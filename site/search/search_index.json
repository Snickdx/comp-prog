{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programming Techniques Guide","text":"<p>Welcome to the comprehensive guide to programming techniques and algorithms! This documentation covers essential techniques used in competitive programming, software development, and algorithmic problem-solving.</p>"},{"location":"#categories","title":"Categories","text":"<p>Our techniques are organized into the following categories:</p>"},{"location":"#brute-force-search-enumeration","title":"\ud83d\udd0d Brute Force &amp; Search Enumeration","text":"<p>Techniques for systematically exploring solution spaces and finding optimal solutions through exhaustive search methods.</p>"},{"location":"#counting-frequency-and-precomputation","title":"\ud83d\udcca Counting, Frequency, and Precomputation","text":"<p>Methods for efficiently counting elements, managing frequencies, and preprocessing data for faster queries.</p>"},{"location":"#dynamic-programming-dp","title":"\ud83c\udfaf Dynamic Programming (DP)","text":"<p>Advanced techniques for solving complex problems by breaking them down into simpler subproblems.</p>"},{"location":"#graph-network-modeling","title":"\ud83c\udf10 Graph &amp; Network Modeling","text":"<p>Algorithms and techniques for working with graphs, networks, and relational data structures.</p>"},{"location":"#geometry-spatial-modeling","title":"\ud83d\udcd0 Geometry &amp; Spatial Modeling","text":"<p>Mathematical approaches for solving geometric and spatial problems efficiently.</p>"},{"location":"#string-bitwise-techniques","title":"\ud83d\udd24 String &amp; Bitwise Techniques","text":"<p>Specialized algorithms for string manipulation and bitwise operations.</p>"},{"location":"#simulation-modeling","title":"\ud83c\udfae Simulation &amp; Modeling","text":"<p>Techniques for simulating real-world scenarios and modeling complex systems.</p>"},{"location":"#data-structures","title":"\ud83c\udfd7\ufe0f Data Structures","text":"<p>Essential data structures and their applications in algorithm design.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Each category contains: - Overview: Introduction to the category and its techniques - Individual Technique Pages: Detailed explanations with examples and use cases</p> <p>Navigate through the categories using the sidebar or the tabs above to explore specific techniques.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>This documentation is designed to be a living resource. Feel free to contribute improvements, examples, or additional techniques!</p>"},{"location":"brute-force/","title":"Brute Force &amp; Search Enumeration","text":"<p>Brute force and search enumeration techniques involve systematically exploring all possible solutions to find the optimal one. While these methods may seem computationally expensive, they are often the most straightforward approach and can be optimized through various techniques.</p>"},{"location":"brute-force/#techniques-in-this-category","title":"Techniques in This Category","text":""},{"location":"brute-force/#boolean-counter-enumeration","title":"Boolean Counter Enumeration","text":"<p>A systematic approach to generating all possible combinations using binary representations and bit manipulation.</p>"},{"location":"brute-force/#recursive-backtracking","title":"Recursive Backtracking","text":"<p>A powerful technique that explores all possible solutions by building them incrementally and backtracking when a solution becomes invalid.</p>"},{"location":"brute-force/#meet-in-the-middle","title":"Meet-in-the-Middle","text":"<p>An optimization technique that splits the search space in half, solving each half independently and then combining the results.</p>"},{"location":"brute-force/#permutation-enumeration","title":"Permutation Enumeration","text":"<p>Methods for generating and working with all possible arrangements of elements.</p>"},{"location":"brute-force/#when-to-use","title":"When to Use","text":"<p>These techniques are particularly useful when: - The problem space is small enough to explore exhaustively - You need to find the optimal solution among all possibilities - Other optimization techniques are not applicable - You're dealing with combinatorial problems</p>"},{"location":"brute-force/#complexity-considerations","title":"Complexity Considerations","text":"<p>While brute force methods guarantee finding the optimal solution, they often have exponential time complexity. The key is to: - Prune unnecessary branches early - Use efficient data structures - Apply optimizations like memoization when possible</p>"},{"location":"brute-force/boolean-counter/","title":"Boolean Counter Enumeration","text":"<p>Boolean counter enumeration is a systematic approach to generating all possible combinations using binary representations and bit manipulation. This technique is particularly useful when you need to explore all subsets of a given set.</p>"},{"location":"brute-force/boolean-counter/#how-it-works","title":"How It Works","text":"<p>The technique uses the binary representation of numbers to represent different combinations: - Each bit position represents whether an element is included (1) or excluded (0) - Numbers from 0 to 2^n - 1 represent all possible subsets of n elements</p>"},{"location":"brute-force/boolean-counter/#algorithm","title":"Algorithm","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; generateSubsets(vector&lt;int&gt;&amp; elements) {\n    int n = elements.size();\n    vector&lt;vector&lt;int&gt;&gt; subsets;\n\n    // Generate all possible subsets using bit manipulation\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {  // 2^n combinations\n        vector&lt;int&gt; subset;\n        for (int j = 0; j &lt; n; j++) {\n            if (i &amp; (1 &lt;&lt; j)) {  // Check if j-th bit is set\n                subset.push_back(elements[j]);\n            }\n        }\n        subsets.push_back(subset);\n    }\n\n    return subsets;\n}\n</code></pre>"},{"location":"brute-force/boolean-counter/#example-subset-sum-problem","title":"Example: Subset Sum Problem","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; subsetSum(vector&lt;int&gt;&amp; arr, int target) {\n    int n = arr.size();\n\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {\n        int currentSum = 0;\n        vector&lt;int&gt; subset;\n\n        for (int j = 0; j &lt; n; j++) {\n            if (i &amp; (1 &lt;&lt; j)) {\n                currentSum += arr[j];\n                subset.push_back(arr[j]);\n            }\n        }\n\n        if (currentSum == target) {\n            return subset;\n        }\n    }\n\n    return {};  // No subset found\n}\n</code></pre>"},{"location":"brute-force/boolean-counter/#use-cases","title":"Use Cases","text":"<ul> <li>Subset Problems: Finding all subsets that satisfy certain conditions</li> <li>Combination Generation: Generating all possible combinations of elements</li> <li>Knapsack Problems: Exploring all possible item selections</li> <li>Permutation Problems: When combined with other techniques</li> </ul>"},{"location":"brute-force/boolean-counter/#complexity","title":"Complexity","text":"<ul> <li>Time Complexity: O(2^n \u00d7 n) for generating all subsets</li> <li>Space Complexity: O(2^n) for storing all subsets</li> </ul>"},{"location":"brute-force/boolean-counter/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Early Termination: Stop when you find the first valid solution</li> <li>Pruning: Skip combinations that can't lead to valid solutions</li> <li>Bit Manipulation: Use efficient bit operations for checking set membership</li> <li>Memoization: Cache results for repeated subproblems when applicable</li> </ol>"},{"location":"brute-force/recursive-backtracking/","title":"Recursive Backtracking","text":"<p>Recursive backtracking is a powerful technique that explores all possible solutions by building them incrementally and backtracking when a solution becomes invalid. It's particularly effective for constraint satisfaction problems and combinatorial optimization.</p>"},{"location":"brute-force/recursive-backtracking/#how-it-works","title":"How It Works","text":"<p>The algorithm follows these steps: 1. Choose: Make a choice for the current step 2. Explore: Recursively solve the remaining problem 3. Unchoose: Backtrack if the choice doesn't lead to a solution</p>"},{"location":"brute-force/recursive-backtracking/#basic-template","title":"Basic Template","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nbool backtrack(vector&lt;int&gt;&amp; currentState, vector&lt;int&gt;&amp; remainingChoices) {\n    // Base case: solution found\n    if (isSolution(currentState)) {\n        return true;\n    }\n\n    // Try each possible choice\n    for (int i = 0; i &lt; remainingChoices.size(); i++) {\n        int choice = remainingChoices[i];\n        if (isValidChoice(currentState, choice)) {\n            // Make the choice\n            currentState.push_back(choice);\n            remainingChoices.erase(remainingChoices.begin() + i);\n\n            // Recursively explore\n            if (backtrack(currentState, remainingChoices)) {\n                return true;\n            }\n\n            // Backtrack: undo the choice\n            currentState.pop_back();\n            remainingChoices.insert(remainingChoices.begin() + i, choice);\n        }\n    }\n\n    return false;  // No solution found\n}\n</code></pre>"},{"location":"brute-force/recursive-backtracking/#example-n-queens-problem","title":"Example: N-Queens Problem","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass NQueens {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; board;\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; solutions;\n    int n;\n\n    bool isSafe(int row, int col) {\n        // Check column\n        for (int i = 0; i &lt; row; i++) {\n            if (board[i][col] == 1) {\n                return false;\n            }\n        }\n\n        // Check diagonals\n        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {\n            if (board[i][j] == 1) {\n                return false;\n            }\n        }\n\n        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {\n            if (board[i][j] == 1) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    void backtrack(int row) {\n        if (row == n) {\n            solutions.push_back(board);\n            return;\n        }\n\n        for (int col = 0; col &lt; n; col++) {\n            if (isSafe(row, col)) {\n                board[row][col] = 1;\n                backtrack(row + 1);\n                board[row][col] = 0;  // Backtrack\n            }\n        }\n    }\n\npublic:\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; solveNQueens(int n) {\n        this-&gt;n = n;\n        board = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0));\n        solutions.clear();\n        backtrack(0);\n        return solutions;\n    }\n};\n</code></pre>"},{"location":"brute-force/recursive-backtracking/#common-applications","title":"Common Applications","text":"<ul> <li>Constraint Satisfaction: Sudoku, crossword puzzles</li> <li>Combinatorial Problems: Permutations, combinations</li> <li>Path Finding: Maze solving, Hamiltonian paths</li> <li>Game Playing: Chess, checkers endgame analysis</li> </ul>"},{"location":"brute-force/recursive-backtracking/#optimization-techniques","title":"Optimization Techniques","text":"<ol> <li>Pruning: Eliminate branches that can't lead to solutions</li> <li>Heuristics: Order choices to find solutions faster</li> <li>Memoization: Cache results for repeated subproblems</li> <li>Constraint Propagation: Use constraints to reduce search space</li> </ol>"},{"location":"brute-force/recursive-backtracking/#complexity-considerations","title":"Complexity Considerations","text":"<ul> <li>Time Complexity: Often exponential, but pruning can significantly improve performance</li> <li>Space Complexity: O(depth) for recursion stack</li> <li>Best Case: O(1) if solution is found immediately</li> <li>Worst Case: O(b^d) where b is branching factor and d is depth</li> </ul>"},{"location":"counting/","title":"Counting, Frequency, and Precomputation","text":"<p>This category covers techniques for efficiently counting elements, managing frequencies, and preprocessing data to enable faster queries. These methods are fundamental to many algorithmic solutions and are often used as building blocks for more complex algorithms.</p>"},{"location":"counting/#techniques-in-this-category","title":"Techniques in This Category","text":""},{"location":"counting/#frequency-counting-arrays","title":"Frequency Counting Arrays","text":"<p>Using arrays to count occurrences of elements, enabling O(1) lookups for frequency queries.</p>"},{"location":"counting/#prefix-difference-arrays","title":"Prefix / Difference Arrays","text":"<p>Precomputing prefix sums or differences to answer range queries in constant time.</p>"},{"location":"counting/#sieve-of-eratosthenes","title":"Sieve of Eratosthenes","text":"<p>An efficient algorithm for finding all prime numbers up to a given limit through systematic elimination.</p>"},{"location":"counting/#when-to-use","title":"When to Use","text":"<p>These techniques are essential when: - You need to answer multiple queries about ranges or frequencies - Working with statistical data or counting problems - Optimizing repeated computations - Building foundations for more complex algorithms</p>"},{"location":"counting/#key-benefits","title":"Key Benefits","text":"<ul> <li>Time Complexity: Often reduces query time from O(n) to O(1)</li> <li>Space Efficiency: Uses simple data structures like arrays</li> <li>Simplicity: Easy to implement and understand</li> <li>Versatility: Applicable to a wide range of problems</li> </ul>"},{"location":"counting/frequency-arrays/","title":"Frequency Counting Arrays","text":"<p>Frequency counting arrays are a simple yet powerful technique for counting occurrences of elements in a dataset. By using arrays to store counts, we can achieve O(1) lookup time for frequency queries.</p>"},{"location":"counting/frequency-arrays/#how-it-works","title":"How It Works","text":"<p>The technique uses an array where: - Index represents the element value - Value at index represents the frequency/count of that element</p>"},{"location":"counting/frequency-arrays/#basic-implementation","title":"Basic Implementation","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvector&lt;int&gt; countFrequencies(vector&lt;int&gt;&amp; arr) {\n    if (arr.empty()) return {};\n\n    // Find the maximum value to determine array size\n    int maxVal = *max_element(arr.begin(), arr.end());\n    vector&lt;int&gt; freq(maxVal + 1, 0);\n\n    // Count frequencies\n    for (int num : arr) {\n        freq[num]++;\n    }\n\n    return freq;\n}\n\nint getFrequency(vector&lt;int&gt;&amp; freq, int value) {\n    if (value &lt; freq.size()) {\n        return freq[value];\n    }\n    return 0;\n}\n</code></pre>"},{"location":"counting/frequency-arrays/#example-character-frequency-in-string","title":"Example: Character Frequency in String","text":"<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; charFrequency(string text) {\n    // For ASCII characters (0-127)\n    vector&lt;int&gt; freq(128, 0);\n\n    for (char c : text) {\n        freq[c]++;\n    }\n\n    return freq;\n}\n\nchar mostFrequentChar(string text) {\n    vector&lt;int&gt; freq = charFrequency(text);\n    int maxFreq = *max_element(freq.begin(), freq.end());\n\n    for (int i = 0; i &lt; freq.size(); i++) {\n        if (freq[i] == maxFreq) {\n            return (char)i;\n        }\n    }\n    return '\\0';\n}\n</code></pre>"},{"location":"counting/frequency-arrays/#advanced-applications","title":"Advanced Applications","text":""},{"location":"counting/frequency-arrays/#counting-sort","title":"Counting Sort","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvector&lt;int&gt; countingSort(vector&lt;int&gt;&amp; arr) {\n    if (arr.empty()) return {};\n\n    int maxVal = *max_element(arr.begin(), arr.end());\n    vector&lt;int&gt; freq(maxVal + 1, 0);\n\n    // Count frequencies\n    for (int num : arr) {\n        freq[num]++;\n    }\n\n    // Reconstruct sorted array\n    vector&lt;int&gt; result;\n    for (int i = 0; i &lt; freq.size(); i++) {\n        for (int j = 0; j &lt; freq[i]; j++) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"counting/frequency-arrays/#finding-duplicates","title":"Finding Duplicates","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nvector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; arr) {\n    unordered_map&lt;int, int&gt; freq;\n    vector&lt;int&gt; duplicates;\n\n    for (int num : arr) {\n        freq[num]++;\n        if (freq[num] == 2) {  // First duplicate\n            duplicates.push_back(num);\n        }\n    }\n\n    return duplicates;\n}\n</code></pre>"},{"location":"counting/frequency-arrays/#use-cases","title":"Use Cases","text":"<ul> <li>Sorting: Counting sort for small integer ranges</li> <li>Duplicate Detection: Finding repeated elements</li> <li>Anagram Detection: Comparing character frequencies</li> <li>Mode Finding: Finding most frequent elements</li> <li>Data Analysis: Statistical analysis of datasets</li> </ul>"},{"location":"counting/frequency-arrays/#space-time-tradeoffs","title":"Space-Time Tradeoffs","text":""},{"location":"counting/frequency-arrays/#array-based-when-values-are-small-integers","title":"Array-based (when values are small integers)","text":"<ul> <li>Time: O(n) for counting, O(1) for lookup</li> <li>Space: O(max_value) for frequency array</li> </ul>"},{"location":"counting/frequency-arrays/#hash-map-based-for-arbitrary-values","title":"Hash Map-based (for arbitrary values)","text":"<ul> <li>Time: O(n) for counting, O(1) average for lookup</li> <li>Space: O(unique_values) for hash map</li> </ul>"},{"location":"counting/frequency-arrays/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Range Optimization: Use arrays only when value range is small</li> <li>Memory Efficiency: Consider using hash maps for sparse data</li> <li>Batch Operations: Process multiple queries together</li> <li>Lazy Evaluation: Compute frequencies only when needed</li> </ol>"},{"location":"counting/prefix-arrays/","title":"Prefix / Difference Arrays","text":"<p>Prefix arrays and difference arrays are powerful techniques for efficiently answering range queries. Prefix arrays precompute cumulative sums, while difference arrays enable efficient range updates.</p>"},{"location":"counting/prefix-arrays/#prefix-arrays","title":"Prefix Arrays","text":"<p>Prefix arrays store cumulative sums, allowing O(1) range sum queries.</p>"},{"location":"counting/prefix-arrays/#implementation","title":"Implementation","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; buildPrefixArray(vector&lt;int&gt;&amp; arr) {\n    int n = arr.size();\n    vector&lt;int&gt; prefix(n + 1, 0);\n\n    for (int i = 0; i &lt; n; i++) {\n        prefix[i + 1] = prefix[i] + arr[i];\n    }\n\n    return prefix;\n}\n\nint rangeSum(vector&lt;int&gt;&amp; prefix, int left, int right) {\n    return prefix[right + 1] - prefix[left];\n}\n</code></pre>"},{"location":"counting/prefix-arrays/#example-usage","title":"Example Usage","text":"<pre><code>vector&lt;int&gt; arr = {1, 2, 3, 4, 5};\nvector&lt;int&gt; prefix = buildPrefixArray(arr);\n// prefix = {0, 1, 3, 6, 10, 15}\n\n// Sum from index 1 to 3 (inclusive)\nint sum_1_3 = rangeSum(prefix, 1, 3);  // 2 + 3 + 4 = 9\n</code></pre>"},{"location":"counting/prefix-arrays/#difference-arrays","title":"Difference Arrays","text":"<p>Difference arrays enable efficient range updates by storing differences between consecutive elements.</p>"},{"location":"counting/prefix-arrays/#implementation_1","title":"Implementation","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; buildDifferenceArray(vector&lt;int&gt;&amp; arr) {\n    int n = arr.size();\n    vector&lt;int&gt; diff(n, 0);\n    diff[0] = arr[0];\n\n    for (int i = 1; i &lt; n; i++) {\n        diff[i] = arr[i] - arr[i - 1];\n    }\n\n    return diff;\n}\n\nvoid rangeUpdate(vector&lt;int&gt;&amp; diff, int left, int right, int value) {\n    diff[left] += value;\n    if (right + 1 &lt; diff.size()) {\n        diff[right + 1] -= value;\n    }\n}\n\nvector&lt;int&gt; reconstructArray(vector&lt;int&gt;&amp; diff) {\n    vector&lt;int&gt; arr(diff.size(), 0);\n    arr[0] = diff[0];\n\n    for (int i = 1; i &lt; diff.size(); i++) {\n        arr[i] = arr[i - 1] + diff[i];\n    }\n\n    return arr;\n}\n</code></pre>"},{"location":"counting/prefix-arrays/#example-range-updates","title":"Example: Range Updates","text":"<pre><code>// Original array\nvector&lt;int&gt; arr = {1, 2, 3, 4, 5};\nvector&lt;int&gt; diff = buildDifferenceArray(arr);\n\n// Add 2 to elements from index 1 to 3\nrangeUpdate(diff, 1, 3, 2);\n\n// Reconstruct the updated array\nvector&lt;int&gt; updatedArr = reconstructArray(diff);\n// Result: {1, 4, 5, 6, 5}\n</code></pre>"},{"location":"counting/prefix-arrays/#advanced-applications","title":"Advanced Applications","text":""},{"location":"counting/prefix-arrays/#2d-prefix-arrays","title":"2D Prefix Arrays","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; build2DPrefix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n    int rows = matrix.size(), cols = matrix[0].size();\n    vector&lt;vector&lt;int&gt;&gt; prefix(rows + 1, vector&lt;int&gt;(cols + 1, 0));\n\n    for (int i = 0; i &lt; rows; i++) {\n        for (int j = 0; j &lt; cols; j++) {\n            prefix[i + 1][j + 1] = matrix[i][j] + \n                                   prefix[i][j + 1] + \n                                   prefix[i + 1][j] - \n                                   prefix[i][j];\n        }\n    }\n\n    return prefix;\n}\n\nint rectangleSum(vector&lt;vector&lt;int&gt;&gt;&amp; prefix, int r1, int c1, int r2, int c2) {\n    return prefix[r2 + 1][c2 + 1] - \n           prefix[r1][c2 + 1] - \n           prefix[r2 + 1][c1] + \n           prefix[r1][c1];\n}\n</code></pre>"},{"location":"counting/prefix-arrays/#multiple-range-updates","title":"Multiple Range Updates","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; multipleRangeUpdates(vector&lt;int&gt;&amp; diff, \n                                vector&lt;tuple&lt;int, int, int&gt;&gt;&amp; updates) {\n    /*\n    updates: vector of (left, right, value) tuples\n    */\n    for (auto&amp; update : updates) {\n        int left, right, value;\n        tie(left, right, value) = update;\n        rangeUpdate(diff, left, right, value);\n    }\n\n    return reconstructArray(diff);\n}\n</code></pre>"},{"location":"counting/prefix-arrays/#use-cases","title":"Use Cases","text":"<ul> <li>Range Sum Queries: Fast sum queries over ranges</li> <li>Range Updates: Efficient bulk updates</li> <li>Subarray Problems: Maximum subarray, subarray with given sum</li> <li>2D Problems: Rectangle sum queries, image processing</li> <li>Cumulative Analysis: Running totals, moving averages</li> </ul>"},{"location":"counting/prefix-arrays/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"counting/prefix-arrays/#prefix-arrays_1","title":"Prefix Arrays","text":"<ul> <li>Build Time: O(n)</li> <li>Query Time: O(1)</li> <li>Space: O(n)</li> </ul>"},{"location":"counting/prefix-arrays/#difference-arrays_1","title":"Difference Arrays","text":"<ul> <li>Build Time: O(n)</li> <li>Update Time: O(1) per range update</li> <li>Reconstruction Time: O(n)</li> <li>Space: O(n)</li> </ul>"},{"location":"counting/prefix-arrays/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Memory Layout: Use contiguous memory for better cache performance</li> <li>Batch Operations: Process multiple queries together</li> <li>Lazy Reconstruction: Only reconstruct when final array is needed</li> <li>Modular Arithmetic: Handle overflow with modular operations</li> </ol>"},{"location":"data-structures/","title":"Data Structures","text":"<p>Data structures are fundamental building blocks for efficient algorithm design. This category covers advanced data structures that enable fast queries, updates, and specialized operations essential for solving complex computational problems.</p>"},{"location":"data-structures/#techniques-in-this-category","title":"Techniques in This Category","text":""},{"location":"data-structures/#segment-tree-bit","title":"Segment Tree / BIT","text":"<p>Efficient range query data structures that allow fast updates and range operations, essential for many competitive programming problems.</p>"},{"location":"data-structures/#heap-priority-queue","title":"Heap / Priority Queue","text":"<p>Dynamic data structures for maintaining extremal elements (minimum or maximum) with efficient insertion and deletion operations.</p>"},{"location":"data-structures/#disjoint-set-dsu","title":"Disjoint Set (DSU)","text":"<p>A data structure for efficiently managing disjoint sets, commonly used for connectivity problems and minimum spanning tree algorithms.</p>"},{"location":"data-structures/#when-to-use-advanced-data-structures","title":"When to Use Advanced Data Structures","text":"<p>These data structures are essential when: - You need to perform frequent range queries or updates - Maintaining extremal elements with dynamic operations - Working with connectivity or union-find problems - Optimizing time complexity for repeated operations</p>"},{"location":"data-structures/#common-applications","title":"Common Applications","text":""},{"location":"data-structures/#segment-trees-binary-indexed-trees","title":"Segment Trees &amp; Binary Indexed Trees","text":"<ul> <li>Range Sum Queries: Computing sums over ranges efficiently</li> <li>Range Minimum/Maximum: Finding extremal values in ranges</li> <li>Range Updates: Applying updates to ranges of elements</li> <li>Inversion Counting: Counting inversions in arrays</li> </ul>"},{"location":"data-structures/#heaps-priority-queues","title":"Heaps &amp; Priority Queues","text":"<ul> <li>Dijkstra's Algorithm: Finding shortest paths in graphs</li> <li>Median Maintenance: Keeping track of running median</li> <li>Task Scheduling: Prioritizing tasks based on urgency or importance</li> <li>Merge Operations: Efficiently merging sorted sequences</li> </ul>"},{"location":"data-structures/#disjoint-set-union","title":"Disjoint Set Union","text":"<ul> <li>Connectivity Problems: Determining if elements are connected</li> <li>Minimum Spanning Tree: Kruskal's algorithm implementation</li> <li>Cycle Detection: Detecting cycles in undirected graphs</li> <li>Component Analysis: Analyzing connected components</li> </ul>"},{"location":"dynamic-programming/","title":"Dynamic Programming (DP)","text":"<p>Dynamic Programming is a powerful algorithmic paradigm that solves complex problems by breaking them down into simpler subproblems and storing the solutions to avoid redundant calculations. It's particularly effective for optimization problems with overlapping subproblems.</p>"},{"location":"dynamic-programming/#techniques-in-this-category","title":"Techniques in This Category","text":""},{"location":"dynamic-programming/#top-down-bottom-up","title":"Top-Down &amp; Bottom-Up","text":"<p>Two fundamental approaches to implementing dynamic programming solutions, each with its own advantages.</p>"},{"location":"dynamic-programming/#bitmask-dp","title":"Bitmask DP","text":"<p>Using bitmasks to represent states in dynamic programming, particularly useful for subset problems and state space optimization.</p>"},{"location":"dynamic-programming/#dp-on-trees-graphs","title":"DP on Trees / Graphs","text":"<p>Applying dynamic programming techniques to tree and graph structures for solving complex traversal and optimization problems.</p>"},{"location":"dynamic-programming/#when-to-use-dynamic-programming","title":"When to Use Dynamic Programming","text":"<p>DP is most effective when: - The problem has optimal substructure - Subproblems overlap (same subproblems are solved multiple times) - You need to find the optimal solution among many possibilities - The problem can be broken down into smaller, similar problems</p>"},{"location":"dynamic-programming/#key-principles","title":"Key Principles","text":"<ol> <li>Optimal Substructure: The optimal solution contains optimal solutions to subproblems</li> <li>Overlapping Subproblems: The same subproblems are solved multiple times</li> <li>Memoization: Store results of subproblems to avoid recomputation</li> <li>State Definition: Clearly define what each state represents</li> </ol>"},{"location":"dynamic-programming/top-down-bottom-up/","title":"Top-Down &amp; Bottom-Up Dynamic Programming","text":"<p>Dynamic Programming can be implemented using two main approaches: Top-Down (memoization) and Bottom-Up (tabulation). Each approach has its advantages and is suitable for different scenarios.</p>"},{"location":"dynamic-programming/top-down-bottom-up/#top-down-memoization","title":"Top-Down (Memoization)","text":"<p>Top-down DP starts with the main problem and recursively breaks it down into smaller subproblems, storing results to avoid recomputation.</p>"},{"location":"dynamic-programming/top-down-bottom-up/#implementation","title":"Implementation","text":"<pre><code>#include &lt;unordered_map&gt;\nusing namespace std;\n\nunordered_map&lt;int, long long&gt; memo;\n\nlong long fibonacciMemo(int n) {\n    if (memo.find(n) != memo.end()) {\n        return memo[n];\n    }\n\n    if (n &lt;= 1) {\n        return n;\n    }\n\n    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);\n    return memo[n];\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#example-longest-common-subsequence","title":"Example: Longest Common Subsequence","text":"<pre><code>#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nunordered_map&lt;string, int&gt; memo;\n\nint lcsMemo(string s1, string s2, int i, int j) {\n    string key = to_string(i) + \",\" + to_string(j);\n    if (memo.find(key) != memo.end()) {\n        return memo[key];\n    }\n\n    if (i == 0 || j == 0) {\n        return 0;\n    }\n\n    int result;\n    if (s1[i - 1] == s2[j - 1]) {\n        result = 1 + lcsMemo(s1, s2, i - 1, j - 1);\n    } else {\n        result = max(lcsMemo(s1, s2, i - 1, j),\n                    lcsMemo(s1, s2, i, j - 1));\n    }\n\n    memo[key] = result;\n    return result;\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#bottom-up-tabulation","title":"Bottom-Up (Tabulation)","text":"<p>Bottom-up DP solves smaller subproblems first and builds up to the main problem using iterative approaches.</p>"},{"location":"dynamic-programming/top-down-bottom-up/#implementation_1","title":"Implementation","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nlong long fibonacciTab(int n) {\n    if (n &lt;= 1) {\n        return n;\n    }\n\n    vector&lt;long long&gt; dp(n + 1, 0);\n    dp[1] = 1;\n\n    for (int i = 2; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    return dp[n];\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#example-longest-common-subsequence_1","title":"Example: Longest Common Subsequence","text":"<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint lcsTab(string s1, string s2) {\n    int m = s1.length(), n = s2.length();\n    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#comparison","title":"Comparison","text":"Aspect Top-Down Bottom-Up Approach Recursive Iterative Memory Only computes needed states Computes all states Stack Space Uses recursion stack No recursion Debugging Easier to trace More complex Space Optimization Harder to optimize Easier to optimize"},{"location":"dynamic-programming/top-down-bottom-up/#space-optimization","title":"Space Optimization","text":""},{"location":"dynamic-programming/top-down-bottom-up/#rolling-array-technique","title":"Rolling Array Technique","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nlong long fibonacciOptimized(int n) {\n    if (n &lt;= 1) {\n        return n;\n    }\n\n    long long prev2 = 0, prev1 = 1;\n\n    for (int i = 2; i &lt;= n; i++) {\n        long long current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n\n    return prev1;\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#2d-to-1d-optimization","title":"2D to 1D Optimization","text":"<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint lcsOptimized(string s1, string s2) {\n    int m = s1.length(), n = s2.length();\n    if (m &lt; n) {\n        swap(s1, s2);\n        swap(m, n);\n    }\n\n    vector&lt;int&gt; prev(n + 1, 0);\n    vector&lt;int&gt; curr(n + 1, 0);\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                curr[j] = 1 + prev[j - 1];\n            } else {\n                curr[j] = max(prev[j], curr[j - 1]);\n            }\n        }\n        prev = curr;\n    }\n\n    return prev[n];\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#when-to-use-each-approach","title":"When to Use Each Approach","text":""},{"location":"dynamic-programming/top-down-bottom-up/#use-top-down-when","title":"Use Top-Down When:","text":"<ul> <li>Problem has complex state transitions</li> <li>Not all states need to be computed</li> <li>Recursive structure is natural</li> <li>Memory is not a constraint</li> </ul>"},{"location":"dynamic-programming/top-down-bottom-up/#use-bottom-up-when","title":"Use Bottom-Up When:","text":"<ul> <li>Need to optimize space complexity</li> <li>All states must be computed</li> <li>Iterative approach is clearer</li> <li>Stack overflow is a concern</li> </ul>"},{"location":"dynamic-programming/top-down-bottom-up/#common-patterns","title":"Common Patterns","text":""},{"location":"dynamic-programming/top-down-bottom-up/#state-transition-patterns","title":"State Transition Patterns","text":"<ol> <li>Linear DP: States depend on previous states</li> <li>Interval DP: States represent intervals</li> <li>Tree DP: States represent tree nodes</li> <li>Bitmask DP: States use bit representations</li> </ol>"},{"location":"dynamic-programming/top-down-bottom-up/#optimization-techniques","title":"Optimization Techniques","text":"<ol> <li>Rolling Arrays: Reduce space from O(n) to O(1)</li> <li>Coordinate Compression: Reduce state space</li> <li>Monotonic Queue: Optimize transitions</li> <li>Convex Hull Trick: Optimize specific functions</li> </ol>"},{"location":"geometry/","title":"Geometry &amp; Spatial Modeling","text":"<p>Geometry and spatial modeling techniques deal with mathematical problems involving points, lines, polygons, and other geometric objects. These algorithms are crucial for computer graphics, computational geometry, and spatial data analysis.</p>"},{"location":"geometry/#techniques-in-this-category","title":"Techniques in This Category","text":""},{"location":"geometry/#sweep-line","title":"Sweep Line","text":"<p>An algorithmic technique that processes geometric events in a sorted order, commonly used for line intersection problems and geometric computations.</p>"},{"location":"geometry/#convex-hull","title":"Convex Hull","text":"<p>Finding the minimal convex polygon that contains all given points, with applications in optimization and geometric analysis.</p>"},{"location":"geometry/#when-to-use-geometric-algorithms","title":"When to Use Geometric Algorithms","text":"<p>Geometric techniques are essential when: - Working with spatial data or coordinates - Solving problems involving points, lines, or polygons - Need to determine geometric relationships - Optimizing spatial queries or computations</p>"},{"location":"geometry/#common-geometric-problems","title":"Common Geometric Problems","text":"<ul> <li>Point-in-Polygon: Determining if a point lies inside a polygon</li> <li>Line Intersection: Finding intersection points between lines or line segments</li> <li>Convex Hull: Finding the smallest convex polygon containing all points</li> <li>Closest Pair: Finding the two closest points in a set</li> <li>Area Calculations: Computing areas of polygons or regions</li> <li>Spatial Indexing: Organizing geometric data for efficient queries</li> </ul>"},{"location":"geometry/#complexity-considerations","title":"Complexity Considerations","text":"<p>Many geometric algorithms have specific complexity characteristics: - Sweep line algorithms often achieve O(n log n) complexity - Convex hull algorithms typically run in O(n log n) time - Spatial data structures can provide O(log n) query times</p>"},{"location":"graph-modeling/","title":"Graph &amp; Network Modeling","text":"<p>Graph and network modeling techniques are essential for solving problems involving relationships, connections, and hierarchical structures. These algorithms form the foundation for many real-world applications including social networks, transportation systems, and computer networks.</p>"},{"location":"graph-modeling/#techniques-in-this-category","title":"Techniques in This Category","text":""},{"location":"graph-modeling/#dfs-bfs","title":"DFS / BFS","text":"<p>Depth-First Search and Breadth-First Search are fundamental graph traversal algorithms with different characteristics and use cases.</p>"},{"location":"graph-modeling/#dijkstra-bellman-ford","title":"Dijkstra / Bellman-Ford","text":"<p>Shortest path algorithms for finding optimal routes in weighted graphs, each suitable for different graph types and constraints.</p>"},{"location":"graph-modeling/#union-find","title":"Union-Find","text":"<p>A data structure and algorithm for efficiently managing disjoint sets, commonly used for connectivity problems and minimum spanning trees.</p>"},{"location":"graph-modeling/#when-to-use-graph-algorithms","title":"When to Use Graph Algorithms","text":"<p>Graph techniques are essential when: - Data has inherent relationships or connections - You need to find paths, cycles, or connectivity - Working with hierarchical or network structures - Solving optimization problems on connected components</p>"},{"location":"graph-modeling/#common-graph-problems","title":"Common Graph Problems","text":"<ul> <li>Shortest Path: Finding the minimum cost path between nodes</li> <li>Connectivity: Determining if nodes are reachable from each other</li> <li>Cycle Detection: Identifying cycles in directed or undirected graphs</li> <li>Topological Sorting: Ordering nodes based on dependencies</li> <li>Minimum Spanning Tree: Finding the minimum cost tree connecting all nodes</li> </ul>"},{"location":"graph-modeling/dfs-bfs/","title":"DFS / BFS","text":"<p>Depth-First Search (DFS) and Breadth-First Search (BFS) are fundamental graph traversal algorithms. They differ in their exploration strategy and are suited for different types of problems.</p>"},{"location":"graph-modeling/dfs-bfs/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":"<p>DFS explores as far as possible along each branch before backtracking. It uses a stack (either explicit or implicit through recursion).</p>"},{"location":"graph-modeling/dfs-bfs/#recursive-implementation","title":"Recursive Implementation","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvoid dfsRecursive(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, unordered_set&lt;int&gt;&amp; visited) {\n    visited.insert(start);\n    cout &lt;&lt; start &lt;&lt; \" \";  // Process node\n\n    for (int neighbor : graph[start]) {\n        if (visited.find(neighbor) == visited.end()) {\n            dfsRecursive(graph, neighbor, visited);\n        }\n    }\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#iterative-implementation","title":"Iterative Implementation","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvoid dfsIterative(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start) {\n    unordered_set&lt;int&gt; visited;\n    stack&lt;int&gt; stk;\n    stk.push(start);\n\n    while (!stk.empty()) {\n        int node = stk.top();\n        stk.pop();\n\n        if (visited.find(node) == visited.end()) {\n            visited.insert(node);\n            cout &lt;&lt; node &lt;&lt; \" \";  // Process node\n\n            // Add neighbors to stack (reverse order for same traversal)\n            for (int i = graph[node].size() - 1; i &gt;= 0; i--) {\n                int neighbor = graph[node][i];\n                if (visited.find(neighbor) == visited.end()) {\n                    stk.push(neighbor);\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":"<p>BFS explores all nodes at the current depth before moving to the next level. It uses a queue to maintain the order of exploration.</p>"},{"location":"graph-modeling/dfs-bfs/#implementation","title":"Implementation","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvoid bfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start) {\n    unordered_set&lt;int&gt; visited;\n    queue&lt;int&gt; q;\n    q.push(start);\n    visited.insert(start);\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        cout &lt;&lt; node &lt;&lt; \" \";  // Process node\n\n        for (int neighbor : graph[node]) {\n            if (visited.find(neighbor) == visited.end()) {\n                visited.insert(neighbor);\n                q.push(neighbor);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#applications","title":"Applications","text":""},{"location":"graph-modeling/dfs-bfs/#dfs-applications","title":"DFS Applications","text":"<ul> <li>Path Finding: Finding any path between two nodes</li> <li>Cycle Detection: Detecting cycles in directed/undirected graphs</li> <li>Topological Sorting: Ordering nodes based on dependencies</li> <li>Connected Components: Finding all connected components</li> <li>Maze Solving: Exploring maze paths</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#bfs-applications","title":"BFS Applications","text":"<ul> <li>Shortest Path: Finding shortest path in unweighted graphs</li> <li>Level Order Traversal: Processing nodes level by level</li> <li>Minimum Spanning Tree: Prim's algorithm</li> <li>Social Network Analysis: Finding degrees of separation</li> <li>Web Crawling: Exploring web pages systematically</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#example-finding-shortest-path","title":"Example: Finding Shortest Path","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvector&lt;int&gt; shortestPathBFS(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int end) {\n    if (start == end) {\n        return {start};\n    }\n\n    unordered_set&lt;int&gt; visited;\n    queue&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt; q;\n    q.push({start, {start}});\n    visited.insert(start);\n\n    while (!q.empty()) {\n        auto [node, path] = q.front();\n        q.pop();\n\n        for (int neighbor : graph[node]) {\n            if (neighbor == end) {\n                path.push_back(neighbor);\n                return path;\n            }\n\n            if (visited.find(neighbor) == visited.end()) {\n                visited.insert(neighbor);\n                vector&lt;int&gt; newPath = path;\n                newPath.push_back(neighbor);\n                q.push({neighbor, newPath});\n            }\n        }\n    }\n\n    return {};  // No path found\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#example-cycle-detection","title":"Example: Cycle Detection","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nbool hasCycleDFS(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {\n    unordered_set&lt;int&gt; visited;\n    unordered_set&lt;int&gt; recStack;\n\n    function&lt;bool(int)&gt; dfs = [&amp;](int node) -&gt; bool {\n        visited.insert(node);\n        recStack.insert(node);\n\n        for (int neighbor : graph[node]) {\n            if (visited.find(neighbor) == visited.end()) {\n                if (dfs(neighbor)) {\n                    return true;\n                }\n            } else if (recStack.find(neighbor) != recStack.end()) {\n                return true;\n            }\n        }\n\n        recStack.erase(node);\n        return false;\n    };\n\n    for (int node = 0; node &lt; graph.size(); node++) {\n        if (visited.find(node) == visited.end()) {\n            if (dfs(node)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"graph-modeling/dfs-bfs/#time-complexity","title":"Time Complexity","text":"<ul> <li>DFS: O(V + E) where V is vertices, E is edges</li> <li>BFS: O(V + E) where V is vertices, E is edges</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#space-complexity","title":"Space Complexity","text":"<ul> <li>DFS: O(V) for recursion stack or explicit stack</li> <li>BFS: O(V) for queue and visited set</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#when-to-use-each","title":"When to Use Each","text":""},{"location":"graph-modeling/dfs-bfs/#use-dfs-when","title":"Use DFS When:","text":"<ul> <li>Need to explore all possible paths</li> <li>Memory is limited (uses less memory than BFS)</li> <li>Looking for any solution (not necessarily shortest)</li> <li>Working with tree-like structures</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#use-bfs-when","title":"Use BFS When:","text":"<ul> <li>Need shortest path in unweighted graphs</li> <li>Want to explore nodes level by level</li> <li>Need to find minimum distance</li> <li>Working with social networks or similar structures</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#advanced-variations","title":"Advanced Variations","text":""},{"location":"graph-modeling/dfs-bfs/#bidirectional-bfs","title":"Bidirectional BFS","text":"<pre><code>def bidirectional_bfs(graph, start, end):\n    if start == end:\n        return [start]\n\n    visited_start = {start: [start]}\n    visited_end = {end: [end]}\n    queue_start = deque([start])\n    queue_end = deque([end])\n\n    while queue_start and queue_end:\n        # Expand from start\n        node = queue_start.popleft()\n        for neighbor in graph[node]:\n            if neighbor in visited_end:\n                return visited_start[node] + visited_end[neighbor][::-1]\n            if neighbor not in visited_start:\n                visited_start[neighbor] = visited_start[node] + [neighbor]\n                queue_start.append(neighbor)\n\n        # Expand from end\n        node = queue_end.popleft()\n        for neighbor in graph[node]:\n            if neighbor in visited_start:\n                return visited_start[neighbor] + visited_end[node][::-1]\n            if neighbor not in visited_end:\n                visited_end[neighbor] = visited_end[node] + [neighbor]\n                queue_end.append(neighbor)\n\n    return None\n</code></pre>"},{"location":"simulation/","title":"Simulation &amp; Modeling","text":"<p>Simulation and modeling techniques involve creating computational models to represent real-world scenarios or abstract problems. These methods are particularly useful for problems that require systematic exploration of solution spaces or optimization with specific constraints.</p>"},{"location":"simulation/#techniques-in-this-category","title":"Techniques in This Category","text":""},{"location":"simulation/#two-pointer-sliding-window","title":"Two Pointer / Sliding Window","text":"<p>Efficient techniques for maintaining a dynamic range or window while processing data, commonly used for subarray problems.</p>"},{"location":"simulation/#binary-search-on-answer","title":"Binary Search on Answer","text":"<p>An optimization technique that searches for the optimal parameter value using binary search, particularly useful when the problem has monotonic properties.</p>"},{"location":"simulation/#greedy-algorithms","title":"Greedy Algorithms","text":"<p>Algorithms that make locally optimal choices at each step, often leading to globally optimal solutions for certain types of problems.</p>"},{"location":"simulation/#when-to-use-simulation-modeling","title":"When to Use Simulation &amp; Modeling","text":"<p>These techniques are effective when: - You need to explore a range of possible solutions - The problem has monotonic or predictable properties - Local optimization can lead to global optimization - Working with constrained optimization problems</p>"},{"location":"simulation/#common-problem-types","title":"Common Problem Types","text":""},{"location":"simulation/#sliding-window-problems","title":"Sliding Window Problems","text":"<ul> <li>Maximum/Minimum Subarray: Finding optimal subarrays of fixed or variable size</li> <li>String Matching: Finding patterns or anagrams in strings</li> <li>Resource Allocation: Optimizing resource usage within constraints</li> </ul>"},{"location":"simulation/#binary-search-applications","title":"Binary Search Applications","text":"<ul> <li>Parameter Optimization: Finding optimal values for problem parameters</li> <li>Feasibility Testing: Determining if a solution exists for given constraints</li> <li>Range Queries: Finding values within specific ranges</li> </ul>"},{"location":"simulation/#greedy-applications","title":"Greedy Applications","text":"<ul> <li>Scheduling: Optimizing task or resource scheduling</li> <li>Coin Change: Finding minimum number of coins for change</li> <li>Huffman Coding: Optimal data compression</li> <li>Minimum Spanning Tree: Finding optimal tree structures</li> </ul>"},{"location":"simulation/two-pointer-sliding-window/","title":"Two Pointer / Sliding Window","text":"<p>Two pointer and sliding window techniques are efficient methods for solving problems involving arrays or sequences. They maintain a dynamic range or window while processing data, often achieving O(n) time complexity.</p>"},{"location":"simulation/two-pointer-sliding-window/#two-pointer-technique","title":"Two Pointer Technique","text":"<p>Two pointers move through the array from different positions, typically from both ends or at different speeds.</p>"},{"location":"simulation/two-pointer-sliding-window/#basic-template","title":"Basic Template","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvoid twoPointers(vector&lt;int&gt;&amp; arr) {\n    int left = 0, right = arr.size() - 1;\n\n    while (left &lt; right) {\n        // Process current pair\n        if (conditionMet(arr[left], arr[right])) {\n            // Handle the case\n            left++;\n            right--;\n        } else if (arr[left] &lt; arr[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n}\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#example-two-sum-sorted-array","title":"Example: Two Sum (Sorted Array)","text":"<pre><code>def two_sum_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left &lt; right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum &lt; target:\n            left += 1\n        else:\n            right -= 1\n\n    return None\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#sliding-window-technique","title":"Sliding Window Technique","text":"<p>A sliding window maintains a subarray/substring of variable or fixed size while moving through the array.</p>"},{"location":"simulation/two-pointer-sliding-window/#fixed-size-window","title":"Fixed Size Window","text":"<pre><code>def sliding_window_fixed(arr, k):\n    if len(arr) &lt; k:\n        return []\n\n    window_sum = sum(arr[:k])\n    max_sum = window_sum\n\n    for i in range(k, len(arr)):\n        window_sum = window_sum - arr[i-k] + arr[i]\n        max_sum = max(max_sum, window_sum)\n\n    return max_sum\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#variable-size-window","title":"Variable Size Window","text":"<pre><code>def sliding_window_variable(arr, target):\n    left = 0\n    window_sum = 0\n    min_length = float('inf')\n\n    for right in range(len(arr)):\n        window_sum += arr[right]\n\n        while window_sum &gt;= target:\n            min_length = min(min_length, right - left + 1)\n            window_sum -= arr[left]\n            left += 1\n\n    return min_length if min_length != float('inf') else 0\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#common-applications","title":"Common Applications","text":""},{"location":"simulation/two-pointer-sliding-window/#maximum-subarray-sum","title":"Maximum Subarray Sum","text":"<pre><code>def max_subarray_sum(arr):\n    max_sum = current_sum = arr[0]\n\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#longest-substring-without-repeating-characters","title":"Longest Substring Without Repeating Characters","text":"<pre><code>def longest_unique_substring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#container-with-most-water","title":"Container With Most Water","text":"<pre><code>def max_area(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n\n    while left &lt; right:\n        width = right - left\n        current_area = width * min(height[left], height[right])\n        max_area = max(max_area, current_area)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return max_area\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"simulation/two-pointer-sliding-window/#fast-and-slow-pointers","title":"Fast and Slow Pointers","text":"<pre><code>def detect_cycle(head):\n    slow = fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#three-pointers","title":"Three Pointers","text":"<pre><code>def three_sum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i &gt; 0 and nums[i] == nums[i-1]:\n            continue\n\n        left, right = i + 1, len(nums) - 1\n\n        while left &lt; right:\n            current_sum = nums[i] + nums[left] + nums[right]\n\n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left+1]:\n                    left += 1\n                while left &lt; right and nums[right] == nums[right-1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n            elif current_sum &lt; 0:\n                left += 1\n            else:\n                right -= 1\n\n    return result\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#when-to-use-each-technique","title":"When to Use Each Technique","text":""},{"location":"simulation/two-pointer-sliding-window/#use-two-pointers-when","title":"Use Two Pointers When:","text":"<ul> <li>Array is sorted</li> <li>Need to find pairs/triplets</li> <li>Working with palindromes</li> <li>Need to partition array</li> </ul>"},{"location":"simulation/two-pointer-sliding-window/#use-sliding-window-when","title":"Use Sliding Window When:","text":"<ul> <li>Working with subarrays/substrings</li> <li>Need to find optimal window size</li> <li>Problem involves contiguous elements</li> <li>Need to maintain running statistics</li> </ul>"},{"location":"simulation/two-pointer-sliding-window/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Time Complexity: Usually O(n) for single pass</li> <li>Space Complexity: Usually O(1) for two pointers, O(k) for sliding window where k is window size</li> </ul>"},{"location":"simulation/two-pointer-sliding-window/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Early Termination: Stop when condition is met</li> <li>Skip Duplicates: Avoid processing duplicate elements</li> <li>Boundary Checks: Always check array bounds</li> <li>State Maintenance: Keep track of window state efficiently</li> <li>Memory Optimization: Use variables instead of data structures when possible</li> </ol>"},{"location":"string-bitwise/","title":"String &amp; Bitwise Techniques","text":"<p>String and bitwise techniques involve specialized algorithms for text processing, pattern matching, and bit manipulation. These methods are essential for text analysis, data compression, and optimization problems that can be solved using bitwise operations.</p>"},{"location":"string-bitwise/#techniques-in-this-category","title":"Techniques in This Category","text":""},{"location":"string-bitwise/#kmp-z-algorithm","title":"KMP / Z Algorithm","text":"<p>Efficient pattern matching algorithms for finding substring occurrences in text, with linear time complexity.</p>"},{"location":"string-bitwise/#trie-aho-corasick","title":"Trie / Aho-Corasick","text":"<p>Tree-based data structures for prefix matching and multiple pattern searching, commonly used in autocomplete systems.</p>"},{"location":"string-bitwise/#bitmask-tricks","title":"Bitmask Tricks","text":"<p>Bitwise manipulation techniques for representing and manipulating subsets, often used for optimization and state representation.</p>"},{"location":"string-bitwise/#when-to-use-string-bitwise-techniques","title":"When to Use String &amp; Bitwise Techniques","text":"<p>These techniques are essential when: - Working with text processing and pattern matching - Need to represent subsets or states efficiently - Solving problems that can benefit from bitwise operations - Building search engines or text analysis systems</p>"},{"location":"string-bitwise/#common-applications","title":"Common Applications","text":""},{"location":"string-bitwise/#string-algorithms","title":"String Algorithms","text":"<ul> <li>Pattern Matching: Finding occurrences of patterns in text</li> <li>String Comparison: Efficient string similarity and distance calculations</li> <li>Text Compression: Reducing storage requirements for text data</li> <li>Lexicographic Sorting: Ordering strings alphabetically</li> </ul>"},{"location":"string-bitwise/#bitwise-techniques","title":"Bitwise Techniques","text":"<ul> <li>Subset Generation: Efficiently generating all subsets of a set</li> <li>State Representation: Compact representation of problem states</li> <li>Optimization: Using bitwise operations for performance improvements</li> <li>Parity Checking: Detecting even/odd properties using XOR</li> </ul>"}]}