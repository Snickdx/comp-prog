{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programming Techniques Guide","text":"<p>Welcome to the comprehensive guide to programming techniques and algorithms! This documentation covers essential techniques used in competitive programming, software development, and algorithmic problem-solving.</p>"},{"location":"#categories-techniques","title":"Categories &amp; Techniques","text":"<p>Our techniques are organized into the following categories with their respective techniques:</p> Category Description Techniques \ud83d\udd0d Brute Force &amp; Search Techniques for systematically exploring solution spaces and finding optimal solutions through exhaustive search methods. Boolean Counter \u2022 Recursive Backtracking \u2022 Meet-in-the-Middle \u2022 Permutation Enumeration \ud83d\udcca Counting &amp; Precomputation Methods for efficiently counting elements, managing frequencies, and preprocessing data for faster queries. Frequency Arrays \u2022 Prefix Arrays \u2022 Sieve of Eratosthenes \ud83c\udfaf Dynamic Programming Advanced techniques for solving complex problems by breaking them down into simpler subproblems. Top-Down &amp; Bottom-Up \u2022 Bitmask DP \u2022 DP on Trees / Graphs \ud83c\udf10 Graph &amp; Network Modeling Algorithms and techniques for working with graphs, networks, and relational data structures. DFS / BFS \u2022 Dijkstra / Bellman-Ford \u2022 Union-Find \ud83d\udcd0 Geometry &amp; Spatial Modeling Mathematical approaches for solving geometric and spatial problems efficiently. Sweep Line \u2022 Convex Hull \ud83d\udd24 String &amp; Bitwise Techniques Specialized algorithms for string manipulation and bitwise operations. KMP / Z Algorithm \u2022 Trie / Aho-Corasick \u2022 Bitmask Tricks \ud83c\udfae Simulation &amp; Modeling Techniques for simulating real-world scenarios and modeling complex systems. Two Pointer / Sliding Window \u2022 Binary Search on Answer \u2022 Greedy Algorithms \ud83c\udfd7\ufe0f Data Structures Essential data structures and their applications in algorithm design. Segment Tree / BIT \u2022 Heap / Priority Queue \u2022 Disjoint Set (DSU) \ud83d\udcd0 Mathematical Formulas Essential mathematical formulas and concepts for geometric, counting, trigonometric, and algebraic problems. Geometric Formulas \u2022 Combinatorics &amp; Counting \u2022 Number Theory \u2022 Trigonometry \u2022 Linear Algebra"},{"location":"#getting-started","title":"Getting Started","text":"<p>Each category contains: - Overview: Introduction to the category and its techniques - Individual Technique Pages: Detailed explanations with examples and use cases</p> <p>Navigate through the categories using the sidebar or the tabs above to explore specific techniques.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>This documentation is designed to be a living resource. Feel free to contribute improvements, examples, or additional techniques!</p>"},{"location":"brute-force/","title":"Brute Force &amp; Search Enumeration","text":"<p>Brute force and search enumeration techniques involve systematically exploring all possible solutions to find the optimal one. While these methods may seem computationally expensive, they are often the most straightforward approach and can be optimized through various techniques.</p>"},{"location":"brute-force/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link Boolean Counter Enumeration A systematic approach to generating all possible combinations using binary representations and bit manipulation. Boolean Counter Recursive Backtracking A powerful technique that explores all possible solutions by building them incrementally and backtracking when a solution becomes invalid. Recursive Backtracking Meet-in-the-Middle An optimization technique that splits the search space in half, solving each half independently and then combining the results. Meet-in-the-Middle Permutation Enumeration Methods for generating and working with all possible arrangements of elements. Permutation Enumeration"},{"location":"brute-force/#when-to-use","title":"When to Use","text":"<p>These techniques are particularly useful when: - The problem space is small enough to explore exhaustively - You need to find the optimal solution among all possibilities - Other optimization techniques are not applicable - You're dealing with combinatorial problems</p>"},{"location":"brute-force/#complexity-considerations","title":"Complexity Considerations","text":"<p>While brute force methods guarantee finding the optimal solution, they often have exponential time complexity. The key is to: - Prune unnecessary branches early - Use efficient data structures - Apply optimizations like memoization when possible</p>"},{"location":"brute-force/boolean-counter/","title":"Boolean Counter Enumeration","text":"<p>Boolean counter enumeration is a systematic approach to generating all possible combinations using binary representations and bit manipulation. This technique is particularly useful when you need to explore all subsets of a given set.</p>"},{"location":"brute-force/boolean-counter/#how-it-works","title":"How It Works","text":"<p>The technique uses the binary representation of numbers to represent different combinations: - Each bit position represents whether an element is included (1) or excluded (0) - Numbers from 0 to 2^n - 1 represent all possible subsets of n elements</p>"},{"location":"brute-force/boolean-counter/#algorithm","title":"Algorithm","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; generateSubsets(vector&lt;int&gt;&amp; elements) {\n    int n = elements.size();\n    vector&lt;vector&lt;int&gt;&gt; subsets;\n\n    // Generate all possible subsets using bit manipulation\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {  // 2^n combinations\n        vector&lt;int&gt; subset;\n        for (int j = 0; j &lt; n; j++) {\n            if (i &amp; (1 &lt;&lt; j)) {  // Check if j-th bit is set\n                subset.push_back(elements[j]);\n            }\n        }\n        subsets.push_back(subset);\n    }\n\n    return subsets;\n}\n</code></pre>"},{"location":"brute-force/boolean-counter/#example-subset-sum-problem","title":"Example: Subset Sum Problem","text":"<p>Problem: Given an array of integers and a target sum, find any subset that adds up to the target sum.</p> <p>Sample Input: <code>arr = [3, 1, 4, 2]</code>, <code>target = 6</code> Sample Output: <code>[3, 1, 2]</code> (or <code>[4, 2]</code>)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; subsetSum(vector&lt;int&gt;&amp; arr, int target) {\n    int n = arr.size();\n\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {\n        int currentSum = 0;\n        vector&lt;int&gt; subset;\n\n        for (int j = 0; j &lt; n; j++) {\n            if (i &amp; (1 &lt;&lt; j)) {\n                currentSum += arr[j];\n                subset.push_back(arr[j]);\n            }\n        }\n\n        if (currentSum == target) {\n            return subset;\n        }\n    }\n\n    return {};  // No subset found\n}\n</code></pre>"},{"location":"brute-force/boolean-counter/#use-cases","title":"Use Cases","text":"<ul> <li>Subset Problems: Finding all subsets that satisfy certain conditions</li> <li>Combination Generation: Generating all possible combinations of elements</li> <li>Knapsack Problems: Exploring all possible item selections</li> <li>Permutation Problems: When combined with other techniques</li> </ul>"},{"location":"brute-force/boolean-counter/#complexity","title":"Complexity","text":"<ul> <li>Time Complexity: O(2^n \u00d7 n) for generating all subsets</li> <li>Space Complexity: O(2^n) for storing all subsets</li> </ul>"},{"location":"brute-force/boolean-counter/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Early Termination: Stop when you find the first valid solution</li> <li>Pruning: Skip combinations that can't lead to valid solutions</li> <li>Bit Manipulation: Use efficient bit operations for checking set membership</li> <li>Memoization: Cache results for repeated subproblems when applicable</li> </ol>"},{"location":"brute-force/meet-in-middle/","title":"Meet-in-the-Middle","text":"<p>Meet-in-the-middle is an optimization technique that splits the search space in half, solves each half independently, and then combines the results. This approach can reduce exponential time complexity from O(2^n) to O(2^(n/2)), making it feasible to solve problems that would otherwise be intractable.</p>"},{"location":"brute-force/meet-in-middle/#how-it-works","title":"How It Works","text":"<ol> <li>Split: Divide the problem into two equal or nearly equal parts</li> <li>Solve Independently: Solve each part separately using brute force</li> <li>Combine: Merge the results from both parts to find the final solution</li> </ol>"},{"location":"brute-force/meet-in-middle/#basic-template","title":"Basic Template","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n// Template for meet-in-the-middle\nvector&lt;int&gt; solveMeetInMiddle(vector&lt;int&gt;&amp; data) {\n    int n = data.size();\n    int mid = n / 2;\n\n    // Split into two halves\n    vector&lt;int&gt; left(data.begin(), data.begin() + mid);\n    vector&lt;int&gt; right(data.begin() + mid, data.end());\n\n    // Solve each half independently\n    vector&lt;int&gt; leftResults = solveHalf(left);\n    vector&lt;int&gt; rightResults = solveHalf(right);\n\n    // Combine results\n    return combineResults(leftResults, rightResults);\n}\n</code></pre>"},{"location":"brute-force/meet-in-middle/#example-subset-sum-problem","title":"Example: Subset Sum Problem","text":"<p>Problem: Find if there exists a subset that sums to a target value using meet-in-the-middle.</p> <p>Sample Input:  - <code>arr = [1, 2, 3, 4, 5, 6]</code> - <code>target = 9</code></p> <p>Sample Output: <code>true</code> (subsets like [1,2,6], [3,6], [4,5] sum to 9)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass SubsetSumMeetInMiddle {\npublic:\n    bool subsetSum(vector&lt;int&gt;&amp; arr, int target) {\n        int n = arr.size();\n        int mid = n / 2;\n\n        // Generate all possible sums for left half\n        vector&lt;int&gt; leftSums = generateSums(arr, 0, mid);\n\n        // Generate all possible sums for right half\n        vector&lt;int&gt; rightSums = generateSums(arr, mid, n);\n\n        // Check if target can be achieved\n        for (int leftSum : leftSums) {\n            if (leftSum == target) return true;\n\n            // Check if right half has target - leftSum\n            if (binary_search(rightSums.begin(), rightSums.end(), target - leftSum)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\nprivate:\n    vector&lt;int&gt; generateSums(vector&lt;int&gt;&amp; arr, int start, int end) {\n        vector&lt;int&gt; sums;\n        int n = end - start;\n\n        // Generate all 2^n possible sums\n        for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {\n            int sum = 0;\n            for (int i = 0; i &lt; n; i++) {\n                if (mask &amp; (1 &lt;&lt; i)) {\n                    sum += arr[start + i];\n                }\n            }\n            sums.push_back(sum);\n        }\n\n        sort(sums.begin(), sums.end());\n        return sums;\n    }\n};\n</code></pre>"},{"location":"brute-force/meet-in-middle/#example-4-sum-problem","title":"Example: 4-Sum Problem","text":"<p>Problem: Find all unique quadruplets that sum to a target value.</p> <p>Sample Input:  - <code>nums = [1, 0, -1, 0, -2, 2]</code> - <code>target = 0</code></p> <p>Sample Output:  <pre><code>[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre></p> <pre><code>#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nclass FourSumMeetInMiddle {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n        int n = nums.size();\n        if (n &lt; 4) return {};\n\n        sort(nums.begin(), nums.end());\n        set&lt;vector&lt;int&gt;&gt; result;\n\n        // Split into two halves\n        int mid = n / 2;\n\n        // Generate all pairs from left half\n        unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; leftPairs;\n        for (int i = 0; i &lt; mid; i++) {\n            for (int j = i + 1; j &lt; mid; j++) {\n                int sum = nums[i] + nums[j];\n                leftPairs[sum].push_back({i, j});\n            }\n        }\n\n        // Generate all pairs from right half\n        unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; rightPairs;\n        for (int i = mid; i &lt; n; i++) {\n            for (int j = i + 1; j &lt; n; j++) {\n                int sum = nums[i] + nums[j];\n                rightPairs[sum].push_back({i, j});\n            }\n        }\n\n        // Combine results\n        for (auto&amp; leftPair : leftPairs) {\n            int leftSum = leftPair.first;\n            int targetRightSum = target - leftSum;\n\n            if (rightPairs.find(targetRightSum) != rightPairs.end()) {\n                for (auto&amp; left : leftPair.second) {\n                    for (auto&amp; right : rightPairs[targetRightSum]) {\n                        vector&lt;int&gt; quadruplet = {\n                            nums[left.first], nums[left.second],\n                            nums[right.first], nums[right.second]\n                        };\n                        sort(quadruplet.begin(), quadruplet.end());\n                        result.insert(quadruplet);\n                    }\n                }\n            }\n        }\n\n        return vector&lt;vector&lt;int&gt;&gt;(result.begin(), result.end());\n    }\n};\n</code></pre>"},{"location":"brute-force/meet-in-middle/#advanced-applications","title":"Advanced Applications","text":""},{"location":"brute-force/meet-in-middle/#closest-subset-sum","title":"Closest Subset Sum","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass ClosestSubsetSum {\npublic:\n    int closestSubsetSum(vector&lt;int&gt;&amp; arr, int target) {\n        int n = arr.size();\n        int mid = n / 2;\n\n        // Generate all possible sums for both halves\n        vector&lt;int&gt; leftSums = generateSums(arr, 0, mid);\n        vector&lt;int&gt; rightSums = generateSums(arr, mid, n);\n\n        sort(leftSums.begin(), leftSums.end());\n        sort(rightSums.begin(), rightSums.end());\n\n        int closest = INT_MAX;\n\n        // For each sum in left half, find closest in right half\n        for (int leftSum : leftSums) {\n            int remaining = target - leftSum;\n\n            // Binary search for closest value\n            auto it = lower_bound(rightSums.begin(), rightSums.end(), remaining);\n\n            if (it != rightSums.end()) {\n                closest = min(closest, abs(target - (leftSum + *it)));\n            }\n            if (it != rightSums.begin()) {\n                closest = min(closest, abs(target - (leftSum + *(it - 1))));\n            }\n        }\n\n        return closest;\n    }\n\nprivate:\n    vector&lt;int&gt; generateSums(vector&lt;int&gt;&amp; arr, int start, int end) {\n        vector&lt;int&gt; sums;\n        int n = end - start;\n\n        for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {\n            int sum = 0;\n            for (int i = 0; i &lt; n; i++) {\n                if (mask &amp; (1 &lt;&lt; i)) {\n                    sum += arr[start + i];\n                }\n            }\n            sums.push_back(sum);\n        }\n\n        return sums;\n    }\n};\n</code></pre>"},{"location":"brute-force/meet-in-middle/#maximum-xor-subset","title":"Maximum XOR Subset","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nclass MaxXORSubset {\npublic:\n    int maxXORSubset(vector&lt;int&gt;&amp; arr) {\n        int n = arr.size();\n        int mid = n / 2;\n\n        // Generate all possible XORs for both halves\n        vector&lt;int&gt; leftXORs = generateXORs(arr, 0, mid);\n        vector&lt;int&gt; rightXORs = generateXORs(arr, mid, n);\n\n        int maxXOR = 0;\n\n        // Try all combinations\n        for (int leftXOR : leftXORs) {\n            for (int rightXOR : rightXORs) {\n                maxXOR = max(maxXOR, leftXOR ^ rightXOR);\n            }\n        }\n\n        return maxXOR;\n    }\n\nprivate:\n    vector&lt;int&gt; generateXORs(vector&lt;int&gt;&amp; arr, int start, int end) {\n        vector&lt;int&gt; xors;\n        int n = end - start;\n\n        for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {\n            int xorSum = 0;\n            for (int i = 0; i &lt; n; i++) {\n                if (mask &amp; (1 &lt;&lt; i)) {\n                    xorSum ^= arr[start + i];\n                }\n            }\n            xors.push_back(xorSum);\n        }\n\n        return xors;\n    }\n};\n</code></pre>"},{"location":"brute-force/meet-in-middle/#use-cases","title":"Use Cases","text":""},{"location":"brute-force/meet-in-middle/#optimization-problems","title":"Optimization Problems","text":"<ul> <li>Subset Sum: Finding subsets that sum to a target</li> <li>Knapsack Variants: When the problem can be split into two parts</li> <li>Partition Problems: Dividing sets into two equal parts</li> <li>Closest Pair: Finding closest elements in high dimensions</li> </ul>"},{"location":"brute-force/meet-in-middle/#search-problems","title":"Search Problems","text":"<ul> <li>4-Sum and Higher: Finding k-tuples that sum to target</li> <li>Maximum XOR: Finding maximum XOR of subsets</li> <li>Palindrome Partitioning: When the problem has symmetric structure</li> <li>Graph Problems: Finding paths or cycles in large graphs</li> </ul>"},{"location":"brute-force/meet-in-middle/#mathematical-problems","title":"Mathematical Problems","text":"<ul> <li>Integer Factorization: When the factors can be split</li> <li>Discrete Logarithm: Cryptographic applications</li> <li>Lattice Problems: Finding shortest vectors</li> <li>Combinatorial Optimization: When the search space can be halved</li> </ul>"},{"location":"brute-force/meet-in-middle/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"brute-force/meet-in-middle/#time-complexity","title":"Time Complexity","text":"<ul> <li>Standard Brute Force: O(2^n)</li> <li>Meet-in-the-Middle: O(2^(n/2) \u00d7 log(2^(n/2))) = O(2^(n/2) \u00d7 n)</li> <li>Space Complexity: O(2^(n/2)) for storing intermediate results</li> </ul>"},{"location":"brute-force/meet-in-middle/#when-to-use-meet-in-the-middle","title":"When to Use Meet-in-the-Middle","text":"<ul> <li>Problem can be naturally split into two independent parts</li> <li>Each part can be solved independently</li> <li>Results can be efficiently combined</li> <li>Standard brute force would be too slow (n &gt; 20-25)</li> </ul>"},{"location":"brute-force/meet-in-middle/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Choose Split Point: Optimize where to split the problem</li> <li>Sort Results: Sort one half for efficient binary search</li> <li>Use Hash Maps: For O(1) lookup when combining results</li> <li>Prune Early: Eliminate impossible combinations early</li> <li>Memory Management: Be careful with memory usage for large halves</li> <li>Parallel Processing: Each half can be solved in parallel</li> </ol>"},{"location":"brute-force/permutation-enumeration/","title":"Permutation Enumeration","text":"<p>Permutation enumeration involves generating and working with all possible arrangements of elements. This technique is essential for problems that require exploring different orderings or arrangements of a given set of elements.</p>"},{"location":"brute-force/permutation-enumeration/#types-of-permutations","title":"Types of Permutations","text":""},{"location":"brute-force/permutation-enumeration/#1-all-permutations","title":"1. All Permutations","text":"<p>Generate all possible arrangements of n distinct elements.</p>"},{"location":"brute-force/permutation-enumeration/#2-permutations-with-repetition","title":"2. Permutations with Repetition","text":"<p>Generate arrangements where elements can be repeated.</p>"},{"location":"brute-force/permutation-enumeration/#3-partial-permutations-k-permutations","title":"3. Partial Permutations (k-permutations)","text":"<p>Generate arrangements of k elements chosen from n elements.</p>"},{"location":"brute-force/permutation-enumeration/#4-permutations-with-constraints","title":"4. Permutations with Constraints","text":"<p>Generate arrangements that satisfy specific conditions.</p>"},{"location":"brute-force/permutation-enumeration/#basic-permutation-generation","title":"Basic Permutation Generation","text":""},{"location":"brute-force/permutation-enumeration/#recursive-approach","title":"Recursive Approach","text":"<p>Problem: Generate all permutations of an array using recursion.</p> <p>Sample Input: <code>arr = [1, 2, 3]</code></p> <p>Sample Output:  <pre><code>[1, 2, 3]\n[1, 3, 2]\n[2, 1, 3]\n[2, 3, 1]\n[3, 1, 2]\n[3, 2, 1]\n</code></pre></p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass PermutationGenerator {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generatePermutations(vector&lt;int&gt;&amp; arr) {\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;int&gt; current;\n        vector&lt;bool&gt; used(arr.size(), false);\n\n        generatePermutationsHelper(arr, current, used, result);\n        return result;\n    }\n\nprivate:\n    void generatePermutationsHelper(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; current, \n                                   vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n        if (current.size() == arr.size()) {\n            result.push_back(current);\n            return;\n        }\n\n        for (int i = 0; i &lt; arr.size(); i++) {\n            if (!used[i]) {\n                used[i] = true;\n                current.push_back(arr[i]);\n                generatePermutationsHelper(arr, current, used, result);\n                current.pop_back();\n                used[i] = false;\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"brute-force/permutation-enumeration/#iterative-approach-heaps-algorithm","title":"Iterative Approach (Heap's Algorithm)","text":"<p>Problem: Generate all permutations iteratively using Heap's algorithm.</p> <p>Sample Input: <code>arr = [1, 2, 3]</code></p> <p>Sample Output: All 6 permutations of [1, 2, 3]</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass IterativePermutation {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generatePermutations(vector&lt;int&gt;&amp; arr) {\n        vector&lt;vector&lt;int&gt;&gt; result;\n        int n = arr.size();\n        vector&lt;int&gt; c(n, 0);\n\n        result.push_back(arr);\n\n        int i = 0;\n        while (i &lt; n) {\n            if (c[i] &lt; i) {\n                if (i % 2 == 0) {\n                    swap(arr[0], arr[i]);\n                } else {\n                    swap(arr[c[i]], arr[i]);\n                }\n                result.push_back(arr);\n                c[i]++;\n                i = 0;\n            } else {\n                c[i] = 0;\n                i++;\n            }\n        }\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"brute-force/permutation-enumeration/#next-permutation-lexicographic-order","title":"Next Permutation (Lexicographic Order)","text":"<p>Problem: Find the next lexicographically greater permutation.</p> <p>Sample Input: <code>arr = [1, 2, 3]</code></p> <p>Sample Output: <code>[1, 3, 2]</code> (next permutation in lexicographic order)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass NextPermutation {\npublic:\n    bool nextPermutation(vector&lt;int&gt;&amp; arr) {\n        int n = arr.size();\n        int i = n - 2;\n\n        // Find the largest index i such that arr[i] &lt; arr[i + 1]\n        while (i &gt;= 0 &amp;&amp; arr[i] &gt;= arr[i + 1]) {\n            i--;\n        }\n\n        if (i &lt; 0) {\n            return false; // No next permutation exists\n        }\n\n        // Find the largest index j such that arr[i] &lt; arr[j]\n        int j = n - 1;\n        while (arr[j] &lt;= arr[i]) {\n            j--;\n        }\n\n        // Swap arr[i] and arr[j]\n        swap(arr[i], arr[j]);\n\n        // Reverse the suffix starting at arr[i + 1]\n        reverse(arr.begin() + i + 1, arr.end());\n\n        return true;\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; allPermutations(vector&lt;int&gt;&amp; arr) {\n        vector&lt;vector&lt;int&gt;&gt; result;\n        sort(arr.begin(), arr.end());\n\n        do {\n            result.push_back(arr);\n        } while (nextPermutation(arr));\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"brute-force/permutation-enumeration/#partial-permutations-k-permutations","title":"Partial Permutations (k-permutations)","text":"<p>Problem: Generate all permutations of k elements chosen from n elements.</p> <p>Sample Input:  - <code>arr = [1, 2, 3, 4]</code> - <code>k = 2</code></p> <p>Sample Output:  <pre><code>[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], \n[3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]\n</code></pre></p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass PartialPermutation {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generateKPermutations(vector&lt;int&gt;&amp; arr, int k) {\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;int&gt; current;\n        vector&lt;bool&gt; used(arr.size(), false);\n\n        generateKPermutationsHelper(arr, k, current, used, result);\n        return result;\n    }\n\nprivate:\n    void generateKPermutationsHelper(vector&lt;int&gt;&amp; arr, int k, vector&lt;int&gt;&amp; current,\n                                   vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n        if (current.size() == k) {\n            result.push_back(current);\n            return;\n        }\n\n        for (int i = 0; i &lt; arr.size(); i++) {\n            if (!used[i]) {\n                used[i] = true;\n                current.push_back(arr[i]);\n                generateKPermutationsHelper(arr, k, current, used, result);\n                current.pop_back();\n                used[i] = false;\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"brute-force/permutation-enumeration/#permutations-with-repetition","title":"Permutations with Repetition","text":"<p>Problem: Generate all permutations when elements can be repeated.</p> <p>Sample Input: <code>arr = [1, 1, 2]</code></p> <p>Sample Output:  <pre><code>[1, 1, 2], [1, 2, 1], [2, 1, 1]\n</code></pre></p> <pre><code>#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass PermutationWithRepetition {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generatePermutationsWithRep(vector&lt;int&gt;&amp; arr) {\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;int&gt; current;\n        unordered_map&lt;int, int&gt; count;\n\n        // Count frequency of each element\n        for (int num : arr) {\n            count[num]++;\n        }\n\n        generatePermutationsWithRepHelper(count, current, arr.size(), result);\n        return result;\n    }\n\nprivate:\n    void generatePermutationsWithRepHelper(unordered_map&lt;int, int&gt;&amp; count, \n                                          vector&lt;int&gt;&amp; current, int remaining,\n                                          vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n        if (remaining == 0) {\n            result.push_back(current);\n            return;\n        }\n\n        for (auto&amp; pair : count) {\n            if (pair.second &gt; 0) {\n                pair.second--;\n                current.push_back(pair.first);\n                generatePermutationsWithRepHelper(count, current, remaining - 1, result);\n                current.pop_back();\n                pair.second++;\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"brute-force/permutation-enumeration/#advanced-applications","title":"Advanced Applications","text":""},{"location":"brute-force/permutation-enumeration/#permutation-based-problems","title":"Permutation-based Problems","text":"<p>Problem: Find the kth permutation in lexicographic order.</p> <p>Sample Input:  - <code>n = 3</code> (elements 1, 2, 3) - <code>k = 3</code></p> <p>Sample Output: <code>[2, 1, 3]</code> (3rd permutation)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass KthPermutation {\npublic:\n    string getKthPermutation(int n, int k) {\n        vector&lt;int&gt; numbers;\n        vector&lt;int&gt; factorial(n + 1, 1);\n\n        // Calculate factorials\n        for (int i = 1; i &lt;= n; i++) {\n            factorial[i] = factorial[i - 1] * i;\n            numbers.push_back(i);\n        }\n\n        string result = \"\";\n        k--; // Convert to 0-based indexing\n\n        for (int i = 1; i &lt;= n; i++) {\n            int index = k / factorial[n - i];\n            result += to_string(numbers[index]);\n            numbers.erase(numbers.begin() + index);\n            k -= index * factorial[n - i];\n        }\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"brute-force/permutation-enumeration/#circular-permutations","title":"Circular Permutations","text":"<p>Problem: Generate all circular permutations (rotations are considered the same).</p> <p>Sample Input: <code>arr = [1, 2, 3]</code></p> <p>Sample Output:  <pre><code>[1, 2, 3], [1, 3, 2]\n</code></pre> (Note: [2, 3, 1] and [3, 1, 2] are rotations of [1, 2, 3])</p> <pre><code>#include &lt;vector&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nclass CircularPermutation {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generateCircularPermutations(vector&lt;int&gt;&amp; arr) {\n        set&lt;vector&lt;int&gt;&gt; uniquePerms;\n        vector&lt;vector&lt;int&gt;&gt; allPerms = generateAllPermutations(arr);\n\n        for (auto&amp; perm : allPerms) {\n            vector&lt;int&gt; normalized = normalizeCircular(perm);\n            uniquePerms.insert(normalized);\n        }\n\n        return vector&lt;vector&lt;int&gt;&gt;(uniquePerms.begin(), uniquePerms.end());\n    }\n\nprivate:\n    vector&lt;int&gt; normalizeCircular(vector&lt;int&gt;&amp; arr) {\n        int n = arr.size();\n        int minIndex = 0;\n\n        // Find the index of minimum element\n        for (int i = 1; i &lt; n; i++) {\n            if (arr[i] &lt; arr[minIndex]) {\n                minIndex = i;\n            }\n        }\n\n        // Rotate to start with minimum element\n        vector&lt;int&gt; result;\n        for (int i = 0; i &lt; n; i++) {\n            result.push_back(arr[(minIndex + i) % n]);\n        }\n\n        return result;\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; generateAllPermutations(vector&lt;int&gt;&amp; arr) {\n        // Implementation of permutation generation\n        // (using any of the methods above)\n        return {};\n    }\n};\n</code></pre>"},{"location":"brute-force/permutation-enumeration/#use-cases","title":"Use Cases","text":""},{"location":"brute-force/permutation-enumeration/#combinatorial-problems","title":"Combinatorial Problems","text":"<ul> <li>Arrangement Problems: Finding optimal arrangements</li> <li>Scheduling: Arranging tasks or events</li> <li>Routing: Finding optimal paths or tours</li> <li>Assignment: Assigning resources to tasks</li> </ul>"},{"location":"brute-force/permutation-enumeration/#optimization-problems","title":"Optimization Problems","text":"<ul> <li>Traveling Salesman: Finding shortest tour</li> <li>Job Scheduling: Optimizing task sequences</li> <li>Resource Allocation: Optimal distribution</li> <li>Layout Problems: Arranging objects optimally</li> </ul>"},{"location":"brute-force/permutation-enumeration/#mathematical-problems","title":"Mathematical Problems","text":"<ul> <li>Group Theory: Studying symmetry groups</li> <li>Combinatorics: Counting arrangements</li> <li>Probability: Calculating permutation probabilities</li> <li>Cryptography: Generating keys or codes</li> </ul>"},{"location":"brute-force/permutation-enumeration/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"brute-force/permutation-enumeration/#time-complexity","title":"Time Complexity","text":"<ul> <li>All Permutations: O(n! \u00d7 n) for generating and storing</li> <li>Next Permutation: O(n) for finding next permutation</li> <li>k-Permutations: O(P(n,k) \u00d7 k) where P(n,k) = n!/(n-k)!</li> <li>With Repetition: O(n^r) where r is the number of positions</li> </ul>"},{"location":"brute-force/permutation-enumeration/#space-complexity","title":"Space Complexity","text":"<ul> <li>Recursive: O(n) for recursion stack</li> <li>Iterative: O(1) additional space (excluding output)</li> <li>Storage: O(n! \u00d7 n) for storing all permutations</li> </ul>"},{"location":"brute-force/permutation-enumeration/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use Iterative Methods: Avoid recursion overhead when possible</li> <li>Generate on Demand: Don't store all permutations if not needed</li> <li>Prune Early: Stop generating when constraints are violated</li> <li>Use Next Permutation: For lexicographic order without storing all</li> <li>Handle Duplicates: Use frequency counting for repeated elements</li> <li>Memory Management: Be careful with large permutation spaces</li> </ol>"},{"location":"brute-force/recursive-backtracking/","title":"Recursive Backtracking","text":"<p>Recursive backtracking is a powerful technique that explores all possible solutions by building them incrementally and backtracking when a solution becomes invalid. It's particularly effective for constraint satisfaction problems and combinatorial optimization.</p>"},{"location":"brute-force/recursive-backtracking/#how-it-works","title":"How It Works","text":"<p>The algorithm follows these steps: 1. Choose: Make a choice for the current step 2. Explore: Recursively solve the remaining problem 3. Unchoose: Backtrack if the choice doesn't lead to a solution</p>"},{"location":"brute-force/recursive-backtracking/#basic-template","title":"Basic Template","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nbool backtrack(vector&lt;int&gt;&amp; currentState, vector&lt;int&gt;&amp; remainingChoices) {\n    // Base case: solution found\n    if (isSolution(currentState)) {\n        return true;\n    }\n\n    // Try each possible choice\n    for (int i = 0; i &lt; remainingChoices.size(); i++) {\n        int choice = remainingChoices[i];\n        if (isValidChoice(currentState, choice)) {\n            // Make the choice\n            currentState.push_back(choice);\n            remainingChoices.erase(remainingChoices.begin() + i);\n\n            // Recursively explore\n            if (backtrack(currentState, remainingChoices)) {\n                return true;\n            }\n\n            // Backtrack: undo the choice\n            currentState.pop_back();\n            remainingChoices.insert(remainingChoices.begin() + i, choice);\n        }\n    }\n\n    return false;  // No solution found\n}\n</code></pre>"},{"location":"brute-force/recursive-backtracking/#example-n-queens-problem","title":"Example: N-Queens Problem","text":"<p>Problem: Place N queens on an N\u00d7N chessboard such that no two queens attack each other. Return all possible solutions.</p> <p>Sample Input: <code>n = 4</code> Sample Output:  <pre><code>[\n  [[0,1,0,0], [0,0,0,1], [1,0,0,0], [0,0,1,0]],\n  [[0,0,1,0], [1,0,0,0], [0,0,0,1], [0,1,0,0]]\n]\n</code></pre> (1 represents queen, 0 represents empty)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass NQueens {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; board;\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; solutions;\n    int n;\n\n    bool isSafe(int row, int col) {\n        // Check column\n        for (int i = 0; i &lt; row; i++) {\n            if (board[i][col] == 1) {\n                return false;\n            }\n        }\n\n        // Check diagonals\n        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {\n            if (board[i][j] == 1) {\n                return false;\n            }\n        }\n\n        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {\n            if (board[i][j] == 1) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    void backtrack(int row) {\n        if (row == n) {\n            solutions.push_back(board);\n            return;\n        }\n\n        for (int col = 0; col &lt; n; col++) {\n            if (isSafe(row, col)) {\n                board[row][col] = 1;\n                backtrack(row + 1);\n                board[row][col] = 0;  // Backtrack\n            }\n        }\n    }\n\npublic:\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; solveNQueens(int n) {\n        this-&gt;n = n;\n        board = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0));\n        solutions.clear();\n        backtrack(0);\n        return solutions;\n    }\n};\n</code></pre>"},{"location":"brute-force/recursive-backtracking/#common-applications","title":"Common Applications","text":"<ul> <li>Constraint Satisfaction: Sudoku, crossword puzzles</li> <li>Combinatorial Problems: Permutations, combinations</li> <li>Path Finding: Maze solving, Hamiltonian paths</li> <li>Game Playing: Chess, checkers endgame analysis</li> </ul>"},{"location":"brute-force/recursive-backtracking/#optimization-techniques","title":"Optimization Techniques","text":"<ol> <li>Pruning: Eliminate branches that can't lead to solutions</li> <li>Heuristics: Order choices to find solutions faster</li> <li>Memoization: Cache results for repeated subproblems</li> <li>Constraint Propagation: Use constraints to reduce search space</li> </ol>"},{"location":"brute-force/recursive-backtracking/#complexity-considerations","title":"Complexity Considerations","text":"<ul> <li>Time Complexity: Often exponential, but pruning can significantly improve performance</li> <li>Space Complexity: O(depth) for recursion stack</li> <li>Best Case: O(1) if solution is found immediately</li> <li>Worst Case: O(b^d) where b is branching factor and d is depth</li> </ul>"},{"location":"counting/","title":"Counting, Frequency, and Precomputation","text":"<p>This category covers techniques for efficiently counting elements, managing frequencies, and preprocessing data to enable faster queries. These methods are fundamental to many algorithmic solutions and are often used as building blocks for more complex algorithms.</p>"},{"location":"counting/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link Frequency Counting Arrays Using arrays to count occurrences of elements, enabling O(1) lookups for frequency queries. Frequency Arrays Prefix / Difference Arrays Precomputing prefix sums or differences to answer range queries in constant time. Prefix Arrays Sieve of Eratosthenes An efficient algorithm for finding all prime numbers up to a given limit through systematic elimination. Sieve of Eratosthenes"},{"location":"counting/#when-to-use","title":"When to Use","text":"<p>These techniques are essential when: - You need to answer multiple queries about ranges or frequencies - Working with statistical data or counting problems - Optimizing repeated computations - Building foundations for more complex algorithms</p>"},{"location":"counting/#key-benefits","title":"Key Benefits","text":"<ul> <li>Time Complexity: Often reduces query time from O(n) to O(1)</li> <li>Space Efficiency: Uses simple data structures like arrays</li> <li>Simplicity: Easy to implement and understand</li> <li>Versatility: Applicable to a wide range of problems</li> </ul>"},{"location":"counting/frequency-arrays/","title":"Frequency Counting Arrays","text":"<p>Frequency counting arrays are a simple yet powerful technique for counting occurrences of elements in a dataset. By using arrays to store counts, we can achieve O(1) lookup time for frequency queries.</p>"},{"location":"counting/frequency-arrays/#how-it-works","title":"How It Works","text":"<p>The technique uses an array where: - Index represents the element value - Value at index represents the frequency/count of that element</p>"},{"location":"counting/frequency-arrays/#basic-implementation","title":"Basic Implementation","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvector&lt;int&gt; countFrequencies(vector&lt;int&gt;&amp; arr) {\n    if (arr.empty()) return {};\n\n    // Find the maximum value to determine array size\n    int maxVal = *max_element(arr.begin(), arr.end());\n    vector&lt;int&gt; freq(maxVal + 1, 0);\n\n    // Count frequencies\n    for (int num : arr) {\n        freq[num]++;\n    }\n\n    return freq;\n}\n\nint getFrequency(vector&lt;int&gt;&amp; freq, int value) {\n    if (value &lt; freq.size()) {\n        return freq[value];\n    }\n    return 0;\n}\n</code></pre>"},{"location":"counting/frequency-arrays/#example-character-frequency-in-string","title":"Example: Character Frequency in String","text":"<p>Problem: Count the frequency of each character in a string and find the most frequent character.</p> <p>Sample Input: <code>text = \"hello world\"</code></p> <p>Sample Output:  - Character frequencies: h=1, e=1, l=3, o=2, space=1, w=1, r=1, d=1 - Most frequent character: 'l' (appears 3 times)</p> <pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; charFrequency(string text) {\n    // For ASCII characters (0-127)\n    vector&lt;int&gt; freq(128, 0);\n\n    for (char c : text) {\n        freq[c]++;\n    }\n\n    return freq;\n}\n\nchar mostFrequentChar(string text) {\n    vector&lt;int&gt; freq = charFrequency(text);\n    int maxFreq = *max_element(freq.begin(), freq.end());\n\n    for (int i = 0; i &lt; freq.size(); i++) {\n        if (freq[i] == maxFreq) {\n            return (char)i;\n        }\n    }\n    return '\\0';\n}\n</code></pre>"},{"location":"counting/frequency-arrays/#advanced-applications","title":"Advanced Applications","text":""},{"location":"counting/frequency-arrays/#counting-sort","title":"Counting Sort","text":"<p>Problem: Sort an array of integers using counting sort (efficient for small integer ranges).</p> <p>Sample Input: <code>arr = [4, 2, 2, 8, 3, 3, 1]</code></p> <p>Sample Output: <code>[1, 2, 2, 3, 3, 4, 8]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvector&lt;int&gt; countingSort(vector&lt;int&gt;&amp; arr) {\n    if (arr.empty()) return {};\n\n    int maxVal = *max_element(arr.begin(), arr.end());\n    vector&lt;int&gt; freq(maxVal + 1, 0);\n\n    // Count frequencies\n    for (int num : arr) {\n        freq[num]++;\n    }\n\n    // Reconstruct sorted array\n    vector&lt;int&gt; result;\n    for (int i = 0; i &lt; freq.size(); i++) {\n        for (int j = 0; j &lt; freq[i]; j++) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"counting/frequency-arrays/#finding-duplicates","title":"Finding Duplicates","text":"<p>Problem: Find all duplicate elements in an array using frequency counting.</p> <p>Sample Input: <code>arr = [1, 2, 3, 2, 4, 3, 5]</code></p> <p>Sample Output: <code>[2, 3]</code> (elements that appear more than once)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nvector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; arr) {\n    unordered_map&lt;int, int&gt; freq;\n    vector&lt;int&gt; duplicates;\n\n    for (int num : arr) {\n        freq[num]++;\n        if (freq[num] == 2) {  // First duplicate\n            duplicates.push_back(num);\n        }\n    }\n\n    return duplicates;\n}\n</code></pre>"},{"location":"counting/frequency-arrays/#use-cases","title":"Use Cases","text":"<ul> <li>Sorting: Counting sort for small integer ranges</li> <li>Duplicate Detection: Finding repeated elements</li> <li>Anagram Detection: Comparing character frequencies</li> <li>Mode Finding: Finding most frequent elements</li> <li>Data Analysis: Statistical analysis of datasets</li> </ul>"},{"location":"counting/frequency-arrays/#space-time-tradeoffs","title":"Space-Time Tradeoffs","text":""},{"location":"counting/frequency-arrays/#array-based-when-values-are-small-integers","title":"Array-based (when values are small integers)","text":"<ul> <li>Time: O(n) for counting, O(1) for lookup</li> <li>Space: O(max_value) for frequency array</li> </ul>"},{"location":"counting/frequency-arrays/#hash-map-based-for-arbitrary-values","title":"Hash Map-based (for arbitrary values)","text":"<ul> <li>Time: O(n) for counting, O(1) average for lookup</li> <li>Space: O(unique_values) for hash map</li> </ul>"},{"location":"counting/frequency-arrays/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Range Optimization: Use arrays only when value range is small</li> <li>Memory Efficiency: Consider using hash maps for sparse data</li> <li>Batch Operations: Process multiple queries together</li> <li>Lazy Evaluation: Compute frequencies only when needed</li> </ol>"},{"location":"counting/prefix-arrays/","title":"Prefix / Difference Arrays","text":"<p>Prefix arrays and difference arrays are powerful techniques for efficiently answering range queries. Prefix arrays precompute cumulative sums, while difference arrays enable efficient range updates.</p>"},{"location":"counting/prefix-arrays/#prefix-arrays","title":"Prefix Arrays","text":"<p>Prefix arrays store cumulative sums, allowing O(1) range sum queries.</p>"},{"location":"counting/prefix-arrays/#implementation","title":"Implementation","text":"<p>Problem: Build a prefix array to enable O(1) range sum queries.</p> <p>Sample Input: <code>arr = [1, 2, 3, 4, 5]</code></p> <p>Sample Output:  - Prefix array: <code>[0, 1, 3, 6, 10, 15]</code> - Range sum(1,3): <code>9</code> (2+3+4)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; buildPrefixArray(vector&lt;int&gt;&amp; arr) {\n    int n = arr.size();\n    vector&lt;int&gt; prefix(n + 1, 0);\n\n    for (int i = 0; i &lt; n; i++) {\n        prefix[i + 1] = prefix[i] + arr[i];\n    }\n\n    return prefix;\n}\n\nint rangeSum(vector&lt;int&gt;&amp; prefix, int left, int right) {\n    return prefix[right + 1] - prefix[left];\n}\n</code></pre>"},{"location":"counting/prefix-arrays/#example-usage","title":"Example Usage","text":"<pre><code>vector&lt;int&gt; arr = {1, 2, 3, 4, 5};\nvector&lt;int&gt; prefix = buildPrefixArray(arr);\n// prefix = {0, 1, 3, 6, 10, 15}\n\n// Sum from index 1 to 3 (inclusive)\nint sum_1_3 = rangeSum(prefix, 1, 3);  // 2 + 3 + 4 = 9\n</code></pre>"},{"location":"counting/prefix-arrays/#difference-arrays","title":"Difference Arrays","text":"<p>Difference arrays enable efficient range updates by storing differences between consecutive elements.</p>"},{"location":"counting/prefix-arrays/#implementation_1","title":"Implementation","text":"<p>Problem: Perform range updates efficiently using difference arrays.</p> <p>Sample Input:  - Initial array: <code>[0, 0, 0, 0, 0]</code> - Range update: add 5 to indices 1-3</p> <p>Sample Output: <code>[0, 5, 5, 5, 0]</code></p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; buildDifferenceArray(vector&lt;int&gt;&amp; arr) {\n    int n = arr.size();\n    vector&lt;int&gt; diff(n, 0);\n    diff[0] = arr[0];\n\n    for (int i = 1; i &lt; n; i++) {\n        diff[i] = arr[i] - arr[i - 1];\n    }\n\n    return diff;\n}\n\nvoid rangeUpdate(vector&lt;int&gt;&amp; diff, int left, int right, int value) {\n    diff[left] += value;\n    if (right + 1 &lt; diff.size()) {\n        diff[right + 1] -= value;\n    }\n}\n\nvector&lt;int&gt; reconstructArray(vector&lt;int&gt;&amp; diff) {\n    vector&lt;int&gt; arr(diff.size(), 0);\n    arr[0] = diff[0];\n\n    for (int i = 1; i &lt; diff.size(); i++) {\n        arr[i] = arr[i - 1] + diff[i];\n    }\n\n    return arr;\n}\n</code></pre>"},{"location":"counting/prefix-arrays/#example-range-updates","title":"Example: Range Updates","text":"<pre><code>// Original array\nvector&lt;int&gt; arr = {1, 2, 3, 4, 5};\nvector&lt;int&gt; diff = buildDifferenceArray(arr);\n\n// Add 2 to elements from index 1 to 3\nrangeUpdate(diff, 1, 3, 2);\n\n// Reconstruct the updated array\nvector&lt;int&gt; updatedArr = reconstructArray(diff);\n// Result: {1, 4, 5, 6, 5}\n</code></pre>"},{"location":"counting/prefix-arrays/#advanced-applications","title":"Advanced Applications","text":""},{"location":"counting/prefix-arrays/#2d-prefix-arrays","title":"2D Prefix Arrays","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; build2DPrefix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n    int rows = matrix.size(), cols = matrix[0].size();\n    vector&lt;vector&lt;int&gt;&gt; prefix(rows + 1, vector&lt;int&gt;(cols + 1, 0));\n\n    for (int i = 0; i &lt; rows; i++) {\n        for (int j = 0; j &lt; cols; j++) {\n            prefix[i + 1][j + 1] = matrix[i][j] + \n                                   prefix[i][j + 1] + \n                                   prefix[i + 1][j] - \n                                   prefix[i][j];\n        }\n    }\n\n    return prefix;\n}\n\nint rectangleSum(vector&lt;vector&lt;int&gt;&gt;&amp; prefix, int r1, int c1, int r2, int c2) {\n    return prefix[r2 + 1][c2 + 1] - \n           prefix[r1][c2 + 1] - \n           prefix[r2 + 1][c1] + \n           prefix[r1][c1];\n}\n</code></pre>"},{"location":"counting/prefix-arrays/#multiple-range-updates","title":"Multiple Range Updates","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; multipleRangeUpdates(vector&lt;int&gt;&amp; diff, \n                                vector&lt;tuple&lt;int, int, int&gt;&gt;&amp; updates) {\n    /*\n    updates: vector of (left, right, value) tuples\n    */\n    for (auto&amp; update : updates) {\n        int left, right, value;\n        tie(left, right, value) = update;\n        rangeUpdate(diff, left, right, value);\n    }\n\n    return reconstructArray(diff);\n}\n</code></pre>"},{"location":"counting/prefix-arrays/#use-cases","title":"Use Cases","text":"<ul> <li>Range Sum Queries: Fast sum queries over ranges</li> <li>Range Updates: Efficient bulk updates</li> <li>Subarray Problems: Maximum subarray, subarray with given sum</li> <li>2D Problems: Rectangle sum queries, image processing</li> <li>Cumulative Analysis: Running totals, moving averages</li> </ul>"},{"location":"counting/prefix-arrays/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"counting/prefix-arrays/#prefix-arrays_1","title":"Prefix Arrays","text":"<ul> <li>Build Time: O(n)</li> <li>Query Time: O(1)</li> <li>Space: O(n)</li> </ul>"},{"location":"counting/prefix-arrays/#difference-arrays_1","title":"Difference Arrays","text":"<ul> <li>Build Time: O(n)</li> <li>Update Time: O(1) per range update</li> <li>Reconstruction Time: O(n)</li> <li>Space: O(n)</li> </ul>"},{"location":"counting/prefix-arrays/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Memory Layout: Use contiguous memory for better cache performance</li> <li>Batch Operations: Process multiple queries together</li> <li>Lazy Reconstruction: Only reconstruct when final array is needed</li> <li>Modular Arithmetic: Handle overflow with modular operations</li> </ol>"},{"location":"counting/sieve-eratosthenes/","title":"Sieve of Eratosthenes","text":"<p>The Sieve of Eratosthenes is an efficient algorithm for finding all prime numbers up to a given limit. It works by systematically eliminating multiples of each prime number, leaving only the primes. This algorithm is fundamental for many number theory problems and competitive programming challenges.</p>"},{"location":"counting/sieve-eratosthenes/#how-it-works","title":"How It Works","text":"<ol> <li>Initialize: Create a boolean array of size n+1, marking all numbers as potential primes</li> <li>Mark Non-Primes: For each number from 2 to \u221an, if it's still marked as prime, mark all its multiples as non-prime</li> <li>Collect Primes: All unmarked numbers are prime</li> </ol>"},{"location":"counting/sieve-eratosthenes/#basic-implementation","title":"Basic Implementation","text":"<p>Problem: Find all prime numbers up to a given limit using the Sieve of Eratosthenes.</p> <p>Sample Input: <code>n = 30</code></p> <p>Sample Output: <code>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nvector&lt;int&gt; sieveOfEratosthenes(int n) {\n    vector&lt;bool&gt; isPrime(n + 1, true);\n    isPrime[0] = isPrime[1] = false;\n\n    for (int i = 2; i * i &lt;= n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j &lt;= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\n    vector&lt;int&gt; primes;\n    for (int i = 2; i &lt;= n; i++) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n</code></pre>"},{"location":"counting/sieve-eratosthenes/#optimized-implementation","title":"Optimized Implementation","text":"<p>Problem: Optimized version with better memory usage and performance.</p> <p>Sample Input: <code>n = 100</code></p> <p>Sample Output: All primes from 2 to 97</p> <pre><code>#include &lt;vector&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nvector&lt;int&gt; optimizedSieve(int n) {\n    if (n &lt; 2) return {};\n\n    vector&lt;bool&gt; isPrime(n + 1, true);\n    isPrime[0] = isPrime[1] = false;\n\n    // Only check odd numbers (except 2)\n    for (int i = 3; i * i &lt;= n; i += 2) {\n        if (isPrime[i]) {\n            // Start from i*i and step by 2*i (skip even multiples)\n            for (int j = i * i; j &lt;= n; j += 2 * i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\n    vector&lt;int&gt; primes;\n    primes.push_back(2); // Add 2 separately\n\n    for (int i = 3; i &lt;= n; i += 2) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n</code></pre>"},{"location":"counting/sieve-eratosthenes/#segmented-sieve","title":"Segmented Sieve","text":"<p>Problem: Find primes in a range [L, R] where R can be very large but R-L is manageable.</p> <p>Sample Input:  - <code>L = 100</code> - <code>R = 200</code></p> <p>Sample Output: Primes in range [100, 200]</p> <pre><code>#include &lt;vector&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nvector&lt;int&gt; segmentedSieve(int L, int R) {\n    // First, find all primes up to sqrt(R)\n    int limit = sqrt(R);\n    vector&lt;bool&gt; isPrime(limit + 1, true);\n    isPrime[0] = isPrime[1] = false;\n\n    for (int i = 2; i * i &lt;= limit; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j &lt;= limit; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\n    // Collect small primes\n    vector&lt;int&gt; smallPrimes;\n    for (int i = 2; i &lt;= limit; i++) {\n        if (isPrime[i]) {\n            smallPrimes.push_back(i);\n        }\n    }\n\n    // Segmented sieve\n    vector&lt;bool&gt; rangePrime(R - L + 1, true);\n\n    for (int prime : smallPrimes) {\n        int start = max(prime * prime, (L + prime - 1) / prime * prime);\n        for (int j = start; j &lt;= R; j += prime) {\n            rangePrime[j - L] = false;\n        }\n    }\n\n    // Collect primes in range\n    vector&lt;int&gt; result;\n    for (int i = 0; i &lt; rangePrime.size(); i++) {\n        if (rangePrime[i] &amp;&amp; (L + i) &gt; 1) {\n            result.push_back(L + i);\n        }\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"counting/sieve-eratosthenes/#advanced-applications","title":"Advanced Applications","text":""},{"location":"counting/sieve-eratosthenes/#prime-factorization","title":"Prime Factorization","text":"<p>Problem: Precompute smallest prime factor for each number to enable fast factorization.</p> <p>Sample Input: <code>n = 20</code></p> <p>Sample Output:  - Smallest prime factors: [0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2, 11, 2, 13, 2, 3, 2, 17, 2, 19, 2]</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass PrimeFactorization {\nprivate:\n    vector&lt;int&gt; spf; // smallest prime factor\n\npublic:\n    PrimeFactorization(int n) {\n        spf.resize(n + 1);\n        for (int i = 0; i &lt;= n; i++) {\n            spf[i] = i;\n        }\n\n        for (int i = 2; i * i &lt;= n; i++) {\n            if (spf[i] == i) { // i is prime\n                for (int j = i * i; j &lt;= n; j += i) {\n                    if (spf[j] == j) {\n                        spf[j] = i;\n                    }\n                }\n            }\n        }\n    }\n\n    vector&lt;int&gt; getPrimeFactors(int x) {\n        vector&lt;int&gt; factors;\n        while (x &gt; 1) {\n            factors.push_back(spf[x]);\n            x /= spf[x];\n        }\n        return factors;\n    }\n\n    bool isPrime(int x) {\n        return spf[x] == x &amp;&amp; x &gt; 1;\n    }\n};\n</code></pre>"},{"location":"counting/sieve-eratosthenes/#totient-function-eulers-phi","title":"Totient Function (Euler's Phi)","text":"<p>Problem: Calculate Euler's totient function \u03c6(n) for all numbers up to n.</p> <p>Sample Input: <code>n = 10</code></p> <p>Sample Output:  - \u03c6(1) = 1, \u03c6(2) = 1, \u03c6(3) = 2, \u03c6(4) = 2, \u03c6(5) = 4, \u03c6(6) = 2, \u03c6(7) = 6, \u03c6(8) = 4, \u03c6(9) = 6, \u03c6(10) = 4</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; eulerTotient(int n) {\n    vector&lt;int&gt; phi(n + 1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        phi[i] = i;\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        if (phi[i] == i) { // i is prime\n            for (int j = i; j &lt;= n; j += i) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n    return phi;\n}\n</code></pre>"},{"location":"counting/sieve-eratosthenes/#mobius-function","title":"M\u00f6bius Function","text":"<p>Problem: Calculate M\u00f6bius function \u03bc(n) for all numbers up to n.</p> <p>Sample Input: <code>n = 10</code></p> <p>Sample Output:  - \u03bc(1) = 1, \u03bc(2) = -1, \u03bc(3) = -1, \u03bc(4) = 0, \u03bc(5) = -1, \u03bc(6) = 1, \u03bc(7) = -1, \u03bc(8) = 0, \u03bc(9) = 0, \u03bc(10) = 1</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; mobiusFunction(int n) {\n    vector&lt;int&gt; mu(n + 1, 1);\n    vector&lt;bool&gt; isPrime(n + 1, true);\n\n    for (int i = 2; i &lt;= n; i++) {\n        if (isPrime[i]) {\n            for (int j = i; j &lt;= n; j += i) {\n                isPrime[j] = false;\n                if (j % (i * i) == 0) {\n                    mu[j] = 0;\n                } else {\n                    mu[j] *= -1;\n                }\n            }\n        }\n    }\n\n    return mu;\n}\n</code></pre>"},{"location":"counting/sieve-eratosthenes/#use-cases","title":"Use Cases","text":""},{"location":"counting/sieve-eratosthenes/#number-theory-problems","title":"Number Theory Problems","text":"<ul> <li>Prime Counting: Count primes in a range</li> <li>Prime Factorization: Factor numbers efficiently</li> <li>GCD/LCM: Compute greatest common divisor and least common multiple</li> <li>Modular Arithmetic: Work with modular operations</li> </ul>"},{"location":"counting/sieve-eratosthenes/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>Prime Checking: Determine if a number is prime</li> <li>Prime Generation: Generate primes for other algorithms</li> <li>Mathematical Functions: Totient, M\u00f6bius, and other functions</li> <li>Optimization: Precompute values for faster queries</li> </ul>"},{"location":"counting/sieve-eratosthenes/#cryptography","title":"Cryptography","text":"<ul> <li>RSA Algorithm: Generate large primes for encryption</li> <li>Key Generation: Create secure cryptographic keys</li> <li>Hash Functions: Use primes in hash table implementations</li> <li>Random Number Generation: Generate pseudo-random primes</li> </ul>"},{"location":"counting/sieve-eratosthenes/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"counting/sieve-eratosthenes/#time-complexity","title":"Time Complexity","text":"<ul> <li>Basic Sieve: O(n log log n)</li> <li>Optimized Sieve: O(n log log n) with better constants</li> <li>Segmented Sieve: O(\u221aR + (R-L) log log R)</li> <li>Prime Factorization: O(log n) per query after preprocessing</li> </ul>"},{"location":"counting/sieve-eratosthenes/#space-complexity","title":"Space Complexity","text":"<ul> <li>Basic Sieve: O(n) for boolean array</li> <li>Optimized Sieve: O(n) but with better cache performance</li> <li>Segmented Sieve: O(\u221aR + (R-L)) for the range</li> <li>Prime Factorization: O(n) for smallest prime factor array</li> </ul>"},{"location":"counting/sieve-eratosthenes/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Memory Optimization: Use bitset for large ranges</li> <li>Cache Efficiency: Process numbers in order for better cache performance</li> <li>Wheel Factorization: Skip multiples of small primes</li> <li>Segmented Approach: Handle large ranges by dividing into segments</li> <li>Precomputation: Store results for frequently used ranges</li> <li>Parallel Processing: Use multiple threads for very large sieves</li> </ol>"},{"location":"counting/sieve-eratosthenes/#common-variations","title":"Common Variations","text":""},{"location":"counting/sieve-eratosthenes/#linear-sieve","title":"Linear Sieve","text":"<pre><code>vector&lt;int&gt; linearSieve(int n) {\n    vector&lt;int&gt; primes;\n    vector&lt;int&gt; spf(n + 1);\n\n    for (int i = 2; i &lt;= n; i++) {\n        if (spf[i] == 0) {\n            spf[i] = i;\n            primes.push_back(i);\n        }\n\n        for (int j = 0; j &lt; primes.size() &amp;&amp; primes[j] &lt;= spf[i] &amp;&amp; i * primes[j] &lt;= n; j++) {\n            spf[i * primes[j]] = primes[j];\n        }\n    }\n\n    return primes;\n}\n</code></pre>"},{"location":"counting/sieve-eratosthenes/#sieve-of-sundaram","title":"Sieve of Sundaram","text":"<pre><code>vector&lt;int&gt; sieveOfSundaram(int n) {\n    int newN = (n - 1) / 2;\n    vector&lt;bool&gt; marked(newN + 1, false);\n\n    for (int i = 1; i &lt;= newN; i++) {\n        for (int j = i; (i + j + 2 * i * j) &lt;= newN; j++) {\n            marked[i + j + 2 * i * j] = true;\n        }\n    }\n\n    vector&lt;int&gt; primes;\n    if (n &gt;= 2) primes.push_back(2);\n\n    for (int i = 1; i &lt;= newN; i++) {\n        if (!marked[i]) {\n            primes.push_back(2 * i + 1);\n        }\n    }\n\n    return primes;\n}\n</code></pre>"},{"location":"data-structures/","title":"Data Structures","text":"<p>Data structures are fundamental building blocks for efficient algorithm design. This category covers advanced data structures that enable fast queries, updates, and specialized operations essential for solving complex computational problems.</p>"},{"location":"data-structures/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link Segment Tree / BIT Efficient range query data structures that allow fast updates and range operations, essential for many competitive programming problems. Segment Tree / BIT Heap / Priority Queue Dynamic data structures for maintaining extremal elements (minimum or maximum) with efficient insertion and deletion operations. Heap / Priority Queue Disjoint Set (DSU) A data structure for efficiently managing disjoint sets, commonly used for connectivity problems and minimum spanning tree algorithms. Disjoint Set (DSU)"},{"location":"data-structures/#when-to-use-advanced-data-structures","title":"When to Use Advanced Data Structures","text":"<p>These data structures are essential when: - You need to perform frequent range queries or updates - Maintaining extremal elements with dynamic operations - Working with connectivity or union-find problems - Optimizing time complexity for repeated operations</p>"},{"location":"data-structures/#common-applications","title":"Common Applications","text":""},{"location":"data-structures/#segment-trees-binary-indexed-trees","title":"Segment Trees &amp; Binary Indexed Trees","text":"<ul> <li>Range Sum Queries: Computing sums over ranges efficiently</li> <li>Range Minimum/Maximum: Finding extremal values in ranges</li> <li>Range Updates: Applying updates to ranges of elements</li> <li>Inversion Counting: Counting inversions in arrays</li> </ul>"},{"location":"data-structures/#heaps-priority-queues","title":"Heaps &amp; Priority Queues","text":"<ul> <li>Dijkstra's Algorithm: Finding shortest paths in graphs</li> <li>Median Maintenance: Keeping track of running median</li> <li>Task Scheduling: Prioritizing tasks based on urgency or importance</li> <li>Merge Operations: Efficiently merging sorted sequences</li> </ul>"},{"location":"data-structures/#disjoint-set-union","title":"Disjoint Set Union","text":"<ul> <li>Connectivity Problems: Determining if elements are connected</li> <li>Minimum Spanning Tree: Kruskal's algorithm implementation</li> <li>Cycle Detection: Detecting cycles in undirected graphs</li> <li>Component Analysis: Analyzing connected components</li> </ul>"},{"location":"data-structures/disjoint-set/","title":"Disjoint Set Union (DSU)","text":"<p>Disjoint Set Union (DSU), also known as Union-Find, is a data structure that efficiently manages a collection of disjoint sets. It provides fast operations for finding which set an element belongs to and for merging two sets together.</p>"},{"location":"data-structures/disjoint-set/#basic-operations","title":"Basic Operations","text":"<ol> <li>Find: Determine which set an element belongs to</li> <li>Union: Merge two sets into one</li> <li>Connected: Check if two elements are in the same set</li> </ol>"},{"location":"data-structures/disjoint-set/#basic-implementation","title":"Basic Implementation","text":"<p>Problem: Implement DSU with path compression and union by rank optimizations.</p> <p>Sample Input:  - Operations: <code>union(0,1)</code>, <code>union(2,3)</code>, <code>find(0)</code>, <code>find(2)</code>, <code>connected(0,2)</code></p> <p>Sample Output:  - <code>find(0) = 0</code>, <code>find(2) = 2</code>, <code>connected(0,2) = false</code></p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass DisjointSetUnion {\nprivate:\n    vector&lt;int&gt; parent;\n    vector&lt;int&gt; rank;\n    int components;\n\npublic:\n    DisjointSetUnion(int n) : parent(n), rank(n, 0), components(n) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px == py) return; // Already in same set\n\n        // Union by rank\n        if (rank[px] &lt; rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] &gt; rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n\n        components--;\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int getComponents() {\n        return components;\n    }\n};\n</code></pre>"},{"location":"data-structures/disjoint-set/#advanced-applications","title":"Advanced Applications","text":""},{"location":"data-structures/disjoint-set/#minimum-spanning-tree-kruskals-algorithm","title":"Minimum Spanning Tree (Kruskal's Algorithm)","text":"<p>Problem: Find the minimum spanning tree using Kruskal's algorithm with DSU.</p> <p>Sample Input:  - Edges: <code>[(0,1,4), (0,2,1), (1,2,2), (1,3,5), (2,3,3)]</code> (u, v, weight)</p> <p>Sample Output:  - MST edges: <code>[(0,2,1), (1,2,2), (2,3,3)]</code> - Total weight: <code>6</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n    Edge(int u, int v, int w) : u(u), v(v), weight(w) {}\n};\n\nclass KruskalMST {\npublic:\n    vector&lt;Edge&gt; findMST(vector&lt;Edge&gt;&amp; edges, int vertices) {\n        // Sort edges by weight\n        sort(edges.begin(), edges.end(), \n             [](const Edge&amp; a, const Edge&amp; b) {\n                 return a.weight &lt; b.weight;\n             });\n\n        DisjointSetUnion dsu(vertices);\n        vector&lt;Edge&gt; mst;\n\n        for (const Edge&amp; edge : edges) {\n            if (!dsu.connected(edge.u, edge.v)) {\n                dsu.unionSets(edge.u, edge.v);\n                mst.push_back(edge);\n            }\n        }\n\n        return mst;\n    }\n\n    int mstWeight(vector&lt;Edge&gt;&amp; edges, int vertices) {\n        vector&lt;Edge&gt; mst = findMST(edges, vertices);\n        int totalWeight = 0;\n        for (const Edge&amp; edge : mst) {\n            totalWeight += edge.weight;\n        }\n        return totalWeight;\n    }\n};\n</code></pre>"},{"location":"data-structures/disjoint-set/#number-of-islands","title":"Number of Islands","text":"<p>Problem: Count the number of connected components (islands) in a 2D grid.</p> <p>Sample Input:  <pre><code>Grid:\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1\n</code></pre></p> <p>Sample Output: <code>3</code> (Three connected components)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass NumberOfIslands {\nprivate:\n    int rows, cols;\n    vector&lt;vector&lt;int&gt;&gt; directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\n        if (grid.empty() || grid[0].empty()) return 0;\n\n        rows = grid.size();\n        cols = grid[0].size();\n\n        DisjointSetUnion dsu(rows * cols);\n        int waterCount = 0;\n\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                if (grid[i][j] == '1') {\n                    int current = i * cols + j;\n\n                    // Check all 4 directions\n                    for (auto&amp; dir : directions) {\n                        int ni = i + dir[0];\n                        int nj = j + dir[1];\n\n                        if (ni &gt;= 0 &amp;&amp; ni &lt; rows &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; cols &amp;&amp; \n                            grid[ni][nj] == '1') {\n                            int neighbor = ni * cols + nj;\n                            dsu.unionSets(current, neighbor);\n                        }\n                    }\n                } else {\n                    waterCount++;\n                }\n            }\n        }\n\n        return dsu.getComponents() - waterCount;\n    }\n};\n</code></pre>"},{"location":"data-structures/disjoint-set/#redundant-connection","title":"Redundant Connection","text":"<p>Problem: Find the edge that can be removed to make the graph a tree.</p> <p>Sample Input:  - Edges: <code>[[1,2], [1,3], [2,3]]</code></p> <p>Sample Output: <code>[2,3]</code> (The redundant edge)</p> <pre><code>class RedundantConnection {\npublic:\n    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n        int n = edges.size();\n        DisjointSetUnion dsu(n + 1);\n\n        for (const auto&amp; edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n\n            if (dsu.connected(u, v)) {\n                return edge; // This edge creates a cycle\n            }\n\n            dsu.unionSets(u, v);\n        }\n\n        return {}; // No redundant edge found\n    }\n};\n</code></pre>"},{"location":"data-structures/disjoint-set/#advanced-dsu-features","title":"Advanced DSU Features","text":""},{"location":"data-structures/disjoint-set/#dsu-with-size-tracking","title":"DSU with Size Tracking","text":"<p>Problem: Track the size of each connected component.</p> <p>Sample Input:  - Operations: <code>union(0,1)</code>, <code>union(1,2)</code>, <code>getSize(0)</code></p> <p>Sample Output:  - <code>getSize(0) = 3</code> (Component containing 0, 1, 2 has size 3)</p> <pre><code>class DSUWithSize {\nprivate:\n    vector&lt;int&gt; parent;\n    vector&lt;int&gt; size;\n\npublic:\n    DSUWithSize(int n) : parent(n), size(n, 1) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px == py) return;\n\n        // Always attach smaller tree to larger tree\n        if (size[px] &lt; size[py]) {\n            parent[px] = py;\n            size[py] += size[px];\n        } else {\n            parent[py] = px;\n            size[px] += size[py];\n        }\n    }\n\n    int getSize(int x) {\n        return size[find(x)];\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n</code></pre>"},{"location":"data-structures/disjoint-set/#dsu-with-rollback","title":"DSU with Rollback","text":"<p>Problem: Support rollback operations to undo previous unions.</p> <p>Sample Input:  - Operations: <code>union(0,1)</code>, <code>union(1,2)</code>, <code>rollback()</code>, <code>find(0)</code></p> <p>Sample Output:  - After rollback: <code>find(0) = 0</code>, <code>find(2) = 2</code> (Not connected)</p> <pre><code>class DSUWithRollback {\nprivate:\n    vector&lt;int&gt; parent;\n    vector&lt;int&gt; rank;\n    vector&lt;pair&lt;int, int&gt;&gt; history; // Store operations for rollback\n\npublic:\n    DSUWithRollback(int n) : parent(n), rank(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            return find(parent[x]);\n        }\n        return x;\n    }\n\n    void unionSets(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px == py) return;\n\n        // Store the operation for potential rollback\n        history.push_back({px, py});\n\n        if (rank[px] &lt; rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] &gt; rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n\n    void rollback() {\n        if (history.empty()) return;\n\n        auto [px, py] = history.back();\n        history.pop_back();\n\n        parent[px] = px;\n        parent[py] = py;\n        rank[px] = 0;\n        rank[py] = 0;\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n</code></pre>"},{"location":"data-structures/disjoint-set/#dsu-with-distance-to-root","title":"DSU with Distance to Root","text":"<p>Problem: Track the distance from each node to its root.</p> <p>Sample Input:  - Operations: <code>union(0,1)</code>, <code>union(1,2)</code>, <code>getDistance(0,2)</code></p> <p>Sample Output:  - <code>getDistance(0,2) = 2</code> (Distance from 0 to 2 through root)</p> <pre><code>class DSUWithDistance {\nprivate:\n    vector&lt;int&gt; parent;\n    vector&lt;int&gt; distance;\n\npublic:\n    DSUWithDistance(int n) : parent(n), distance(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            int root = find(parent[x]);\n            distance[x] += distance[parent[x]];\n            parent[x] = root;\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y, int weight = 1) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px == py) return;\n\n        parent[px] = py;\n        distance[px] = distance[y] - distance[x] + weight;\n    }\n\n    int getDistance(int x, int y) {\n        if (find(x) != find(y)) return -1; // Not connected\n\n        return abs(distance[x] - distance[y]);\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n</code></pre>"},{"location":"data-structures/disjoint-set/#use-cases","title":"Use Cases","text":""},{"location":"data-structures/disjoint-set/#graph-problems","title":"Graph Problems","text":"<ul> <li>Connectivity: Check if two vertices are connected</li> <li>Cycle Detection: Detect cycles in undirected graphs</li> <li>Minimum Spanning Tree: Kruskal's algorithm</li> <li>Connected Components: Find all connected components</li> </ul>"},{"location":"data-structures/disjoint-set/#grid-problems","title":"Grid Problems","text":"<ul> <li>Number of Islands: Count connected components in 2D grid</li> <li>Maze Problems: Check connectivity in mazes</li> <li>Flood Fill: Connected region problems</li> <li>Union-Find on Grid: 2D connectivity problems</li> </ul>"},{"location":"data-structures/disjoint-set/#network-problems","title":"Network Problems","text":"<ul> <li>Network Connectivity: Check if network is connected</li> <li>Redundant Connections: Find edges that can be removed</li> <li>Critical Connections: Find bridges in network</li> <li>Component Analysis: Analyze network components</li> </ul>"},{"location":"data-structures/disjoint-set/#optimization-problems","title":"Optimization Problems","text":"<ul> <li>Clustering: Group similar elements</li> <li>Partitioning: Divide elements into groups</li> <li>Matching: Find optimal pairings</li> <li>Scheduling: Group related tasks</li> </ul>"},{"location":"data-structures/disjoint-set/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"data-structures/disjoint-set/#time-complexity","title":"Time Complexity","text":"<ul> <li>Find (with path compression): O(\u03b1(n)) amortized</li> <li>Union (with union by rank): O(\u03b1(n)) amortized</li> <li>Connected: O(\u03b1(n)) amortized</li> <li>\u03b1(n): Inverse Ackermann function (practically constant)</li> </ul>"},{"location":"data-structures/disjoint-set/#space-complexity","title":"Space Complexity","text":"<ul> <li>Basic DSU: O(n) for parent and rank arrays</li> <li>With Size Tracking: O(n) for additional size array</li> <li>With Rollback: O(n + m) where m is number of operations</li> </ul>"},{"location":"data-structures/disjoint-set/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Path Compression: Always use path compression in find operation</li> <li>Union by Rank: Use union by rank for better performance</li> <li>Early Termination: Stop when all elements are connected</li> <li>Memory Management: Use appropriate data structures for your use case</li> <li>Batch Operations: Process multiple unions together when possible</li> <li>Rollback Support: Add rollback only when needed (adds overhead)</li> </ol>"},{"location":"data-structures/disjoint-set/#common-patterns","title":"Common Patterns","text":""},{"location":"data-structures/disjoint-set/#standard-dsu-pattern","title":"Standard DSU Pattern","text":"<pre><code>DisjointSetUnion dsu(n);\nfor (auto&amp; edge : edges) {\n    if (!dsu.connected(edge.u, edge.v)) {\n        dsu.unionSets(edge.u, edge.v);\n        // Process the edge\n    }\n}\n</code></pre>"},{"location":"data-structures/disjoint-set/#component-counting-pattern","title":"Component Counting Pattern","text":"<pre><code>DisjointSetUnion dsu(n);\n// Perform all unions\nint components = dsu.getComponents();\n</code></pre>"},{"location":"data-structures/disjoint-set/#cycle-detection-pattern","title":"Cycle Detection Pattern","text":"<pre><code>DisjointSetUnion dsu(n);\nfor (auto&amp; edge : edges) {\n    if (dsu.connected(edge.u, edge.v)) {\n        // Cycle detected\n        return edge;\n    }\n    dsu.unionSets(edge.u, edge.v);\n}\n</code></pre>"},{"location":"data-structures/heap-priority-queue/","title":"Heap / Priority Queue","text":"<p>Heaps and Priority Queues are fundamental data structures for maintaining extremal elements (minimum or maximum) with efficient insertion and deletion operations. They are essential for many algorithms including Dijkstra's shortest path, heap sort, and task scheduling.</p>"},{"location":"data-structures/heap-priority-queue/#heap-properties","title":"Heap Properties","text":"<p>A heap is a complete binary tree that satisfies the heap property: - Min-Heap: Parent \u2264 Children - Max-Heap: Parent \u2265 Children</p>"},{"location":"data-structures/heap-priority-queue/#basic-heap-implementation","title":"Basic Heap Implementation","text":""},{"location":"data-structures/heap-priority-queue/#min-heap-implementation","title":"Min-Heap Implementation","text":"<p>Problem: Implement a min-heap with insert, extract-min, and peek operations.</p> <p>Sample Input:  - Operations: <code>insert(5)</code>, <code>insert(3)</code>, <code>insert(8)</code>, <code>peek()</code>, <code>extractMin()</code>, <code>peek()</code></p> <p>Sample Output:  - After insertions: <code>peek() = 3</code> - After <code>extractMin()</code>: <code>peek() = 5</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass MinHeap {\nprivate:\n    vector&lt;int&gt; heap;\n\n    void heapifyUp(int index) {\n        while (index &gt; 0) {\n            int parent = (index - 1) / 2;\n            if (heap[index] &gt;= heap[parent]) break;\n            swap(heap[index], heap[parent]);\n            index = parent;\n        }\n    }\n\n    void heapifyDown(int index) {\n        while (true) {\n            int smallest = index;\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n\n            if (left &lt; heap.size() &amp;&amp; heap[left] &lt; heap[smallest]) {\n                smallest = left;\n            }\n            if (right &lt; heap.size() &amp;&amp; heap[right] &lt; heap[smallest]) {\n                smallest = right;\n            }\n\n            if (smallest == index) break;\n\n            swap(heap[index], heap[smallest]);\n            index = smallest;\n        }\n    }\n\npublic:\n    void insert(int value) {\n        heap.push_back(value);\n        heapifyUp(heap.size() - 1);\n    }\n\n    int extractMin() {\n        if (heap.empty()) return -1;\n\n        int min = heap[0];\n        heap[0] = heap.back();\n        heap.pop_back();\n\n        if (!heap.empty()) {\n            heapifyDown(0);\n        }\n\n        return min;\n    }\n\n    int peek() {\n        return heap.empty() ? -1 : heap[0];\n    }\n\n    bool empty() {\n        return heap.empty();\n    }\n\n    int size() {\n        return heap.size();\n    }\n};\n</code></pre>"},{"location":"data-structures/heap-priority-queue/#max-heap-implementation","title":"Max-Heap Implementation","text":"<p>Problem: Implement a max-heap with insert, extract-max, and peek operations.</p> <p>Sample Input:  - Operations: <code>insert(5)</code>, <code>insert(3)</code>, <code>insert(8)</code>, <code>peek()</code>, <code>extractMax()</code>, <code>peek()</code></p> <p>Sample Output:  - After insertions: <code>peek() = 8</code> - After <code>extractMax()</code>: <code>peek() = 5</code></p> <pre><code>class MaxHeap {\nprivate:\n    vector&lt;int&gt; heap;\n\n    void heapifyUp(int index) {\n        while (index &gt; 0) {\n            int parent = (index - 1) / 2;\n            if (heap[index] &lt;= heap[parent]) break;\n            swap(heap[index], heap[parent]);\n            index = parent;\n        }\n    }\n\n    void heapifyDown(int index) {\n        while (true) {\n            int largest = index;\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n\n            if (left &lt; heap.size() &amp;&amp; heap[left] &gt; heap[largest]) {\n                largest = left;\n            }\n            if (right &lt; heap.size() &amp;&amp; heap[right] &gt; heap[largest]) {\n                largest = right;\n            }\n\n            if (largest == index) break;\n\n            swap(heap[index], heap[largest]);\n            index = largest;\n        }\n    }\n\npublic:\n    void insert(int value) {\n        heap.push_back(value);\n        heapifyUp(heap.size() - 1);\n    }\n\n    int extractMax() {\n        if (heap.empty()) return -1;\n\n        int max = heap[0];\n        heap[0] = heap.back();\n        heap.pop_back();\n\n        if (!heap.empty()) {\n            heapifyDown(0);\n        }\n\n        return max;\n    }\n\n    int peek() {\n        return heap.empty() ? -1 : heap[0];\n    }\n\n    bool empty() {\n        return heap.empty();\n    }\n\n    int size() {\n        return heap.size();\n    }\n};\n</code></pre>"},{"location":"data-structures/heap-priority-queue/#priority-queue-with-custom-comparators","title":"Priority Queue with Custom Comparators","text":"<p>Problem: Implement a priority queue that can handle custom comparison functions.</p> <p>Sample Input:  - Custom comparator: Sort by string length - Operations: <code>push(\"apple\")</code>, <code>push(\"hi\")</code>, <code>push(\"hello\")</code>, <code>top()</code>, <code>pop()</code>, <code>top()</code></p> <p>Sample Output:  - After insertions: <code>top() = \"hello\"</code> (longest string) - After <code>pop()</code>: <code>top() = \"apple\"</code></p> <pre><code>#include &lt;queue&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass CustomPriorityQueue {\nprivate:\n    struct StringLengthComparator {\n        bool operator()(const string&amp; a, const string&amp; b) {\n            return a.length() &lt; b.length(); // Max-heap by length\n        }\n    };\n\n    priority_queue&lt;string, vector&lt;string&gt;, StringLengthComparator&gt; pq;\n\npublic:\n    void push(const string&amp; value) {\n        pq.push(value);\n    }\n\n    string top() {\n        return pq.empty() ? \"\" : pq.top();\n    }\n\n    void pop() {\n        if (!pq.empty()) {\n            pq.pop();\n        }\n    }\n\n    bool empty() {\n        return pq.empty();\n    }\n\n    int size() {\n        return pq.size();\n    }\n};\n</code></pre>"},{"location":"data-structures/heap-priority-queue/#advanced-applications","title":"Advanced Applications","text":""},{"location":"data-structures/heap-priority-queue/#median-maintenance","title":"Median Maintenance","text":"<p>Problem: Maintain the median of a stream of numbers using two heaps.</p> <p>Sample Input:  - Stream: <code>[5, 15, 1, 3]</code> - Operations: <code>add(5)</code>, <code>getMedian()</code>, <code>add(15)</code>, <code>getMedian()</code>, <code>add(1)</code>, <code>getMedian()</code>, <code>add(3)</code>, <code>getMedian()</code></p> <p>Sample Output:  - After <code>add(5)</code>: <code>getMedian() = 5</code> - After <code>add(15)</code>: <code>getMedian() = 10</code> - After <code>add(1)</code>: <code>getMedian() = 5</code> - After <code>add(3)</code>: <code>getMedian() = 4</code></p> <pre><code>class MedianFinder {\nprivate:\n    priority_queue&lt;int&gt; maxHeap; // Left half (max-heap)\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap; // Right half (min-heap)\n\npublic:\n    void addNum(int num) {\n        if (maxHeap.empty() || num &lt;= maxHeap.top()) {\n            maxHeap.push(num);\n        } else {\n            minHeap.push(num);\n        }\n\n        // Balance heaps\n        if (maxHeap.size() &gt; minHeap.size() + 1) {\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n        } else if (minHeap.size() &gt; maxHeap.size() + 1) {\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n        }\n    }\n\n    double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else if (maxHeap.size() &gt; minHeap.size()) {\n            return maxHeap.top();\n        } else {\n            return minHeap.top();\n        }\n    }\n};\n</code></pre>"},{"location":"data-structures/heap-priority-queue/#merge-k-sorted-arrays","title":"Merge K Sorted Arrays","text":"<p>Problem: Merge k sorted arrays into one sorted array using a min-heap.</p> <p>Sample Input:  - Arrays: <code>[[1, 4, 7], [2, 5, 8], [3, 6, 9]]</code></p> <p>Sample Output:  - Merged: <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nclass MergeKSorted {\nprivate:\n    struct Element {\n        int value;\n        int arrayIndex;\n        int elementIndex;\n\n        Element(int v, int ai, int ei) : value(v), arrayIndex(ai), elementIndex(ei) {}\n\n        bool operator&gt;(const Element&amp; other) const {\n            return value &gt; other.value;\n        }\n    };\n\npublic:\n    vector&lt;int&gt; mergeKSortedArrays(vector&lt;vector&lt;int&gt;&gt;&amp; arrays) {\n        priority_queue&lt;Element, vector&lt;Element&gt;, greater&lt;Element&gt;&gt; minHeap;\n        vector&lt;int&gt; result;\n\n        // Insert first element from each array\n        for (int i = 0; i &lt; arrays.size(); i++) {\n            if (!arrays[i].empty()) {\n                minHeap.push(Element(arrays[i][0], i, 0));\n            }\n        }\n\n        while (!minHeap.empty()) {\n            Element current = minHeap.top();\n            minHeap.pop();\n\n            result.push_back(current.value);\n\n            // Insert next element from the same array\n            if (current.elementIndex + 1 &lt; arrays[current.arrayIndex].size()) {\n                minHeap.push(Element(arrays[current.arrayIndex][current.elementIndex + 1], \n                                   current.arrayIndex, current.elementIndex + 1));\n            }\n        }\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"data-structures/heap-priority-queue/#task-scheduling","title":"Task Scheduling","text":"<p>Problem: Schedule tasks with different priorities and deadlines using a priority queue.</p> <p>Sample Input:  - Tasks: <code>[(1, 3), (2, 1), (3, 2)]</code> (priority, deadline) - Operations: <code>addTask(1, 3)</code>, <code>addTask(2, 1)</code>, <code>addTask(3, 2)</code>, <code>getNextTask()</code>, <code>getNextTask()</code></p> <p>Sample Output:  - <code>getNextTask() = 2</code> (highest priority) - <code>getNextTask() = 3</code> (next highest priority)</p> <pre><code>struct Task {\n    int priority;\n    int deadline;\n    int id;\n\n    Task(int p, int d, int i) : priority(p), deadline(d), id(i) {}\n\n    bool operator&lt;(const Task&amp; other) const {\n        if (priority != other.priority) {\n            return priority &lt; other.priority; // Higher priority first\n        }\n        return deadline &gt; other.deadline; // Earlier deadline first\n    }\n};\n\nclass TaskScheduler {\nprivate:\n    priority_queue&lt;Task&gt; taskQueue;\n    int nextId = 0;\n\npublic:\n    void addTask(int priority, int deadline) {\n        taskQueue.push(Task(priority, deadline, nextId++));\n    }\n\n    Task getNextTask() {\n        if (taskQueue.empty()) {\n            return Task(-1, -1, -1); // No tasks\n        }\n\n        Task next = taskQueue.top();\n        taskQueue.pop();\n        return next;\n    }\n\n    bool hasTasks() {\n        return !taskQueue.empty();\n    }\n};\n</code></pre>"},{"location":"data-structures/heap-priority-queue/#heap-sort","title":"Heap Sort","text":"<p>Problem: Sort an array using heap sort algorithm.</p> <p>Sample Input:  - Array: <code>[64, 34, 25, 12, 22, 11, 90]</code></p> <p>Sample Output:  - Sorted: <code>[11, 12, 22, 25, 34, 64, 90]</code></p> <pre><code>class HeapSort {\nprivate:\n    void heapify(vector&lt;int&gt;&amp; arr, int n, int i) {\n        int largest = i;\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n\n        if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {\n            largest = left;\n        }\n\n        if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {\n            largest = right;\n        }\n\n        if (largest != i) {\n            swap(arr[i], arr[largest]);\n            heapify(arr, n, largest);\n        }\n    }\n\npublic:\n    void heapSort(vector&lt;int&gt;&amp; arr) {\n        int n = arr.size();\n\n        // Build max heap\n        for (int i = n / 2 - 1; i &gt;= 0; i--) {\n            heapify(arr, n, i);\n        }\n\n        // Extract elements one by one\n        for (int i = n - 1; i &gt; 0; i--) {\n            swap(arr[0], arr[i]);\n            heapify(arr, i, 0);\n        }\n    }\n};\n</code></pre>"},{"location":"data-structures/heap-priority-queue/#use-cases","title":"Use Cases","text":""},{"location":"data-structures/heap-priority-queue/#graph-algorithms","title":"Graph Algorithms","text":"<ul> <li>Dijkstra's Algorithm: Finding shortest paths</li> <li>Prim's Algorithm: Minimum spanning tree</li> <li>A* Search: Pathfinding with heuristics</li> <li>Topological Sort: Ordering with dependencies</li> </ul>"},{"location":"data-structures/heap-priority-queue/#sorting-and-selection","title":"Sorting and Selection","text":"<ul> <li>Heap Sort: In-place sorting algorithm</li> <li>Kth Largest Element: Finding kth largest element</li> <li>Merge K Sorted Lists: Combining sorted sequences</li> <li>External Sorting: Sorting large datasets</li> </ul>"},{"location":"data-structures/heap-priority-queue/#system-design","title":"System Design","text":"<ul> <li>Task Scheduling: Priority-based task execution</li> <li>Load Balancing: Distributing work efficiently</li> <li>Memory Management: Managing memory allocation</li> <li>Event Processing: Processing events by priority</li> </ul>"},{"location":"data-structures/heap-priority-queue/#data-processing","title":"Data Processing","text":"<ul> <li>Median Maintenance: Keeping track of running median</li> <li>Stream Processing: Processing data streams</li> <li>Top K Elements: Finding most frequent elements</li> <li>Sliding Window: Maintaining window statistics</li> </ul>"},{"location":"data-structures/heap-priority-queue/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"data-structures/heap-priority-queue/#time-complexity","title":"Time Complexity","text":"<ul> <li>Insert: O(log n)</li> <li>Extract Min/Max: O(log n)</li> <li>Peek: O(1)</li> <li>Build Heap: O(n)</li> <li>Heap Sort: O(n log n)</li> </ul>"},{"location":"data-structures/heap-priority-queue/#space-complexity","title":"Space Complexity","text":"<ul> <li>All Operations: O(n) for storing elements</li> <li>In-place Heap Sort: O(1) additional space</li> </ul>"},{"location":"data-structures/heap-priority-queue/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Choose Right Heap: Use min-heap for smallest elements, max-heap for largest</li> <li>Custom Comparators: Use custom comparators for complex ordering</li> <li>Memory Management: Use appropriate data types to save memory</li> <li>Batch Operations: Process multiple operations together when possible</li> <li>Lazy Deletion: Mark elements as deleted instead of removing immediately</li> <li>Fibonacci Heaps: Use for advanced algorithms requiring decrease-key operations</li> </ol>"},{"location":"data-structures/segment-tree-bit/","title":"Segment Tree / Binary Indexed Tree (BIT)","text":"<p>Segment Trees and Binary Indexed Trees (Fenwick Trees) are powerful data structures for efficiently handling range queries and updates. They enable O(log n) time complexity for both point updates and range queries, making them essential for many competitive programming problems.</p>"},{"location":"data-structures/segment-tree-bit/#segment-tree","title":"Segment Tree","text":"<p>A Segment Tree is a binary tree where each node represents a segment of the array. It allows efficient range queries and updates.</p>"},{"location":"data-structures/segment-tree-bit/#basic-structure","title":"Basic Structure","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector&lt;int&gt; tree;\n    int n;\n\n    void build(vector&lt;int&gt;&amp; arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node, start, mid);\n            build(arr, 2 * node + 1, mid + 1, end);\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    void update(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            tree[node] = val;\n        } else {\n            int mid = (start + end) / 2;\n            if (idx &lt;= mid) {\n                update(2 * node, start, mid, idx, val);\n            } else {\n                update(2 * node + 1, mid + 1, end, idx, val);\n            }\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r &lt; start || end &lt; l) {\n            return 0;\n        }\n        if (l &lt;= start &amp;&amp; end &lt;= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left = query(2 * node, start, mid, l, r);\n        int right = query(2 * node + 1, mid + 1, end, l, r);\n        return left + right;\n    }\n\npublic:\n    SegmentTree(vector&lt;int&gt;&amp; arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void update(int idx, int val) {\n        update(1, 0, n - 1, idx, val);\n    }\n\n    int rangeSum(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n};\n</code></pre>"},{"location":"data-structures/segment-tree-bit/#range-sum-queries","title":"Range Sum Queries","text":"<p>Problem: Handle range sum queries and point updates efficiently.</p> <p>Sample Input:  - Array: <code>[1, 3, 5, 7, 9, 11]</code> - Queries: <code>rangeSum(1, 3)</code>, <code>update(1, 10)</code>, <code>rangeSum(1, 3)</code></p> <p>Sample Output:  - <code>rangeSum(1, 3) = 15</code> (3 + 5 + 7) - After <code>update(1, 10)</code>: <code>rangeSum(1, 3) = 22</code> (10 + 5 + 7)</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11};\n    SegmentTree st(arr);\n\n    cout &lt;&lt; \"Range sum(1, 3): \" &lt;&lt; st.rangeSum(1, 3) &lt;&lt; endl;\n\n    st.update(1, 10);\n    cout &lt;&lt; \"After update(1, 10), range sum(1, 3): \" &lt;&lt; st.rangeSum(1, 3) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"data-structures/segment-tree-bit/#range-minimum-queries","title":"Range Minimum Queries","text":"<p>Problem: Find the minimum element in a range with point updates.</p> <p>Sample Input:  - Array: <code>[1, 3, 2, 7, 9, 11]</code> - Queries: <code>rangeMin(1, 3)</code>, <code>update(1, 0)</code>, <code>rangeMin(1, 3)</code></p> <p>Sample Output:  - <code>rangeMin(1, 3) = 2</code> (min of 3, 2, 7) - After <code>update(1, 0)</code>: <code>rangeMin(1, 3) = 0</code> (min of 0, 2, 7)</p> <pre><code>class MinSegmentTree {\nprivate:\n    vector&lt;int&gt; tree;\n    int n;\n\n    void build(vector&lt;int&gt;&amp; arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node, start, mid);\n            build(arr, 2 * node + 1, mid + 1, end);\n            tree[node] = min(tree[2 * node], tree[2 * node + 1]);\n        }\n    }\n\n    void update(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            tree[node] = val;\n        } else {\n            int mid = (start + end) / 2;\n            if (idx &lt;= mid) {\n                update(2 * node, start, mid, idx, val);\n            } else {\n                update(2 * node + 1, mid + 1, end, idx, val);\n            }\n            tree[node] = min(tree[2 * node], tree[2 * node + 1]);\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r &lt; start || end &lt; l) {\n            return INT_MAX;\n        }\n        if (l &lt;= start &amp;&amp; end &lt;= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left = query(2 * node, start, mid, l, r);\n        int right = query(2 * node + 1, mid + 1, end, l, r);\n        return min(left, right);\n    }\n\npublic:\n    MinSegmentTree(vector&lt;int&gt;&amp; arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void update(int idx, int val) {\n        update(1, 0, n - 1, idx, val);\n    }\n\n    int rangeMin(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n};\n</code></pre>"},{"location":"data-structures/segment-tree-bit/#binary-indexed-tree-fenwick-tree","title":"Binary Indexed Tree (Fenwick Tree)","text":"<p>A Binary Indexed Tree is a more space-efficient alternative to Segment Trees for range sum queries.</p>"},{"location":"data-structures/segment-tree-bit/#basic-implementation","title":"Basic Implementation","text":"<p>Problem: Implement Binary Indexed Tree for range sum queries and point updates.</p> <p>Sample Input:  - Array: <code>[1, 3, 5, 7, 9, 11]</code> - Queries: <code>rangeSum(1, 3)</code>, <code>update(1, 10)</code>, <code>rangeSum(1, 3)</code></p> <p>Sample Output:  - <code>rangeSum(1, 3) = 15</code> (3 + 5 + 7) - After <code>update(1, 10)</code>: <code>rangeSum(1, 3) = 22</code> (10 + 5 + 7)</p> <pre><code>class BinaryIndexedTree {\nprivate:\n    vector&lt;int&gt; bit;\n    int n;\n\n    int getSum(int idx) {\n        int sum = 0;\n        idx++; // 1-indexed\n        while (idx &gt; 0) {\n            sum += bit[idx];\n            idx -= idx &amp; (-idx);\n        }\n        return sum;\n    }\n\n    void update(int idx, int val) {\n        idx++; // 1-indexed\n        while (idx &lt;= n) {\n            bit[idx] += val;\n            idx += idx &amp; (-idx);\n        }\n    }\n\npublic:\n    BinaryIndexedTree(vector&lt;int&gt;&amp; arr) {\n        n = arr.size();\n        bit.resize(n + 1, 0);\n\n        for (int i = 0; i &lt; n; i++) {\n            update(i, arr[i]);\n        }\n    }\n\n    void update(int idx, int val) {\n        int diff = val - getSum(idx) + getSum(idx - 1);\n        update(idx, diff);\n    }\n\n    int rangeSum(int l, int r) {\n        return getSum(r) - getSum(l - 1);\n    }\n\n    int getSum(int idx) {\n        int sum = 0;\n        idx++; // 1-indexed\n        while (idx &gt; 0) {\n            sum += bit[idx];\n            idx -= idx &amp; (-idx);\n        }\n        return sum;\n    }\n};\n</code></pre>"},{"location":"data-structures/segment-tree-bit/#advanced-applications","title":"Advanced Applications","text":""},{"location":"data-structures/segment-tree-bit/#range-updates-with-lazy-propagation","title":"Range Updates with Lazy Propagation","text":"<p>Problem: Handle range updates efficiently using lazy propagation.</p> <p>Sample Input:  - Array: <code>[1, 3, 5, 7, 9, 11]</code> - Operations: <code>rangeUpdate(1, 3, 2)</code>, <code>rangeSum(1, 3)</code></p> <p>Sample Output:  - After <code>rangeUpdate(1, 3, 2)</code>: <code>rangeSum(1, 3) = 21</code> (5 + 7 + 9)</p> <pre><code>class LazySegmentTree {\nprivate:\n    vector&lt;int&gt; tree, lazy;\n    int n;\n\n    void push(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            tree[node] += (end - start + 1) * lazy[node];\n            if (start != end) {\n                lazy[2 * node] += lazy[node];\n                lazy[2 * node + 1] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n\n    void rangeUpdate(int node, int start, int end, int l, int r, int val) {\n        push(node, start, end);\n        if (r &lt; start || end &lt; l) return;\n\n        if (l &lt;= start &amp;&amp; end &lt;= r) {\n            lazy[node] += val;\n            push(node, start, end);\n        } else {\n            int mid = (start + end) / 2;\n            rangeUpdate(2 * node, start, mid, l, r, val);\n            rangeUpdate(2 * node + 1, mid + 1, end, l, r, val);\n            push(2 * node, start, mid);\n            push(2 * node + 1, mid + 1, end);\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    int rangeSum(int node, int start, int end, int l, int r) {\n        push(node, start, end);\n        if (r &lt; start || end &lt; l) return 0;\n        if (l &lt;= start &amp;&amp; end &lt;= r) return tree[node];\n\n        int mid = (start + end) / 2;\n        int left = rangeSum(2 * node, start, mid, l, r);\n        int right = rangeSum(2 * node + 1, mid + 1, end, l, r);\n        return left + right;\n    }\n\npublic:\n    LazySegmentTree(vector&lt;int&gt;&amp; arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        lazy.resize(4 * n, 0);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void rangeUpdate(int l, int r, int val) {\n        rangeUpdate(1, 0, n - 1, l, r, val);\n    }\n\n    int rangeSum(int l, int r) {\n        return rangeSum(1, 0, n - 1, l, r);\n    }\n};\n</code></pre>"},{"location":"data-structures/segment-tree-bit/#2d-segment-tree","title":"2D Segment Tree","text":"<p>Problem: Handle range queries and updates on a 2D matrix.</p> <p>Sample Input:  - Matrix: <code>[[1, 2], [3, 4]]</code> - Queries: <code>rangeSum(0, 0, 1, 1)</code>, <code>update(0, 0, 5)</code>, <code>rangeSum(0, 0, 1, 1)</code></p> <p>Sample Output:  - <code>rangeSum(0, 0, 1, 1) = 10</code> (1 + 2 + 3 + 4) - After <code>update(0, 0, 5)</code>: <code>rangeSum(0, 0, 1, 1) = 14</code> (5 + 2 + 3 + 4)</p> <pre><code>class SegmentTree2D {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; tree;\n    int n, m;\n\n    void build(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int nodeX, int nodeY, int startX, int endX, int startY, int endY) {\n        if (startX == endX &amp;&amp; startY == endY) {\n            tree[nodeX][nodeY] = matrix[startX][startY];\n        } else if (startX == endX) {\n            int midY = (startY + endY) / 2;\n            build(matrix, nodeX, 2 * nodeY, startX, endX, startY, midY);\n            build(matrix, nodeX, 2 * nodeY + 1, startX, endX, midY + 1, endY);\n            tree[nodeX][nodeY] = tree[nodeX][2 * nodeY] + tree[nodeX][2 * nodeY + 1];\n        } else {\n            int midX = (startX + endX) / 2;\n            build(matrix, 2 * nodeX, nodeY, startX, midX, startY, endY);\n            build(matrix, 2 * nodeX + 1, nodeY, midX + 1, endX, startY, endY);\n            tree[nodeX][nodeY] = tree[2 * nodeX][nodeY] + tree[2 * nodeX + 1][nodeY];\n        }\n    }\n\npublic:\n    SegmentTree2D(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        n = matrix.size();\n        m = matrix[0].size();\n        tree.resize(4 * n, vector&lt;int&gt;(4 * m));\n        build(matrix, 1, 1, 0, n - 1, 0, m - 1);\n    }\n\n    int rangeSum(int x1, int y1, int x2, int y2) {\n        return query(1, 1, 0, n - 1, 0, m - 1, x1, y1, x2, y2);\n    }\n\nprivate:\n    int query(int nodeX, int nodeY, int startX, int endX, int startY, int endY, int x1, int y1, int x2, int y2) {\n        if (x2 &lt; startX || endX &lt; x1 || y2 &lt; startY || endY &lt; y1) return 0;\n        if (x1 &lt;= startX &amp;&amp; endX &lt;= x2 &amp;&amp; y1 &lt;= startY &amp;&amp; endY &lt;= y2) return tree[nodeX][nodeY];\n\n        int midX = (startX + endX) / 2;\n        int midY = (startY + endY) / 2;\n\n        int sum = 0;\n        sum += query(2 * nodeX, 2 * nodeY, startX, midX, startY, midY, x1, y1, x2, y2);\n        sum += query(2 * nodeX, 2 * nodeY + 1, startX, midX, midY + 1, endY, x1, y1, x2, y2);\n        sum += query(2 * nodeX + 1, 2 * nodeY, midX + 1, endX, startY, midY, x1, y1, x2, y2);\n        sum += query(2 * nodeX + 1, 2 * nodeY + 1, midX + 1, endX, midY + 1, endY, x1, y1, x2, y2);\n\n        return sum;\n    }\n};\n</code></pre>"},{"location":"data-structures/segment-tree-bit/#use-cases","title":"Use Cases","text":""},{"location":"data-structures/segment-tree-bit/#range-query-problems","title":"Range Query Problems","text":"<ul> <li>Range Sum: Computing sums over ranges efficiently</li> <li>Range Minimum/Maximum: Finding extremal values in ranges</li> <li>Range GCD/LCM: Computing greatest common divisor or least common multiple</li> <li>Range XOR: Computing XOR over ranges</li> </ul>"},{"location":"data-structures/segment-tree-bit/#update-problems","title":"Update Problems","text":"<ul> <li>Point Updates: Updating individual elements</li> <li>Range Updates: Updating ranges of elements</li> <li>Lazy Propagation: Efficient range updates</li> <li>2D Updates: Updating 2D ranges</li> </ul>"},{"location":"data-structures/segment-tree-bit/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>RMQ Problems: Range Minimum Query problems</li> <li>RSQ Problems: Range Sum Query problems</li> <li>Inversion Counting: Counting inversions in arrays</li> <li>Frequency Queries: Handling frequency-based queries</li> </ul>"},{"location":"data-structures/segment-tree-bit/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"data-structures/segment-tree-bit/#time-complexity","title":"Time Complexity","text":"<ul> <li>Build: O(n) for Segment Tree, O(n log n) for BIT</li> <li>Point Update: O(log n) for both</li> <li>Range Query: O(log n) for both</li> <li>Range Update: O(log n) with lazy propagation</li> </ul>"},{"location":"data-structures/segment-tree-bit/#space-complexity","title":"Space Complexity","text":"<ul> <li>Segment Tree: O(4n) for 1D, O(16nm) for 2D</li> <li>Binary Indexed Tree: O(n) for 1D, O(nm) for 2D</li> <li>Lazy Propagation: O(4n) additional space</li> </ul>"},{"location":"data-structures/segment-tree-bit/#when-to-use-each","title":"When to Use Each","text":""},{"location":"data-structures/segment-tree-bit/#use-segment-tree-when","title":"Use Segment Tree when:","text":"<ul> <li>You need range updates with lazy propagation</li> <li>Complex range operations (min, max, gcd, etc.)</li> <li>2D range queries</li> <li>Non-commutative operations</li> </ul>"},{"location":"data-structures/segment-tree-bit/#use-binary-indexed-tree-when","title":"Use Binary Indexed Tree when:","text":"<ul> <li>Only need range sum queries</li> <li>Space is a constraint</li> <li>Simple point updates</li> <li>Commutative operations</li> </ul>"},{"location":"data-structures/segment-tree-bit/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Choose Right Structure: Use BIT for simple range sums, Segment Tree for complex operations</li> <li>Lazy Propagation: Use for range updates to avoid O(n) per update</li> <li>Coordinate Compression: Compress coordinates for sparse data</li> <li>Memory Management: Use appropriate data types to save memory</li> <li>Batch Operations: Process multiple queries together when possible</li> <li>2D Optimization: Use 2D BIT for 2D range sums when possible</li> </ol>"},{"location":"dynamic-programming/","title":"Dynamic Programming (DP)","text":"<p>Dynamic Programming is a powerful algorithmic paradigm that solves complex problems by breaking them down into simpler subproblems and storing the solutions to avoid redundant calculations. It's particularly effective for optimization problems with overlapping subproblems.</p>"},{"location":"dynamic-programming/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link Top-Down &amp; Bottom-Up Two fundamental approaches to implementing dynamic programming solutions, each with its own advantages. Top-Down &amp; Bottom-Up Bitmask DP Using bitmasks to represent states in dynamic programming, particularly useful for subset problems and state space optimization. Bitmask DP DP on Trees / Graphs Applying dynamic programming techniques to tree and graph structures for solving complex traversal and optimization problems. DP on Trees / Graphs"},{"location":"dynamic-programming/#when-to-use-dynamic-programming","title":"When to Use Dynamic Programming","text":"<p>DP is most effective when: - The problem has optimal substructure - Subproblems overlap (same subproblems are solved multiple times) - You need to find the optimal solution among many possibilities - The problem can be broken down into smaller, similar problems</p>"},{"location":"dynamic-programming/#key-principles","title":"Key Principles","text":"<ol> <li>Optimal Substructure: The optimal solution contains optimal solutions to subproblems</li> <li>Overlapping Subproblems: The same subproblems are solved multiple times</li> <li>Memoization: Store results of subproblems to avoid recomputation</li> <li>State Definition: Clearly define what each state represents</li> </ol>"},{"location":"dynamic-programming/bitmask-dp/","title":"Bitmask Dynamic Programming","text":"<p>Bitmask DP is a powerful technique that uses binary representations to represent states in dynamic programming problems. It's particularly useful for subset problems, state space optimization, and problems where you need to track which elements have been used or visited.</p>"},{"location":"dynamic-programming/bitmask-dp/#how-it-works","title":"How It Works","text":"<p>Bitmask DP uses integers to represent sets, where each bit position indicates whether an element is included (1) or excluded (0). This allows for efficient state representation and transitions.</p>"},{"location":"dynamic-programming/bitmask-dp/#basic-concepts","title":"Basic Concepts","text":""},{"location":"dynamic-programming/bitmask-dp/#bitmask-operations","title":"Bitmask Operations","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid demonstrateBitmaskOps() {\n    int mask = 0b1010; // Binary: 1010 (elements 1 and 3 are set)\n\n    // Check if element i is set\n    bool isSet = (mask &amp; (1 &lt;&lt; i)) != 0;\n\n    // Set element i\n    mask |= (1 &lt;&lt; i);\n\n    // Unset element i\n    mask &amp;= ~(1 &lt;&lt; i);\n\n    // Toggle element i\n    mask ^= (1 &lt;&lt; i);\n\n    // Count set bits\n    int count = __builtin_popcount(mask);\n\n    // Get all subsets of a mask\n    for (int subset = mask; subset; subset = (subset - 1) &amp; mask) {\n        // Process subset\n    }\n}\n</code></pre>"},{"location":"dynamic-programming/bitmask-dp/#classic-problems","title":"Classic Problems","text":""},{"location":"dynamic-programming/bitmask-dp/#traveling-salesman-problem-tsp","title":"Traveling Salesman Problem (TSP)","text":"<p>Problem: Find the shortest route that visits each city exactly once and returns to the starting city.</p> <p>Sample Input:  <pre><code>Distance matrix:\n   0  10  15  20\n  10   0  35  25\n  15  35   0  30\n  20  25  30   0\n</code></pre></p> <p>Sample Output: <code>80</code> (Route: 0 \u2192 1 \u2192 3 \u2192 2 \u2192 0)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass TSPBitmask {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; dist;\n    vector&lt;vector&lt;int&gt;&gt; dp;\n    int n;\n\npublic:\n    int solveTSP(vector&lt;vector&lt;int&gt;&gt;&amp; distance) {\n        n = distance.size();\n        dist = distance;\n        dp.assign(1 &lt;&lt; n, vector&lt;int&gt;(n, -1));\n\n        return tsp(1, 0); // Start from city 0, only city 0 visited\n    }\n\nprivate:\n    int tsp(int mask, int pos) {\n        // If all cities visited, return to start\n        if (mask == (1 &lt;&lt; n) - 1) {\n            return dist[pos][0];\n        }\n\n        if (dp[mask][pos] != -1) {\n            return dp[mask][pos];\n        }\n\n        int minCost = INT_MAX;\n\n        // Try visiting each unvisited city\n        for (int next = 0; next &lt; n; next++) {\n            if (!(mask &amp; (1 &lt;&lt; next))) { // If city not visited\n                int newMask = mask | (1 &lt;&lt; next);\n                int cost = dist[pos][next] + tsp(newMask, next);\n                minCost = min(minCost, cost);\n            }\n        }\n\n        return dp[mask][pos] = minCost;\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/bitmask-dp/#assignment-problem","title":"Assignment Problem","text":"<p>Problem: Assign n tasks to n workers such that each task is assigned to exactly one worker and the total cost is minimized.</p> <p>Sample Input:  <pre><code>Cost matrix:\n[9, 2, 7, 8]\n[6, 4, 3, 7]\n[5, 8, 1, 8]\n[7, 6, 9, 4]\n</code></pre></p> <p>Sample Output: <code>13</code> (Minimum cost assignment)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass AssignmentProblem {\npublic:\n    int minCostAssignment(vector&lt;vector&lt;int&gt;&gt;&amp; cost) {\n        int n = cost.size();\n        vector&lt;int&gt; dp(1 &lt;&lt; n, INT_MAX);\n        dp[0] = 0; // Base case: no assignments made\n\n        for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {\n            int assigned = __builtin_popcount(mask);\n\n            for (int i = 0; i &lt; n; i++) {\n                if (!(mask &amp; (1 &lt;&lt; i))) { // If task i not assigned\n                    int newMask = mask | (1 &lt;&lt; i);\n                    dp[newMask] = min(dp[newMask], dp[mask] + cost[assigned][i]);\n                }\n            }\n        }\n\n        return dp[(1 &lt;&lt; n) - 1];\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/bitmask-dp/#advanced-applications","title":"Advanced Applications","text":""},{"location":"dynamic-programming/bitmask-dp/#subset-sum-with-bitmask","title":"Subset Sum with Bitmask","text":"<p>Problem: Find if there exists a subset that sums to a target value using bitmask DP.</p> <p>Sample Input:  - <code>arr = [1, 2, 3, 4, 5]</code> - <code>target = 9</code></p> <p>Sample Output: <code>true</code> (subsets like [2,3,4], [1,3,5], [4,5] sum to 9)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nclass SubsetSumBitmask {\npublic:\n    bool subsetSum(vector&lt;int&gt;&amp; arr, int target) {\n        int n = arr.size();\n        unordered_set&lt;int&gt; possibleSums;\n        possibleSums.insert(0);\n\n        for (int mask = 1; mask &lt; (1 &lt;&lt; n); mask++) {\n            int sum = 0;\n            for (int i = 0; i &lt; n; i++) {\n                if (mask &amp; (1 &lt;&lt; i)) {\n                    sum += arr[i];\n                }\n            }\n            possibleSums.insert(sum);\n\n            if (sum == target) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; getAllSubsets(vector&lt;int&gt;&amp; arr, int target) {\n        int n = arr.size();\n        vector&lt;vector&lt;int&gt;&gt; result;\n\n        for (int mask = 1; mask &lt; (1 &lt;&lt; n); mask++) {\n            int sum = 0;\n            vector&lt;int&gt; subset;\n\n            for (int i = 0; i &lt; n; i++) {\n                if (mask &amp; (1 &lt;&lt; i)) {\n                    sum += arr[i];\n                    subset.push_back(arr[i]);\n                }\n            }\n\n            if (sum == target) {\n                result.push_back(subset);\n            }\n        }\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/bitmask-dp/#hamiltonian-path","title":"Hamiltonian Path","text":"<p>Problem: Find if there exists a path that visits each vertex exactly once in a directed graph.</p> <p>Sample Input:  - Graph: <code>{0: [1, 2], 1: [2], 2: [0, 3], 3: []}</code> - Start: <code>0</code></p> <p>Sample Output: <code>true</code> (Path: 0 \u2192 1 \u2192 2 \u2192 3)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nclass HamiltonianPath {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; graph;\n    vector&lt;vector&lt;int&gt;&gt; dp;\n    int n;\n\npublic:\n    bool hasHamiltonianPath(vector&lt;vector&lt;int&gt;&gt;&amp; adjList) {\n        n = adjList.size();\n        graph = adjList;\n        dp.assign(1 &lt;&lt; n, vector&lt;int&gt;(n, -1));\n\n        // Try starting from each vertex\n        for (int start = 0; start &lt; n; start++) {\n            if (hamiltonianPath(1 &lt;&lt; start, start)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\nprivate:\n    bool hamiltonianPath(int mask, int pos) {\n        // If all vertices visited\n        if (mask == (1 &lt;&lt; n) - 1) {\n            return true;\n        }\n\n        if (dp[mask][pos] != -1) {\n            return dp[mask][pos];\n        }\n\n        // Try visiting each unvisited neighbor\n        for (int next : graph[pos]) {\n            if (!(mask &amp; (1 &lt;&lt; next))) {\n                int newMask = mask | (1 &lt;&lt; next);\n                if (hamiltonianPath(newMask, next)) {\n                    return dp[mask][pos] = true;\n                }\n            }\n        }\n\n        return dp[mask][pos] = false;\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/bitmask-dp/#partition-into-equal-sum-subsets","title":"Partition into Equal Sum Subsets","text":"<p>Problem: Partition an array into k equal sum subsets using bitmask DP.</p> <p>Sample Input:  - <code>nums = [4, 3, 2, 3, 5, 2, 1]</code> - <code>k = 4</code></p> <p>Sample Output: <code>true</code> (Can partition into 4 subsets of sum 5 each)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass PartitionEqualSubsets {\npublic:\n    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) {\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        if (sum % k != 0) return false;\n\n        int target = sum / k;\n        int n = nums.size();\n\n        // Sort in descending order for better pruning\n        sort(nums.begin(), nums.end(), greater&lt;int&gt;());\n\n        vector&lt;int&gt; dp(1 &lt;&lt; n, -1);\n        dp[0] = 0;\n\n        for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {\n            if (dp[mask] == -1) continue;\n\n            for (int i = 0; i &lt; n; i++) {\n                if (!(mask &amp; (1 &lt;&lt; i))) {\n                    int newMask = mask | (1 &lt;&lt; i);\n                    int newSum = dp[mask] + nums[i];\n\n                    if (newSum &lt;= target) {\n                        dp[newMask] = (newSum == target) ? 0 : newSum;\n                    }\n                }\n            }\n        }\n\n        return dp[(1 &lt;&lt; n) - 1] == 0;\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/bitmask-dp/#optimization-techniques","title":"Optimization Techniques","text":""},{"location":"dynamic-programming/bitmask-dp/#state-space-reduction","title":"State Space Reduction","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass OptimizedBitmaskDP {\nprivate:\n    unordered_map&lt;int, int&gt; memo;\n\npublic:\n    int solveOptimized(vector&lt;int&gt;&amp; data) {\n        memo.clear();\n        return solve(0, 0);\n    }\n\nprivate:\n    int solve(int mask, int pos) {\n        if (pos &gt;= data.size()) {\n            return evaluateMask(mask);\n        }\n\n        if (memo.find(mask) != memo.end()) {\n            return memo[mask];\n        }\n\n        int result = 0;\n\n        // Option 1: Don't include current element\n        result = max(result, solve(mask, pos + 1));\n\n        // Option 2: Include current element\n        int newMask = mask | (1 &lt;&lt; pos);\n        result = max(result, solve(newMask, pos + 1));\n\n        return memo[mask] = result;\n    }\n\n    int evaluateMask(int mask) {\n        // Evaluate the current mask configuration\n        return __builtin_popcount(mask);\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/bitmask-dp/#iterative-bottom-up-approach","title":"Iterative Bottom-Up Approach","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass IterativeBitmaskDP {\npublic:\n    int solveIterative(vector&lt;int&gt;&amp; data) {\n        int n = data.size();\n        vector&lt;int&gt; dp(1 &lt;&lt; n, 0);\n\n        // Base case: empty set\n        dp[0] = 0;\n\n        // Fill DP table\n        for (int mask = 1; mask &lt; (1 &lt;&lt; n); mask++) {\n            for (int i = 0; i &lt; n; i++) {\n                if (mask &amp; (1 &lt;&lt; i)) {\n                    int prevMask = mask ^ (1 &lt;&lt; i);\n                    dp[mask] = max(dp[mask], dp[prevMask] + data[i]);\n                }\n            }\n        }\n\n        return dp[(1 &lt;&lt; n) - 1];\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/bitmask-dp/#use-cases","title":"Use Cases","text":""},{"location":"dynamic-programming/bitmask-dp/#optimization-problems","title":"Optimization Problems","text":"<ul> <li>Traveling Salesman: Finding shortest tour through all cities</li> <li>Assignment Problems: Optimal task-worker assignments</li> <li>Knapsack Variants: Subset selection with constraints</li> <li>Scheduling: Optimal task scheduling with dependencies</li> </ul>"},{"location":"dynamic-programming/bitmask-dp/#graph-problems","title":"Graph Problems","text":"<ul> <li>Hamiltonian Path/Cycle: Visiting each vertex exactly once</li> <li>Vertex Cover: Minimum set covering all edges</li> <li>Clique Problems: Finding maximum cliques</li> <li>Path Problems: Finding optimal paths with constraints</li> </ul>"},{"location":"dynamic-programming/bitmask-dp/#combinatorial-problems","title":"Combinatorial Problems","text":"<ul> <li>Subset Selection: Choosing optimal subsets</li> <li>Partition Problems: Dividing sets optimally</li> <li>Matching Problems: Optimal pairings</li> <li>Covering Problems: Covering sets with minimum subsets</li> </ul>"},{"location":"dynamic-programming/bitmask-dp/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"dynamic-programming/bitmask-dp/#time-complexity","title":"Time Complexity","text":"<ul> <li>Basic TSP: O(n\u00b2 \u00d7 2^n)</li> <li>Assignment Problem: O(n\u00b2 \u00d7 2^n)</li> <li>General Bitmask DP: O(2^n \u00d7 n) where n is the number of elements</li> <li>Space Complexity: O(2^n \u00d7 n) for memoization</li> </ul>"},{"location":"dynamic-programming/bitmask-dp/#when-to-use-bitmask-dp","title":"When to Use Bitmask DP","text":"<ul> <li>Problem involves selecting subsets from a set</li> <li>State can be represented as a bitmask</li> <li>Number of elements is small (typically n \u2264 20-25)</li> <li>Need to track which elements have been used/visited</li> <li>Problem has overlapping subproblems</li> </ul>"},{"location":"dynamic-programming/bitmask-dp/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Prune Impossible States: Skip states that can't lead to valid solutions</li> <li>Use Built-in Functions: <code>__builtin_popcount()</code>, <code>__builtin_clz()</code>, etc.</li> <li>Memory Optimization: Use 1D arrays when possible</li> <li>State Ordering: Process states in a specific order for better cache performance</li> <li>Early Termination: Stop when optimal solution is found</li> <li>Compression: Use smaller data types when possible</li> </ol>"},{"location":"dynamic-programming/dp-trees-graphs/","title":"DP on Trees and Graphs","text":"<p>Dynamic Programming on trees and graphs involves applying DP techniques to solve optimization problems on tree and graph structures. These problems often require considering different states and transitions based on the structure of the tree or graph.</p>"},{"location":"dynamic-programming/dp-trees-graphs/#tree-dp-concepts","title":"Tree DP Concepts","text":""},{"location":"dynamic-programming/dp-trees-graphs/#tree-traversal-for-dp","title":"Tree Traversal for DP","text":"<p>Trees have a natural recursive structure that makes them ideal for DP. The key is to process children before parents (post-order) or parents before children (pre-order).</p>"},{"location":"dynamic-programming/dp-trees-graphs/#common-tree-dp-patterns","title":"Common Tree DP Patterns","text":"<ol> <li>Rooted Tree DP: Solve for each subtree rooted at a node</li> <li>Rerooting DP: Efficiently compute answers for all possible roots</li> <li>Tree Decomposition: Break tree into smaller components</li> </ol>"},{"location":"dynamic-programming/dp-trees-graphs/#classic-tree-dp-problems","title":"Classic Tree DP Problems","text":""},{"location":"dynamic-programming/dp-trees-graphs/#maximum-path-sum-in-binary-tree","title":"Maximum Path Sum in Binary Tree","text":"<p>Problem: Find the maximum path sum in a binary tree where a path is any sequence of nodes from some starting node to any node in the tree along parent-child connections.</p> <p>Sample Input:  <pre><code>    1\n   / \\\n  2   3\n / \\\n4   5\n</code></pre></p> <p>Sample Output: <code>15</code> (Path: 4 \u2192 2 \u2192 5, sum = 4 + 2 + 5 = 11, but including 1 \u2192 3 gives 15)</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass MaxPathSum {\nprivate:\n    int maxSum;\n\npublic:\n    int maxPathSum(TreeNode* root) {\n        maxSum = INT_MIN;\n        maxPathDown(root);\n        return maxSum;\n    }\n\nprivate:\n    int maxPathDown(TreeNode* node) {\n        if (!node) return 0;\n\n        // Get maximum path sum from left and right subtrees\n        int left = max(0, maxPathDown(node-&gt;left));\n        int right = max(0, maxPathDown(node-&gt;right));\n\n        // Update global maximum (path through current node)\n        maxSum = max(maxSum, left + right + node-&gt;val);\n\n        // Return maximum path sum ending at current node\n        return max(left, right) + node-&gt;val;\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/dp-trees-graphs/#house-robber-iii-tree-version","title":"House Robber III (Tree Version)","text":"<p>Problem: Rob houses arranged in a binary tree where connected houses cannot be robbed simultaneously.</p> <p>Sample Input:  <pre><code>    3\n   / \\\n  2   3\n   \\   \\\n    3   1\n</code></pre></p> <p>Sample Output: <code>7</code> (Rob houses 3, 3, 1 = 3 + 3 + 1 = 7)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass HouseRobberTree {\npublic:\n    int rob(TreeNode* root) {\n        vector&lt;int&gt; result = robHelper(root);\n        return max(result[0], result[1]);\n    }\n\nprivate:\n    // Returns [rob_current, not_rob_current]\n    vector&lt;int&gt; robHelper(TreeNode* node) {\n        if (!node) {\n            return {0, 0};\n        }\n\n        vector&lt;int&gt; left = robHelper(node-&gt;left);\n        vector&lt;int&gt; right = robHelper(node-&gt;right);\n\n        // If we rob current node, we cannot rob children\n        int robCurrent = node-&gt;val + left[1] + right[1];\n\n        // If we don't rob current node, we can choose to rob or not rob children\n        int notRobCurrent = max(left[0], left[1]) + max(right[0], right[1]);\n\n        return {robCurrent, notRobCurrent};\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/dp-trees-graphs/#tree-diameter","title":"Tree Diameter","text":"<p>Problem: Find the diameter of a tree (longest path between any two nodes).</p> <p>Sample Input:  <pre><code>    1\n   / \\\n  2   3\n / \\\n4   5\n</code></pre></p> <p>Sample Output: <code>3</code> (Path: 4 \u2192 2 \u2192 1 \u2192 3, length = 3)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass TreeDiameter {\nprivate:\n    int diameter;\n\npublic:\n    int diameterOfBinaryTree(TreeNode* root) {\n        diameter = 0;\n        height(root);\n        return diameter;\n    }\n\nprivate:\n    int height(TreeNode* node) {\n        if (!node) return 0;\n\n        int leftHeight = height(node-&gt;left);\n        int rightHeight = height(node-&gt;right);\n\n        // Update diameter (path through current node)\n        diameter = max(diameter, leftHeight + rightHeight);\n\n        // Return height of subtree rooted at current node\n        return 1 + max(leftHeight, rightHeight);\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/dp-trees-graphs/#graph-dp-problems","title":"Graph DP Problems","text":""},{"location":"dynamic-programming/dp-trees-graphs/#shortest-path-in-dag","title":"Shortest Path in DAG","text":"<p>Problem: Find shortest paths from a source to all vertices in a Directed Acyclic Graph.</p> <p>Sample Input:  - Graph: <code>{0: [(1,5), (2,3)], 1: [(3,2)], 2: [(3,1)], 3: []}</code> - Source: <code>0</code></p> <p>Sample Output: <code>[0, 5, 3, 4]</code> (Shortest distances from 0 to all vertices)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass ShortestPathDAG {\npublic:\n    vector&lt;int&gt; shortestPath(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph, int source) {\n        int n = graph.size();\n        vector&lt;int&gt; dist(n, INT_MAX);\n        dist[source] = 0;\n\n        // Topological sort\n        vector&lt;int&gt; topo = topologicalSort(graph);\n\n        // Process vertices in topological order\n        for (int u : topo) {\n            if (dist[u] != INT_MAX) {\n                for (auto&amp; edge : graph[u]) {\n                    int v = edge.first;\n                    int weight = edge.second;\n                    dist[v] = min(dist[v], dist[u] + weight);\n                }\n            }\n        }\n\n        return dist;\n    }\n\nprivate:\n    vector&lt;int&gt; topologicalSort(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph) {\n        int n = graph.size();\n        vector&lt;int&gt; inDegree(n, 0);\n\n        // Calculate in-degrees\n        for (int u = 0; u &lt; n; u++) {\n            for (auto&amp; edge : graph[u]) {\n                inDegree[edge.first]++;\n            }\n        }\n\n        // Kahn's algorithm\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; n; i++) {\n            if (inDegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        vector&lt;int&gt; result;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            result.push_back(u);\n\n            for (auto&amp; edge : graph[u]) {\n                int v = edge.first;\n                inDegree[v]--;\n                if (inDegree[v] == 0) {\n                    q.push(v);\n                }\n            }\n        }\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/dp-trees-graphs/#longest-path-in-dag","title":"Longest Path in DAG","text":"<p>Problem: Find the longest path in a Directed Acyclic Graph.</p> <p>Sample Input:  - Graph: <code>{0: [1, 2], 1: [3], 2: [3], 3: []}</code></p> <p>Sample Output: <code>3</code> (Longest path length)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass LongestPathDAG {\nprivate:\n    vector&lt;int&gt; memo;\n    vector&lt;vector&lt;int&gt;&gt; graph;\n\npublic:\n    int longestPath(vector&lt;vector&lt;int&gt;&gt;&amp; adjList) {\n        int n = adjList.size();\n        graph = adjList;\n        memo.assign(n, -1);\n\n        int maxPath = 0;\n        for (int i = 0; i &lt; n; i++) {\n            maxPath = max(maxPath, dfs(i));\n        }\n\n        return maxPath;\n    }\n\nprivate:\n    int dfs(int node) {\n        if (memo[node] != -1) {\n            return memo[node];\n        }\n\n        int maxPath = 0;\n        for (int neighbor : graph[node]) {\n            maxPath = max(maxPath, 1 + dfs(neighbor));\n        }\n\n        return memo[node] = maxPath;\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/dp-trees-graphs/#advanced-tree-dp","title":"Advanced Tree DP","text":""},{"location":"dynamic-programming/dp-trees-graphs/#rerooting-dp","title":"Rerooting DP","text":"<p>Problem: For each node as root, find the sum of distances to all other nodes.</p> <p>Sample Input:  <pre><code>    0\n   / \\\n  1   2\n / \\\n3   4\n</code></pre></p> <p>Sample Output: <code>[6, 8, 12, 10, 10]</code> (Sum of distances for each node as root)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass RerootingDP {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; graph;\n    vector&lt;int&gt; subtreeSize;\n    vector&lt;int&gt; sumDistances;\n    int n;\n\npublic:\n    vector&lt;int&gt; sumOfDistancesInTree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n        this-&gt;n = n;\n        graph.resize(n);\n        subtreeSize.resize(n);\n        sumDistances.resize(n);\n\n        // Build adjacency list\n        for (auto&amp; edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n\n        // First DFS: calculate subtree sizes and distances from root\n        dfs1(0, -1);\n\n        // Second DFS: reroot and calculate distances for all nodes\n        dfs2(0, -1);\n\n        return sumDistances;\n    }\n\nprivate:\n    void dfs1(int node, int parent) {\n        subtreeSize[node] = 1;\n        sumDistances[node] = 0;\n\n        for (int child : graph[node]) {\n            if (child != parent) {\n                dfs1(child, node);\n                subtreeSize[node] += subtreeSize[child];\n                sumDistances[node] += sumDistances[child] + subtreeSize[child];\n            }\n        }\n    }\n\n    void dfs2(int node, int parent) {\n        for (int child : graph[node]) {\n            if (child != parent) {\n                // Reroot: move from node to child\n                sumDistances[child] = sumDistances[node] - subtreeSize[child] + (n - subtreeSize[child]);\n                dfs2(child, node);\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/dp-trees-graphs/#tree-decomposition-dp","title":"Tree Decomposition DP","text":"<p>Problem: Find maximum independent set in a tree.</p> <p>Sample Input:  <pre><code>    1\n   / \\\n  2   3\n / \\\n4   5\n</code></pre></p> <p>Sample Output: <code>3</code> (Maximum independent set: {1, 4, 5})</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass MaxIndependentSet {\npublic:\n    int maxIndependentSet(TreeNode* root) {\n        vector&lt;int&gt; result = maxIndependentSetHelper(root);\n        return max(result[0], result[1]);\n    }\n\nprivate:\n    // Returns [include_current, exclude_current]\n    vector&lt;int&gt; maxIndependentSetHelper(TreeNode* node) {\n        if (!node) {\n            return {0, 0};\n        }\n\n        vector&lt;int&gt; left = maxIndependentSetHelper(node-&gt;left);\n        vector&lt;int&gt; right = maxIndependentSetHelper(node-&gt;right);\n\n        // Include current node: cannot include children\n        int include = node-&gt;val + left[1] + right[1];\n\n        // Exclude current node: can choose to include or exclude children\n        int exclude = max(left[0], left[1]) + max(right[0], right[1]);\n\n        return {include, exclude};\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/dp-trees-graphs/#use-cases","title":"Use Cases","text":""},{"location":"dynamic-programming/dp-trees-graphs/#tree-problems","title":"Tree Problems","text":"<ul> <li>Path Problems: Finding optimal paths in trees</li> <li>Subtree Problems: Optimizing over subtrees</li> <li>Tree Decomposition: Breaking trees into components</li> <li>Rerooting: Computing answers for all possible roots</li> </ul>"},{"location":"dynamic-programming/dp-trees-graphs/#graph-problems","title":"Graph Problems","text":"<ul> <li>DAG Problems: Shortest/longest paths in DAGs</li> <li>Tree-like Graphs: Problems on graphs with tree structure</li> <li>Component Problems: Optimizing over connected components</li> <li>Flow Problems: Network flow optimizations</li> </ul>"},{"location":"dynamic-programming/dp-trees-graphs/#optimization-problems","title":"Optimization Problems","text":"<ul> <li>Resource Allocation: Optimal distribution in tree/graph structures</li> <li>Scheduling: Optimal scheduling with dependencies</li> <li>Matching: Optimal matching in bipartite graphs</li> <li>Covering: Minimum covering problems</li> </ul>"},{"location":"dynamic-programming/dp-trees-graphs/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"dynamic-programming/dp-trees-graphs/#time-complexity","title":"Time Complexity","text":"<ul> <li>Tree DP: O(n) where n is number of nodes</li> <li>Graph DP: O(V + E) for DAG problems</li> <li>Rerooting DP: O(n) for rerooting all nodes</li> <li>General Graph DP: Depends on problem structure</li> </ul>"},{"location":"dynamic-programming/dp-trees-graphs/#space-complexity","title":"Space Complexity","text":"<ul> <li>Tree DP: O(n) for recursion stack and memoization</li> <li>Graph DP: O(V) for memoization</li> <li>Rerooting DP: O(n) for storing results</li> </ul>"},{"location":"dynamic-programming/dp-trees-graphs/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Choose Root Wisely: Select root that simplifies the problem</li> <li>Use Post-order: Process children before parents in tree DP</li> <li>Memoization: Cache results for repeated subproblems</li> <li>State Compression: Use bitmasks for small state spaces</li> <li>Pruning: Skip impossible states early</li> <li>Iterative Approach: Use bottom-up when possible to avoid stack overflow</li> </ol>"},{"location":"dynamic-programming/top-down-bottom-up/","title":"Top-Down &amp; Bottom-Up Dynamic Programming","text":"<p>Dynamic Programming can be implemented using two main approaches: Top-Down (memoization) and Bottom-Up (tabulation). Each approach has its advantages and is suitable for different scenarios.</p>"},{"location":"dynamic-programming/top-down-bottom-up/#top-down-memoization","title":"Top-Down (Memoization)","text":"<p>Top-down DP starts with the main problem and recursively breaks it down into smaller subproblems, storing results to avoid recomputation.</p>"},{"location":"dynamic-programming/top-down-bottom-up/#implementation","title":"Implementation","text":"<p>Problem: Calculate Fibonacci numbers using top-down memoization to avoid redundant calculations.</p> <p>Sample Input: <code>n = 10</code></p> <p>Sample Output: <code>55</code> (10th Fibonacci number)</p> <pre><code>#include &lt;unordered_map&gt;\nusing namespace std;\n\nunordered_map&lt;int, long long&gt; memo;\n\nlong long fibonacciMemo(int n) {\n    if (memo.find(n) != memo.end()) {\n        return memo[n];\n    }\n\n    if (n &lt;= 1) {\n        return n;\n    }\n\n    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);\n    return memo[n];\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#example-longest-common-subsequence","title":"Example: Longest Common Subsequence","text":"<p>Problem: Find the length of the longest common subsequence between two strings using memoization.</p> <p>Sample Input:  - <code>s1 = \"ABCDGH\"</code> - <code>s2 = \"AEDFHR\"</code></p> <p>Sample Output: <code>3</code> (LCS: \"ADH\")</p> <pre><code>#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nunordered_map&lt;string, int&gt; memo;\n\nint lcsMemo(string s1, string s2, int i, int j) {\n    string key = to_string(i) + \",\" + to_string(j);\n    if (memo.find(key) != memo.end()) {\n        return memo[key];\n    }\n\n    if (i == 0 || j == 0) {\n        return 0;\n    }\n\n    int result;\n    if (s1[i - 1] == s2[j - 1]) {\n        result = 1 + lcsMemo(s1, s2, i - 1, j - 1);\n    } else {\n        result = max(lcsMemo(s1, s2, i - 1, j),\n                    lcsMemo(s1, s2, i, j - 1));\n    }\n\n    memo[key] = result;\n    return result;\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#bottom-up-tabulation","title":"Bottom-Up (Tabulation)","text":"<p>Bottom-up DP solves smaller subproblems first and builds up to the main problem using iterative approaches.</p>"},{"location":"dynamic-programming/top-down-bottom-up/#implementation_1","title":"Implementation","text":"<p>Problem: Calculate Fibonacci numbers using bottom-up tabulation approach.</p> <p>Sample Input: <code>n = 10</code></p> <p>Sample Output: <code>55</code> (10th Fibonacci number)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nlong long fibonacciTab(int n) {\n    if (n &lt;= 1) {\n        return n;\n    }\n\n    vector&lt;long long&gt; dp(n + 1, 0);\n    dp[1] = 1;\n\n    for (int i = 2; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    return dp[n];\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#example-longest-common-subsequence_1","title":"Example: Longest Common Subsequence","text":"<p>Problem: Find the length of the longest common subsequence between two strings using bottom-up tabulation.</p> <p>Sample Input:  - <code>s1 = \"ABCDGH\"</code> - <code>s2 = \"AEDFHR\"</code></p> <p>Sample Output: <code>3</code> (LCS: \"ADH\")</p> <pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint lcsTab(string s1, string s2) {\n    int m = s1.length(), n = s2.length();\n    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#comparison","title":"Comparison","text":"Aspect Top-Down Bottom-Up Approach Recursive Iterative Memory Only computes needed states Computes all states Stack Space Uses recursion stack No recursion Debugging Easier to trace More complex Space Optimization Harder to optimize Easier to optimize"},{"location":"dynamic-programming/top-down-bottom-up/#space-optimization","title":"Space Optimization","text":""},{"location":"dynamic-programming/top-down-bottom-up/#rolling-array-technique","title":"Rolling Array Technique","text":"<p>Problem: Calculate Fibonacci numbers using space-optimized bottom-up approach with rolling array.</p> <p>Sample Input: <code>n = 10</code></p> <p>Sample Output: <code>55</code> (10th Fibonacci number)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nlong long fibonacciOptimized(int n) {\n    if (n &lt;= 1) {\n        return n;\n    }\n\n    long long prev2 = 0, prev1 = 1;\n\n    for (int i = 2; i &lt;= n; i++) {\n        long long current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n\n    return prev1;\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#2d-to-1d-optimization","title":"2D to 1D Optimization","text":"<p>Problem: Find the length of the longest common subsequence using space-optimized 2D to 1D approach.</p> <p>Sample Input:  - <code>s1 = \"ABCDGH\"</code> - <code>s2 = \"AEDFHR\"</code></p> <p>Sample Output: <code>3</code> (LCS: \"ADH\")</p> <pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint lcsOptimized(string s1, string s2) {\n    int m = s1.length(), n = s2.length();\n    if (m &lt; n) {\n        swap(s1, s2);\n        swap(m, n);\n    }\n\n    vector&lt;int&gt; prev(n + 1, 0);\n    vector&lt;int&gt; curr(n + 1, 0);\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                curr[j] = 1 + prev[j - 1];\n            } else {\n                curr[j] = max(prev[j], curr[j - 1]);\n            }\n        }\n        prev = curr;\n    }\n\n    return prev[n];\n}\n</code></pre>"},{"location":"dynamic-programming/top-down-bottom-up/#when-to-use-each-approach","title":"When to Use Each Approach","text":""},{"location":"dynamic-programming/top-down-bottom-up/#use-top-down-when","title":"Use Top-Down When:","text":"<ul> <li>Problem has complex state transitions</li> <li>Not all states need to be computed</li> <li>Recursive structure is natural</li> <li>Memory is not a constraint</li> </ul>"},{"location":"dynamic-programming/top-down-bottom-up/#use-bottom-up-when","title":"Use Bottom-Up When:","text":"<ul> <li>Need to optimize space complexity</li> <li>All states must be computed</li> <li>Iterative approach is clearer</li> <li>Stack overflow is a concern</li> </ul>"},{"location":"dynamic-programming/top-down-bottom-up/#common-patterns","title":"Common Patterns","text":""},{"location":"dynamic-programming/top-down-bottom-up/#state-transition-patterns","title":"State Transition Patterns","text":"<ol> <li>Linear DP: States depend on previous states</li> <li>Interval DP: States represent intervals</li> <li>Tree DP: States represent tree nodes</li> <li>Bitmask DP: States use bit representations</li> </ol>"},{"location":"dynamic-programming/top-down-bottom-up/#optimization-techniques","title":"Optimization Techniques","text":"<ol> <li>Rolling Arrays: Reduce space from O(n) to O(1)</li> <li>Coordinate Compression: Reduce state space</li> <li>Monotonic Queue: Optimize transitions</li> <li>Convex Hull Trick: Optimize specific functions</li> </ol>"},{"location":"geometry/","title":"Geometry &amp; Spatial Modeling","text":"<p>Geometry and spatial modeling techniques deal with mathematical problems involving points, lines, polygons, and other geometric objects. These algorithms are crucial for computer graphics, computational geometry, and spatial data analysis.</p>"},{"location":"geometry/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link Sweep Line An algorithmic technique that processes geometric events in a sorted order, commonly used for line intersection problems and geometric computations. Sweep Line Convex Hull Finding the minimal convex polygon that contains all given points, with applications in optimization and geometric analysis. Convex Hull"},{"location":"geometry/#when-to-use-geometric-algorithms","title":"When to Use Geometric Algorithms","text":"<p>Geometric techniques are essential when: - Working with spatial data or coordinates - Solving problems involving points, lines, or polygons - Need to determine geometric relationships - Optimizing spatial queries or computations</p>"},{"location":"geometry/#common-geometric-problems","title":"Common Geometric Problems","text":"<ul> <li>Point-in-Polygon: Determining if a point lies inside a polygon</li> <li>Line Intersection: Finding intersection points between lines or line segments</li> <li>Convex Hull: Finding the smallest convex polygon containing all points</li> <li>Closest Pair: Finding the two closest points in a set</li> <li>Area Calculations: Computing areas of polygons or regions</li> <li>Spatial Indexing: Organizing geometric data for efficient queries</li> </ul>"},{"location":"geometry/#complexity-considerations","title":"Complexity Considerations","text":"<p>Many geometric algorithms have specific complexity characteristics: - Sweep line algorithms often achieve O(n log n) complexity - Convex hull algorithms typically run in O(n log n) time - Spatial data structures can provide O(log n) query times</p>"},{"location":"geometry/convex-hull/","title":"Convex Hull","text":"<p>The convex hull is the smallest convex polygon that contains all given points. It's a fundamental problem in computational geometry with applications in optimization, computer graphics, and spatial analysis.</p>"},{"location":"geometry/convex-hull/#what-is-a-convex-hull","title":"What is a Convex Hull?","text":"<p>A convex hull of a set of points is the smallest convex polygon that contains all the points. A polygon is convex if any line segment joining two points inside the polygon lies entirely within the polygon.</p>"},{"location":"geometry/convex-hull/#basic-concepts","title":"Basic Concepts","text":""},{"location":"geometry/convex-hull/#point-orientation","title":"Point Orientation","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x, double y) : x(x), y(y) {}\n\n    bool operator&lt;(const Point&amp; other) const {\n        if (x != other.x) return x &lt; other.x;\n        return y &lt; other.y;\n    }\n\n    bool operator==(const Point&amp; other) const {\n        return x == other.x &amp;&amp; y == other.y;\n    }\n};\n\n// Orientation of three points\n// Returns: 0 = collinear, 1 = counterclockwise, -1 = clockwise\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (abs(val) &lt; 1e-9) return 0;  // Collinear\n    return (val &gt; 0) ? 1 : -1;      // Counterclockwise or clockwise\n}\n\n// Distance between two points\ndouble distance(Point p, Point q) {\n    double dx = p.x - q.x;\n    double dy = p.y - q.y;\n    return sqrt(dx * dx + dy * dy);\n}\n</code></pre>"},{"location":"geometry/convex-hull/#graham-scan-algorithm","title":"Graham Scan Algorithm","text":"<p>Problem: Find the convex hull of a set of points using Graham Scan algorithm.</p> <p>Sample Input:  - Points: <code>[(0,0), (1,1), (2,2), (3,1), (2,0), (1,2)]</code></p> <p>Sample Output:  - Convex hull: <code>[(0,0), (2,0), (3,1), (2,2), (1,2)]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;stack&gt;\nusing namespace std;\n\nclass GrahamScan {\npublic:\n    vector&lt;Point&gt; convexHull(vector&lt;Point&gt;&amp; points) {\n        int n = points.size();\n        if (n &lt; 3) return points;\n\n        // Find the bottom-most point (and leftmost in case of tie)\n        int bottom = 0;\n        for (int i = 1; i &lt; n; i++) {\n            if (points[i].y &lt; points[bottom].y || \n                (points[i].y == points[bottom].y &amp;&amp; points[i].x &lt; points[bottom].x)) {\n                bottom = i;\n            }\n        }\n\n        // Swap bottom point with first point\n        swap(points[0], points[bottom]);\n\n        // Sort points by polar angle with respect to bottom point\n        Point p0 = points[0];\n        sort(points.begin() + 1, points.end(), [p0](const Point&amp; a, const Point&amp; b) {\n            int o = orientation(p0, a, b);\n            if (o == 0) {\n                return distance(p0, a) &lt; distance(p0, b);\n            }\n            return o == 1;\n        });\n\n        // Remove collinear points (keep only the farthest)\n        vector&lt;Point&gt; filtered;\n        filtered.push_back(points[0]);\n\n        for (int i = 1; i &lt; n; i++) {\n            while (i &lt; n - 1 &amp;&amp; orientation(p0, points[i], points[i + 1]) == 0) {\n                i++;\n            }\n            filtered.push_back(points[i]);\n        }\n\n        if (filtered.size() &lt; 3) return filtered;\n\n        // Build convex hull\n        stack&lt;Point&gt; hull;\n        hull.push(filtered[0]);\n        hull.push(filtered[1]);\n        hull.push(filtered[2]);\n\n        for (int i = 3; i &lt; filtered.size(); i++) {\n            while (hull.size() &gt; 1) {\n                Point top = hull.top();\n                hull.pop();\n                Point nextToTop = hull.top();\n\n                if (orientation(nextToTop, top, filtered[i]) == 1) {\n                    hull.push(top);\n                    break;\n                }\n            }\n            hull.push(filtered[i]);\n        }\n\n        // Convert stack to vector\n        vector&lt;Point&gt; result;\n        while (!hull.empty()) {\n            result.push_back(hull.top());\n            hull.pop();\n        }\n        reverse(result.begin(), result.end());\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"geometry/convex-hull/#andrews-monotone-chain-algorithm","title":"Andrew's Monotone Chain Algorithm","text":"<p>Problem: Find the convex hull using Andrew's Monotone Chain algorithm (alternative to Graham Scan).</p> <p>Sample Input:  - Points: <code>[(0,0), (1,1), (2,2), (3,1), (2,0), (1,2)]</code></p> <p>Sample Output:  - Convex hull: <code>[(0,0), (2,0), (3,1), (2,2), (1,2)]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass MonotoneChain {\npublic:\n    vector&lt;Point&gt; convexHull(vector&lt;Point&gt;&amp; points) {\n        int n = points.size();\n        if (n &lt; 3) return points;\n\n        // Sort points by x-coordinate (and y-coordinate as tiebreaker)\n        sort(points.begin(), points.end());\n\n        // Build lower hull\n        vector&lt;Point&gt; lower;\n        for (int i = 0; i &lt; n; i++) {\n            while (lower.size() &gt;= 2 &amp;&amp; \n                   orientation(lower[lower.size() - 2], lower[lower.size() - 1], points[i]) &lt;= 0) {\n                lower.pop_back();\n            }\n            lower.push_back(points[i]);\n        }\n\n        // Build upper hull\n        vector&lt;Point&gt; upper;\n        for (int i = n - 1; i &gt;= 0; i--) {\n            while (upper.size() &gt;= 2 &amp;&amp; \n                   orientation(upper[upper.size() - 2], upper[upper.size() - 1], points[i]) &lt;= 0) {\n                upper.pop_back();\n            }\n            upper.push_back(points[i]);\n        }\n\n        // Remove duplicate points\n        lower.pop_back();\n        upper.pop_back();\n\n        // Combine lower and upper hulls\n        lower.insert(lower.end(), upper.begin(), upper.end());\n\n        return lower;\n    }\n};\n</code></pre>"},{"location":"geometry/convex-hull/#advanced-applications","title":"Advanced Applications","text":""},{"location":"geometry/convex-hull/#convex-hull-of-circles","title":"Convex Hull of Circles","text":"<p>Problem: Find the convex hull of circles (approximated as polygons).</p> <p>Sample Input:  - Circles: <code>[(0,0,1), (2,0,1), (1,2,1)]</code> (center_x, center_y, radius)</p> <p>Sample Output:  - Convex hull vertices of the union of circles</p> <pre><code>#include &lt;vector&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nstruct Circle {\n    double x, y, radius;\n    Circle(double x, double y, double r) : x(x), y(y), radius(r) {}\n};\n\nclass CircleConvexHull {\npublic:\n    vector&lt;Point&gt; convexHull(vector&lt;Circle&gt;&amp; circles) {\n        vector&lt;Point&gt; points;\n\n        // Generate points on circle boundaries\n        for (const Circle&amp; circle : circles) {\n            int numPoints = 16; // Number of points per circle\n            for (int i = 0; i &lt; numPoints; i++) {\n                double angle = 2 * M_PI * i / numPoints;\n                double x = circle.x + circle.radius * cos(angle);\n                double y = circle.y + circle.radius * sin(angle);\n                points.push_back(Point(x, y));\n            }\n        }\n\n        // Find convex hull of all points\n        MonotoneChain chain;\n        return chain.convexHull(points);\n    }\n};\n</code></pre>"},{"location":"geometry/convex-hull/#convex-hull-with-collinear-points","title":"Convex Hull with Collinear Points","text":"<p>Problem: Handle collinear points properly in convex hull computation.</p> <p>Sample Input:  - Points: <code>[(0,0), (1,1), (2,2), (3,3), (1,0), (2,0)]</code></p> <p>Sample Output:  - Convex hull: <code>[(0,0), (3,3), (2,0), (1,0)]</code></p> <pre><code>class ConvexHullWithCollinear {\npublic:\n    vector&lt;Point&gt; convexHull(vector&lt;Point&gt;&amp; points) {\n        int n = points.size();\n        if (n &lt; 3) return points;\n\n        // Find bottom-most point\n        int bottom = 0;\n        for (int i = 1; i &lt; n; i++) {\n            if (points[i].y &lt; points[bottom].y || \n                (points[i].y == points[bottom].y &amp;&amp; points[i].x &lt; points[bottom].x)) {\n                bottom = i;\n            }\n        }\n\n        swap(points[0], points[bottom]);\n        Point p0 = points[0];\n\n        // Sort by polar angle\n        sort(points.begin() + 1, points.end(), [p0](const Point&amp; a, const Point&amp; b) {\n            int o = orientation(p0, a, b);\n            if (o == 0) {\n                return distance(p0, a) &lt; distance(p0, b);\n            }\n            return o == 1;\n        });\n\n        // Remove collinear points (keep only the farthest)\n        vector&lt;Point&gt; filtered;\n        filtered.push_back(points[0]);\n\n        for (int i = 1; i &lt; n; i++) {\n            while (i &lt; n - 1 &amp;&amp; orientation(p0, points[i], points[i + 1]) == 0) {\n                i++;\n            }\n            filtered.push_back(points[i]);\n        }\n\n        if (filtered.size() &lt; 3) return filtered;\n\n        // Build hull\n        vector&lt;Point&gt; hull;\n        hull.push_back(filtered[0]);\n        hull.push_back(filtered[1]);\n\n        for (int i = 2; i &lt; filtered.size(); i++) {\n            while (hull.size() &gt; 1 &amp;&amp; \n                   orientation(hull[hull.size() - 2], hull[hull.size() - 1], filtered[i]) != 1) {\n                hull.pop_back();\n            }\n            hull.push_back(filtered[i]);\n        }\n\n        return hull;\n    }\n};\n</code></pre>"},{"location":"geometry/convex-hull/#convex-hull-area-and-perimeter","title":"Convex Hull Area and Perimeter","text":"<p>Problem: Calculate the area and perimeter of a convex hull.</p> <p>Sample Input:  - Points: <code>[(0,0), (2,0), (2,2), (0,2)]</code></p> <p>Sample Output:  - Area: <code>4</code> - Perimeter: <code>8</code></p> <pre><code>class ConvexHullMetrics {\npublic:\n    double calculateArea(vector&lt;Point&gt;&amp; hull) {\n        if (hull.size() &lt; 3) return 0;\n\n        double area = 0;\n        int n = hull.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            int j = (i + 1) % n;\n            area += hull[i].x * hull[j].y - hull[j].x * hull[i].y;\n        }\n\n        return abs(area) / 2.0;\n    }\n\n    double calculatePerimeter(vector&lt;Point&gt;&amp; hull) {\n        if (hull.size() &lt; 2) return 0;\n\n        double perimeter = 0;\n        int n = hull.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            int j = (i + 1) % n;\n            perimeter += distance(hull[i], hull[j]);\n        }\n\n        return perimeter;\n    }\n};\n</code></pre>"},{"location":"geometry/convex-hull/#use-cases","title":"Use Cases","text":""},{"location":"geometry/convex-hull/#computational-geometry","title":"Computational Geometry","text":"<ul> <li>Point Set Analysis: Analyzing properties of point sets</li> <li>Polygon Operations: Intersection, union, and difference of polygons</li> <li>Voronoi Diagrams: Building Voronoi diagrams</li> <li>Delaunay Triangulation: Creating Delaunay triangulations</li> </ul>"},{"location":"geometry/convex-hull/#computer-graphics","title":"Computer Graphics","text":"<ul> <li>Collision Detection: Efficient collision detection between objects</li> <li>Rendering: Optimizing rendering of complex shapes</li> <li>Shape Analysis: Analyzing and comparing shapes</li> <li>Mesh Generation: Generating meshes for 3D objects</li> </ul>"},{"location":"geometry/convex-hull/#optimization","title":"Optimization","text":"<ul> <li>Linear Programming: Finding feasible regions</li> <li>Resource Allocation: Optimizing resource distribution</li> <li>Facility Location: Finding optimal facility locations</li> <li>Path Planning: Planning optimal paths around obstacles</li> </ul>"},{"location":"geometry/convex-hull/#spatial-analysis","title":"Spatial Analysis","text":"<ul> <li>GIS Applications: Geographic information systems</li> <li>Map Analysis: Analyzing geographic data</li> <li>Terrain Analysis: Analyzing terrain features</li> <li>Urban Planning: Planning urban development</li> </ul>"},{"location":"geometry/convex-hull/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"geometry/convex-hull/#time-complexity","title":"Time Complexity","text":"<ul> <li>Graham Scan: O(n log n) due to sorting</li> <li>Monotone Chain: O(n log n) due to sorting</li> <li>Gift Wrapping: O(nh) where h is number of hull points</li> <li>Quick Hull: O(n log n) average case, O(n\u00b2) worst case</li> </ul>"},{"location":"geometry/convex-hull/#space-complexity","title":"Space Complexity","text":"<ul> <li>All Algorithms: O(n) for storing points and hull</li> <li>Graham Scan: O(n) for stack</li> <li>Monotone Chain: O(n) for lower and upper hulls</li> </ul>"},{"location":"geometry/convex-hull/#algorithm-comparison","title":"Algorithm Comparison","text":"Algorithm Time Complexity Space Complexity Advantages Disadvantages Graham Scan O(n log n) O(n) Simple, stable Requires sorting Monotone Chain O(n log n) O(n) No trigonometric functions More complex Gift Wrapping O(nh) O(n) Simple, no sorting Slow for many points Quick Hull O(n log n) avg O(n) Fast average case O(n\u00b2) worst case"},{"location":"geometry/convex-hull/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Choose Right Algorithm: Use Graham Scan for general cases, Monotone Chain for simplicity</li> <li>Handle Collinear Points: Remove or handle collinear points properly</li> <li>Coordinate Precision: Use appropriate precision for floating-point calculations</li> <li>Early Termination: Stop when hull is complete</li> <li>Memory Management: Use appropriate data structures for your use case</li> <li>Parallel Processing: Process independent parts in parallel when possible</li> </ol>"},{"location":"geometry/sweep-line/","title":"Sweep Line Algorithm","text":"<p>The sweep line algorithm is a powerful technique in computational geometry that processes geometric events in a sorted order. It's particularly useful for solving problems involving line intersections, point-in-polygon queries, and other geometric computations.</p>"},{"location":"geometry/sweep-line/#how-it-works","title":"How It Works","text":"<p>The sweep line algorithm works by: 1. Sort Events: Sort all geometric events (points, line endpoints, etc.) by their x-coordinate 2. Sweep: Move a vertical line from left to right across the plane 3. Process Events: At each event, update the active set and check for intersections or other conditions 4. Maintain State: Keep track of the current state as the sweep line moves</p>"},{"location":"geometry/sweep-line/#basic-concepts","title":"Basic Concepts","text":""},{"location":"geometry/sweep-line/#event-processing","title":"Event Processing","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x, double y) : x(x), y(y) {}\n};\n\nstruct Event {\n    double x;\n    int type; // 0: start, 1: end, 2: intersection\n    int id;\n    Event(double x, int type, int id) : x(x), type(type), id(id) {}\n\n    bool operator&lt;(const Event&amp; other) const {\n        if (x != other.x) return x &lt; other.x;\n        return type &lt; other.type;\n    }\n};\n</code></pre>"},{"location":"geometry/sweep-line/#classic-problems","title":"Classic Problems","text":""},{"location":"geometry/sweep-line/#line-segment-intersection","title":"Line Segment Intersection","text":"<p>Problem: Find all intersection points between line segments using sweep line algorithm.</p> <p>Sample Input:  - Segments: <code>[(0,0,2,2), (1,1,3,1), (0,2,2,0)]</code></p> <p>Sample Output:  - Intersections: <code>[(1,1), (1.5,1.5)]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Segment {\n    Point start, end;\n    int id;\n    Segment(Point s, Point e, int id) : start(s), end(e), id(id) {}\n};\n\nclass LineSegmentIntersection {\nprivate:\n    vector&lt;Segment&gt; segments;\n    set&lt;Segment*&gt; activeSegments;\n    vector&lt;Point&gt; intersections;\n\npublic:\n    vector&lt;Point&gt; findIntersections(vector&lt;Segment&gt;&amp; segs) {\n        segments = segs;\n        intersections.clear();\n\n        vector&lt;Event&gt; events;\n\n        // Create events for segment endpoints\n        for (int i = 0; i &lt; segments.size(); i++) {\n            if (segments[i].start.x &lt; segments[i].end.x) {\n                events.push_back(Event(segments[i].start.x, 0, i));\n                events.push_back(Event(segments[i].end.x, 1, i));\n            } else {\n                events.push_back(Event(segments[i].end.x, 0, i));\n                events.push_back(Event(segments[i].start.x, 1, i));\n            }\n        }\n\n        sort(events.begin(), events.end());\n\n        for (const Event&amp; event : events) {\n            if (event.type == 0) {\n                // Start of segment\n                handleSegmentStart(event.id);\n            } else {\n                // End of segment\n                handleSegmentEnd(event.id);\n            }\n        }\n\n        return intersections;\n    }\n\nprivate:\n    void handleSegmentStart(int segId) {\n        Segment* seg = &amp;segments[segId];\n\n        // Check intersections with active segments\n        for (Segment* active : activeSegments) {\n            Point intersection = findIntersection(*seg, *active);\n            if (isValidIntersection(intersection)) {\n                intersections.push_back(intersection);\n            }\n        }\n\n        activeSegments.insert(seg);\n    }\n\n    void handleSegmentEnd(int segId) {\n        Segment* seg = &amp;segments[segId];\n        activeSegments.erase(seg);\n    }\n\n    Point findIntersection(const Segment&amp; s1, const Segment&amp; s2) {\n        // Implementation of line intersection\n        // Returns intersection point or invalid point\n        return Point(0, 0); // Placeholder\n    }\n\n    bool isValidIntersection(const Point&amp; p) {\n        // Check if intersection is valid\n        return true; // Placeholder\n    }\n};\n</code></pre>"},{"location":"geometry/sweep-line/#rectangle-union-area","title":"Rectangle Union Area","text":"<p>Problem: Find the total area covered by a union of rectangles using sweep line.</p> <p>Sample Input:  - Rectangles: <code>[(0,0,2,2), (1,1,3,3), (2,0,4,1)]</code> (x1, y1, x2, y2)</p> <p>Sample Output: <code>8</code> (Total area covered by union)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Rectangle {\n    double x1, y1, x2, y2;\n    Rectangle(double x1, double y1, double x2, double y2) \n        : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nclass RectangleUnion {\nprivate:\n    struct Event {\n        double x;\n        int type; // 0: start, 1: end\n        double y1, y2;\n        Event(double x, int type, double y1, double y2) \n            : x(x), type(type), y1(y1), y2(y2) {}\n\n        bool operator&lt;(const Event&amp; other) const {\n            return x &lt; other.x;\n        }\n    };\n\npublic:\n    double unionArea(vector&lt;Rectangle&gt;&amp; rectangles) {\n        vector&lt;Event&gt; events;\n\n        // Create events for rectangle edges\n        for (const Rectangle&amp; rect : rectangles) {\n            events.push_back(Event(rect.x1, 0, rect.y1, rect.y2));\n            events.push_back(Event(rect.x2, 1, rect.y1, rect.y2));\n        }\n\n        sort(events.begin(), events.end());\n\n        map&lt;double, int&gt; activeIntervals; // y-coordinate -&gt; count\n        double totalArea = 0;\n        double prevX = 0;\n\n        for (const Event&amp; event : events) {\n            if (!activeIntervals.empty()) {\n                double width = event.x - prevX;\n                double height = getActiveHeight(activeIntervals);\n                totalArea += width * height;\n            }\n\n            if (event.type == 0) {\n                // Start of rectangle\n                activeIntervals[event.y1]++;\n                activeIntervals[event.y2]--;\n            } else {\n                // End of rectangle\n                activeIntervals[event.y1]--;\n                activeIntervals[event.y2]++;\n            }\n\n            prevX = event.x;\n        }\n\n        return totalArea;\n    }\n\nprivate:\n    double getActiveHeight(const map&lt;double, int&gt;&amp; intervals) {\n        double height = 0;\n        int count = 0;\n        double prevY = 0;\n\n        for (const auto&amp; interval : intervals) {\n            if (count &gt; 0) {\n                height += interval.first - prevY;\n            }\n            count += interval.second;\n            prevY = interval.first;\n        }\n\n        return height;\n    }\n};\n</code></pre>"},{"location":"geometry/sweep-line/#advanced-applications","title":"Advanced Applications","text":""},{"location":"geometry/sweep-line/#closest-pair-of-points","title":"Closest Pair of Points","text":"<p>Problem: Find the closest pair of points in a 2D plane using sweep line.</p> <p>Sample Input:  - Points: <code>[(0,0), (1,1), (2,2), (3,3), (4,4)]</code></p> <p>Sample Output:  - Closest pair: <code>[(0,0), (1,1)]</code> - Distance: <code>1.414</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nclass ClosestPair {\npublic:\n    pair&lt;Point, Point&gt; findClosestPair(vector&lt;Point&gt;&amp; points) {\n        if (points.size() &lt; 2) return {Point(0,0), Point(0,0)};\n\n        // Sort points by x-coordinate\n        sort(points.begin(), points.end(), [](const Point&amp; a, const Point&amp; b) {\n            return a.x &lt; b.x;\n        });\n\n        double minDist = INFINITY;\n        Point p1, p2;\n\n        set&lt;Point&gt; activePoints;\n\n        for (int i = 0; i &lt; points.size(); i++) {\n            Point current = points[i];\n\n            // Remove points that are too far away\n            auto it = activePoints.begin();\n            while (it != activePoints.end()) {\n                if (current.x - it-&gt;x &gt; minDist) {\n                    it = activePoints.erase(it);\n                } else {\n                    break;\n                }\n            }\n\n            // Check points in the active set\n            for (const Point&amp; point : activePoints) {\n                double dist = distance(current, point);\n                if (dist &lt; minDist) {\n                    minDist = dist;\n                    p1 = current;\n                    p2 = point;\n                }\n            }\n\n            activePoints.insert(current);\n        }\n\n        return {p1, p2};\n    }\n\nprivate:\n    double distance(const Point&amp; a, const Point&amp; b) {\n        double dx = a.x - b.x;\n        double dy = a.y - b.y;\n        return sqrt(dx * dx + dy * dy);\n    }\n};\n</code></pre>"},{"location":"geometry/sweep-line/#point-in-polygon-query","title":"Point-in-Polygon Query","text":"<p>Problem: Determine if a point lies inside a polygon using sweep line.</p> <p>Sample Input:  - Polygon: <code>[(0,0), (2,0), (2,2), (0,2)]</code> (square) - Point: <code>(1,1)</code></p> <p>Sample Output: <code>true</code> (Point is inside the polygon)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass PointInPolygon {\npublic:\n    bool isInsidePolygon(vector&lt;Point&gt;&amp; polygon, Point query) {\n        int n = polygon.size();\n        bool inside = false;\n\n        for (int i = 0; i &lt; n; i++) {\n            Point p1 = polygon[i];\n            Point p2 = polygon[(i + 1) % n];\n\n            if (rayIntersectsSegment(query, p1, p2)) {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\nprivate:\n    bool rayIntersectsSegment(Point p, Point a, Point b) {\n        if (a.y &gt; b.y) swap(a, b);\n\n        if (p.y &lt; a.y || p.y &gt;= b.y) return false;\n        if (p.x &gt;= max(a.x, b.x)) return false;\n        if (p.x &lt; min(a.x, b.x)) return true;\n\n        double intersectionX = a.x + (p.y - a.y) * (b.x - a.x) / (b.y - a.y);\n        return p.x &lt; intersectionX;\n    }\n};\n</code></pre>"},{"location":"geometry/sweep-line/#skyline-problem","title":"Skyline Problem","text":"<p>Problem: Find the skyline of a city given building heights using sweep line.</p> <p>Sample Input:  - Buildings: <code>[(1,3,3), (2,4,4), (5,2,6), (6,1,7)]</code> (left, height, right)</p> <p>Sample Output:  - Skyline: <code>[(1,3), (2,4), (4,0), (5,2), (6,1), (7,0)]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Building {\n    int left, height, right;\n    Building(int l, int h, int r) : left(l), height(h), right(r) {}\n};\n\nclass Skyline {\npublic:\n    vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;Building&gt;&amp; buildings) {\n        vector&lt;pair&lt;int, int&gt;&gt; result;\n\n        // Create events for building edges\n        vector&lt;pair&lt;int, int&gt;&gt; events; // x, height (negative for end)\n\n        for (const Building&amp; building : buildings) {\n            events.push_back({building.left, building.height});\n            events.push_back({building.right, -building.height});\n        }\n\n        sort(events.begin(), events.end());\n\n        map&lt;int, int&gt; activeHeights; // height -&gt; count\n        int prevHeight = 0;\n\n        for (const auto&amp; event : events) {\n            int x = event.first;\n            int height = event.second;\n\n            if (height &gt; 0) {\n                // Start of building\n                activeHeights[height]++;\n            } else {\n                // End of building\n                activeHeights[-height]--;\n                if (activeHeights[-height] == 0) {\n                    activeHeights.erase(-height);\n                }\n            }\n\n            int currentHeight = activeHeights.empty() ? 0 : activeHeights.rbegin()-&gt;first;\n\n            if (currentHeight != prevHeight) {\n                result.push_back({x, currentHeight});\n                prevHeight = currentHeight;\n            }\n        }\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"geometry/sweep-line/#use-cases","title":"Use Cases","text":""},{"location":"geometry/sweep-line/#computational-geometry","title":"Computational Geometry","text":"<ul> <li>Line Intersection: Finding intersection points between line segments</li> <li>Point-in-Polygon: Determining if points lie inside polygons</li> <li>Closest Pair: Finding the closest pair of points</li> <li>Area Calculations: Computing areas of complex shapes</li> </ul>"},{"location":"geometry/sweep-line/#computer-graphics","title":"Computer Graphics","text":"<ul> <li>Rendering: Efficient rendering of geometric objects</li> <li>Collision Detection: Detecting collisions between objects</li> <li>Visibility: Determining what's visible from a viewpoint</li> <li>Clipping: Clipping objects to viewport boundaries</li> </ul>"},{"location":"geometry/sweep-line/#spatial-data-analysis","title":"Spatial Data Analysis","text":"<ul> <li>Range Queries: Finding objects in a given range</li> <li>Nearest Neighbor: Finding closest objects</li> <li>Spatial Indexing: Organizing spatial data efficiently</li> <li>Map Overlay: Combining multiple map layers</li> </ul>"},{"location":"geometry/sweep-line/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>Geometric Problems: Solving geometry-based problems</li> <li>Optimization: Finding optimal geometric configurations</li> <li>Enumeration: Counting geometric objects</li> <li>Transformation: Applying geometric transformations</li> </ul>"},{"location":"geometry/sweep-line/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"geometry/sweep-line/#time-complexity","title":"Time Complexity","text":"<ul> <li>Line Segment Intersection: O(n log n + k) where k is number of intersections</li> <li>Rectangle Union: O(n log n)</li> <li>Closest Pair: O(n log n)</li> <li>Point-in-Polygon: O(n) for single query</li> <li>Skyline: O(n log n)</li> </ul>"},{"location":"geometry/sweep-line/#space-complexity","title":"Space Complexity","text":"<ul> <li>Most Algorithms: O(n) for storing events and active sets</li> <li>Closest Pair: O(n) for active point set</li> <li>Rectangle Union: O(n) for active intervals</li> </ul>"},{"location":"geometry/sweep-line/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Event Sorting: Sort events efficiently by x-coordinate</li> <li>Active Set Management: Use appropriate data structures (set, map)</li> <li>Early Termination: Stop when no more intersections are possible</li> <li>Coordinate Compression: Compress coordinates for better performance</li> <li>Spatial Indexing: Use spatial data structures for large datasets</li> <li>Parallel Processing: Process independent events in parallel</li> </ol>"},{"location":"graph-modeling/","title":"Graph &amp; Network Modeling","text":"<p>Graph and network modeling techniques are essential for solving problems involving relationships, connections, and hierarchical structures. These algorithms form the foundation for many real-world applications including social networks, transportation systems, and computer networks.</p>"},{"location":"graph-modeling/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link DFS / BFS Depth-First Search and Breadth-First Search are fundamental graph traversal algorithms with different characteristics and use cases. DFS / BFS Dijkstra / Bellman-Ford Shortest path algorithms for finding optimal routes in weighted graphs, each suitable for different graph types and constraints. Dijkstra / Bellman-Ford Union-Find A data structure and algorithm for efficiently managing disjoint sets, commonly used for connectivity problems and minimum spanning trees. Union-Find"},{"location":"graph-modeling/#when-to-use-graph-algorithms","title":"When to Use Graph Algorithms","text":"<p>Graph techniques are essential when: - Data has inherent relationships or connections - You need to find paths, cycles, or connectivity - Working with hierarchical or network structures - Solving optimization problems on connected components</p>"},{"location":"graph-modeling/#common-graph-problems","title":"Common Graph Problems","text":"<ul> <li>Shortest Path: Finding the minimum cost path between nodes</li> <li>Connectivity: Determining if nodes are reachable from each other</li> <li>Cycle Detection: Identifying cycles in directed or undirected graphs</li> <li>Topological Sorting: Ordering nodes based on dependencies</li> <li>Minimum Spanning Tree: Finding the minimum cost tree connecting all nodes</li> </ul>"},{"location":"graph-modeling/dfs-bfs/","title":"DFS / BFS","text":"<p>Depth-First Search (DFS) and Breadth-First Search (BFS) are fundamental graph traversal algorithms. They differ in their exploration strategy and are suited for different types of problems.</p>"},{"location":"graph-modeling/dfs-bfs/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":"<p>DFS explores as far as possible along each branch before backtracking. It uses a stack (either explicit or implicit through recursion).</p>"},{"location":"graph-modeling/dfs-bfs/#recursive-implementation","title":"Recursive Implementation","text":"<p>Problem: Traverse a graph using depth-first search recursively.</p> <p>Sample Input:  - Graph: <code>{0: [1, 2], 1: [3], 2: [4], 3: [], 4: []}</code> - Start node: <code>0</code></p> <p>Sample Output: <code>0 1 3 2 4</code> (DFS traversal order)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvoid dfsRecursive(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, unordered_set&lt;int&gt;&amp; visited) {\n    visited.insert(start);\n    cout &lt;&lt; start &lt;&lt; \" \";  // Process node\n\n    for (int neighbor : graph[start]) {\n        if (visited.find(neighbor) == visited.end()) {\n            dfsRecursive(graph, neighbor, visited);\n        }\n    }\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#iterative-implementation","title":"Iterative Implementation","text":"<p>Problem: Traverse a graph using depth-first search iteratively with a stack.</p> <p>Sample Input:  - Graph: <code>{0: [1, 2], 1: [3], 2: [4], 3: [], 4: []}</code> - Start node: <code>0</code></p> <p>Sample Output: <code>0 2 4 1 3</code> (DFS traversal order)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvoid dfsIterative(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start) {\n    unordered_set&lt;int&gt; visited;\n    stack&lt;int&gt; stk;\n    stk.push(start);\n\n    while (!stk.empty()) {\n        int node = stk.top();\n        stk.pop();\n\n        if (visited.find(node) == visited.end()) {\n            visited.insert(node);\n            cout &lt;&lt; node &lt;&lt; \" \";  // Process node\n\n            // Add neighbors to stack (reverse order for same traversal)\n            for (int i = graph[node].size() - 1; i &gt;= 0; i--) {\n                int neighbor = graph[node][i];\n                if (visited.find(neighbor) == visited.end()) {\n                    stk.push(neighbor);\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":"<p>BFS explores all nodes at the current depth before moving to the next level. It uses a queue to maintain the order of exploration.</p>"},{"location":"graph-modeling/dfs-bfs/#implementation","title":"Implementation","text":"<p>Problem: Traverse a graph using breadth-first search to explore level by level.</p> <p>Sample Input:  - Graph: <code>{0: [1, 2], 1: [3], 2: [4], 3: [], 4: []}</code> - Start node: <code>0</code></p> <p>Sample Output: <code>0 1 2 3 4</code> (BFS traversal order)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvoid bfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start) {\n    unordered_set&lt;int&gt; visited;\n    queue&lt;int&gt; q;\n    q.push(start);\n    visited.insert(start);\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        cout &lt;&lt; node &lt;&lt; \" \";  // Process node\n\n        for (int neighbor : graph[node]) {\n            if (visited.find(neighbor) == visited.end()) {\n                visited.insert(neighbor);\n                q.push(neighbor);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#applications","title":"Applications","text":""},{"location":"graph-modeling/dfs-bfs/#dfs-applications","title":"DFS Applications","text":"<ul> <li>Path Finding: Finding any path between two nodes</li> <li>Cycle Detection: Detecting cycles in directed/undirected graphs</li> <li>Topological Sorting: Ordering nodes based on dependencies</li> <li>Connected Components: Finding all connected components</li> <li>Maze Solving: Exploring maze paths</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#bfs-applications","title":"BFS Applications","text":"<ul> <li>Shortest Path: Finding shortest path in unweighted graphs</li> <li>Level Order Traversal: Processing nodes level by level</li> <li>Minimum Spanning Tree: Prim's algorithm</li> <li>Social Network Analysis: Finding degrees of separation</li> <li>Web Crawling: Exploring web pages systematically</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#example-finding-shortest-path","title":"Example: Finding Shortest Path","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvector&lt;int&gt; shortestPathBFS(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int end) {\n    if (start == end) {\n        return {start};\n    }\n\n    unordered_set&lt;int&gt; visited;\n    queue&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt; q;\n    q.push({start, {start}});\n    visited.insert(start);\n\n    while (!q.empty()) {\n        auto [node, path] = q.front();\n        q.pop();\n\n        for (int neighbor : graph[node]) {\n            if (neighbor == end) {\n                path.push_back(neighbor);\n                return path;\n            }\n\n            if (visited.find(neighbor) == visited.end()) {\n                visited.insert(neighbor);\n                vector&lt;int&gt; newPath = path;\n                newPath.push_back(neighbor);\n                q.push({neighbor, newPath});\n            }\n        }\n    }\n\n    return {};  // No path found\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#example-cycle-detection","title":"Example: Cycle Detection","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nbool hasCycleDFS(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {\n    unordered_set&lt;int&gt; visited;\n    unordered_set&lt;int&gt; recStack;\n\n    function&lt;bool(int)&gt; dfs = [&amp;](int node) -&gt; bool {\n        visited.insert(node);\n        recStack.insert(node);\n\n        for (int neighbor : graph[node]) {\n            if (visited.find(neighbor) == visited.end()) {\n                if (dfs(neighbor)) {\n                    return true;\n                }\n            } else if (recStack.find(neighbor) != recStack.end()) {\n                return true;\n            }\n        }\n\n        recStack.erase(node);\n        return false;\n    };\n\n    for (int node = 0; node &lt; graph.size(); node++) {\n        if (visited.find(node) == visited.end()) {\n            if (dfs(node)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"graph-modeling/dfs-bfs/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"graph-modeling/dfs-bfs/#time-complexity","title":"Time Complexity","text":"<ul> <li>DFS: O(V + E) where V is vertices, E is edges</li> <li>BFS: O(V + E) where V is vertices, E is edges</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#space-complexity","title":"Space Complexity","text":"<ul> <li>DFS: O(V) for recursion stack or explicit stack</li> <li>BFS: O(V) for queue and visited set</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#when-to-use-each","title":"When to Use Each","text":""},{"location":"graph-modeling/dfs-bfs/#use-dfs-when","title":"Use DFS When:","text":"<ul> <li>Need to explore all possible paths</li> <li>Memory is limited (uses less memory than BFS)</li> <li>Looking for any solution (not necessarily shortest)</li> <li>Working with tree-like structures</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#use-bfs-when","title":"Use BFS When:","text":"<ul> <li>Need shortest path in unweighted graphs</li> <li>Want to explore nodes level by level</li> <li>Need to find minimum distance</li> <li>Working with social networks or similar structures</li> </ul>"},{"location":"graph-modeling/dfs-bfs/#advanced-variations","title":"Advanced Variations","text":""},{"location":"graph-modeling/dfs-bfs/#bidirectional-bfs","title":"Bidirectional BFS","text":"<pre><code>def bidirectional_bfs(graph, start, end):\n    if start == end:\n        return [start]\n\n    visited_start = {start: [start]}\n    visited_end = {end: [end]}\n    queue_start = deque([start])\n    queue_end = deque([end])\n\n    while queue_start and queue_end:\n        # Expand from start\n        node = queue_start.popleft()\n        for neighbor in graph[node]:\n            if neighbor in visited_end:\n                return visited_start[node] + visited_end[neighbor][::-1]\n            if neighbor not in visited_start:\n                visited_start[neighbor] = visited_start[node] + [neighbor]\n                queue_start.append(neighbor)\n\n        # Expand from end\n        node = queue_end.popleft()\n        for neighbor in graph[node]:\n            if neighbor in visited_start:\n                return visited_start[neighbor] + visited_end[node][::-1]\n            if neighbor not in visited_end:\n                visited_end[neighbor] = visited_end[node] + [neighbor]\n                queue_end.append(neighbor)\n\n    return None\n</code></pre>"},{"location":"graph-modeling/dijkstra-bellman-ford/","title":"Dijkstra &amp; Bellman-Ford Algorithms","text":"<p>Dijkstra's algorithm and Bellman-Ford algorithm are fundamental shortest path algorithms for weighted graphs. They differ in their assumptions about edge weights and their time complexity, making them suitable for different types of problems.</p>"},{"location":"graph-modeling/dijkstra-bellman-ford/#dijkstras-algorithm","title":"Dijkstra's Algorithm","text":"<p>Dijkstra's algorithm finds the shortest path from a source vertex to all other vertices in a graph with non-negative edge weights. It uses a greedy approach with a priority queue.</p>"},{"location":"graph-modeling/dijkstra-bellman-ford/#how-it-works","title":"How It Works","text":"<ol> <li>Initialize: Set distance to source as 0, all others as infinity</li> <li>Priority Queue: Use a min-heap to always process the vertex with minimum distance</li> <li>Relaxation: For each vertex, update distances to its neighbors if a shorter path is found</li> <li>Greedy Choice: Always process the unvisited vertex with minimum distance</li> </ol>"},{"location":"graph-modeling/dijkstra-bellman-ford/#basic-implementation","title":"Basic Implementation","text":"<p>Problem: Find shortest distances from a source vertex to all other vertices using Dijkstra's algorithm.</p> <p>Sample Input:  - Graph: <code>{0: [(1,4), (2,1)], 1: [(3,1)], 2: [(1,2), (3,5)], 3: []}</code> - Source: <code>0</code></p> <p>Sample Output: <code>[0, 3, 1, 4]</code> (Shortest distances from 0 to all vertices)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass Dijkstra {\npublic:\n    vector&lt;int&gt; shortestPath(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph, int source) {\n        int n = graph.size();\n        vector&lt;int&gt; dist(n, INT_MAX);\n        vector&lt;bool&gt; visited(n, false);\n        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n\n        dist[source] = 0;\n        pq.push({0, source});\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            pq.pop();\n\n            if (visited[u]) continue;\n            visited[u] = true;\n\n            for (auto&amp; edge : graph[u]) {\n                int v = edge.first;\n                int weight = edge.second;\n\n                if (dist[u] + weight &lt; dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n\n        return dist;\n    }\n};\n</code></pre>"},{"location":"graph-modeling/dijkstra-bellman-ford/#dijkstra-with-path-reconstruction","title":"Dijkstra with Path Reconstruction","text":"<p>Problem: Find shortest path and reconstruct the actual path from source to destination.</p> <p>Sample Input:  - Graph: <code>{0: [(1,4), (2,1)], 1: [(3,1)], 2: [(1,2), (3,5)], 3: []}</code> - Source: <code>0</code>, Destination: <code>3</code></p> <p>Sample Output:  - Distance: <code>4</code> - Path: <code>[0, 2, 1, 3]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass DijkstraWithPath {\npublic:\n    pair&lt;int, vector&lt;int&gt;&gt; shortestPath(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph, \n                                       int source, int destination) {\n        int n = graph.size();\n        vector&lt;int&gt; dist(n, INT_MAX);\n        vector&lt;int&gt; parent(n, -1);\n        vector&lt;bool&gt; visited(n, false);\n        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n\n        dist[source] = 0;\n        pq.push({0, source});\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            pq.pop();\n\n            if (visited[u]) continue;\n            visited[u] = true;\n\n            if (u == destination) break;\n\n            for (auto&amp; edge : graph[u]) {\n                int v = edge.first;\n                int weight = edge.second;\n\n                if (dist[u] + weight &lt; dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    parent[v] = u;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n\n        // Reconstruct path\n        vector&lt;int&gt; path;\n        if (dist[destination] != INT_MAX) {\n            int current = destination;\n            while (current != -1) {\n                path.push_back(current);\n                current = parent[current];\n            }\n            reverse(path.begin(), path.end());\n        }\n\n        return {dist[destination], path};\n    }\n};\n</code></pre>"},{"location":"graph-modeling/dijkstra-bellman-ford/#bellman-ford-algorithm","title":"Bellman-Ford Algorithm","text":"<p>Bellman-Ford algorithm finds shortest paths from a source vertex to all other vertices, even with negative edge weights. It can also detect negative cycles.</p>"},{"location":"graph-modeling/dijkstra-bellman-ford/#how-it-works_1","title":"How It Works","text":"<ol> <li>Initialize: Set distance to source as 0, all others as infinity</li> <li>Relaxation: For each edge, try to improve the distance to the destination</li> <li>Repeat: Perform relaxation V-1 times (where V is number of vertices)</li> <li>Negative Cycle Check: If one more relaxation improves any distance, negative cycle exists</li> </ol>"},{"location":"graph-modeling/dijkstra-bellman-ford/#basic-implementation_1","title":"Basic Implementation","text":"<p>Problem: Find shortest distances using Bellman-Ford algorithm, handling negative weights.</p> <p>Sample Input:  - Graph: <code>{0: [(1,4), (2,1)], 1: [(3,1)], 2: [(1,2), (3,5)], 3: []}</code> - Source: <code>0</code></p> <p>Sample Output: <code>[0, 3, 1, 4]</code> (Shortest distances from 0 to all vertices)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass BellmanFord {\npublic:\n    vector&lt;int&gt; shortestPath(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph, int source) {\n        int n = graph.size();\n        vector&lt;int&gt; dist(n, INT_MAX);\n        dist[source] = 0;\n\n        // Relax all edges V-1 times\n        for (int i = 0; i &lt; n - 1; i++) {\n            for (int u = 0; u &lt; n; u++) {\n                if (dist[u] != INT_MAX) {\n                    for (auto&amp; edge : graph[u]) {\n                        int v = edge.first;\n                        int weight = edge.second;\n\n                        if (dist[u] + weight &lt; dist[v]) {\n                            dist[v] = dist[u] + weight;\n                        }\n                    }\n                }\n            }\n        }\n\n        return dist;\n    }\n\n    bool hasNegativeCycle(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph) {\n        int n = graph.size();\n        vector&lt;int&gt; dist(n, 0); // Start with all distances as 0\n\n        // Relax all edges V times\n        for (int i = 0; i &lt; n; i++) {\n            for (int u = 0; u &lt; n; u++) {\n                for (auto&amp; edge : graph[u]) {\n                    int v = edge.first;\n                    int weight = edge.second;\n\n                    if (dist[u] + weight &lt; dist[v]) {\n                        if (i == n - 1) {\n                            return true; // Negative cycle detected\n                        }\n                        dist[v] = dist[u] + weight;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n};\n</code></pre>"},{"location":"graph-modeling/dijkstra-bellman-ford/#advanced-applications","title":"Advanced Applications","text":""},{"location":"graph-modeling/dijkstra-bellman-ford/#all-pairs-shortest-path-floyd-warshall","title":"All-Pairs Shortest Path (Floyd-Warshall)","text":"<p>Problem: Find shortest distances between all pairs of vertices.</p> <p>Sample Input:  <pre><code>Distance matrix:\n   0   4   1 INF\n INF   0   1   1\n INF   2   0   5\n INF INF INF   0\n</code></pre></p> <p>Sample Output:  <pre><code>   0   3   1   4\n INF   0   1   1\n INF   2   0   3\n INF INF INF   0\n</code></pre></p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass FloydWarshall {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; allPairsShortestPath(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {\n        int n = graph.size();\n        vector&lt;vector&lt;int&gt;&gt; dist = graph;\n\n        // Floyd-Warshall algorithm\n        for (int k = 0; k &lt; n; k++) {\n            for (int i = 0; i &lt; n; i++) {\n                for (int j = 0; j &lt; n; j++) {\n                    if (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX) {\n                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                    }\n                }\n            }\n        }\n\n        return dist;\n    }\n};\n</code></pre>"},{"location":"graph-modeling/dijkstra-bellman-ford/#shortest-path-with-k-stops","title":"Shortest Path with K Stops","text":"<p>Problem: Find cheapest flight route with at most K stops.</p> <p>Sample Input:  - Flights: <code>[[0,1,100],[1,2,100],[0,2,500]]</code> - Source: <code>0</code>, Destination: <code>2</code>, Stops: <code>1</code></p> <p>Sample Output: <code>200</code> (Route: 0 \u2192 1 \u2192 2 with 1 stop)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass ShortestPathKStops {\npublic:\n    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);\n\n        // Build adjacency list\n        for (auto&amp; flight : flights) {\n            graph[flight[0]].push_back({flight[1], flight[2]});\n        }\n\n        // {cost, city, stops_remaining}\n        priority_queue&lt;vector&lt;int&gt;, vector&lt;vector&lt;int&gt;&gt;, greater&lt;vector&lt;int&gt;&gt;&gt; pq;\n        pq.push({0, src, k + 1});\n\n        while (!pq.empty()) {\n            auto current = pq.top();\n            pq.pop();\n\n            int cost = current[0];\n            int city = current[1];\n            int stops = current[2];\n\n            if (city == dst) {\n                return cost;\n            }\n\n            if (stops &gt; 0) {\n                for (auto&amp; edge : graph[city]) {\n                    int nextCity = edge.first;\n                    int nextCost = edge.second;\n                    pq.push({cost + nextCost, nextCity, stops - 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n</code></pre>"},{"location":"graph-modeling/dijkstra-bellman-ford/#comparison-and-use-cases","title":"Comparison and Use Cases","text":""},{"location":"graph-modeling/dijkstra-bellman-ford/#dijkstra-vs-bellman-ford","title":"Dijkstra vs Bellman-Ford","text":"Aspect Dijkstra Bellman-Ford Edge Weights Non-negative only Negative weights allowed Time Complexity O((V + E) log V) O(VE) Space Complexity O(V) O(V) Negative Cycles Cannot detect Can detect Best For Dense graphs, non-negative weights Sparse graphs, negative weights"},{"location":"graph-modeling/dijkstra-bellman-ford/#when-to-use-each-algorithm","title":"When to Use Each Algorithm","text":"<p>Use Dijkstra when: - All edge weights are non-negative - You need the shortest path from one source - Graph is dense (many edges) - You need optimal time complexity</p> <p>Use Bellman-Ford when: - Graph may have negative edge weights - You need to detect negative cycles - Graph is sparse (few edges) - You need to find shortest paths from one source</p> <p>Use Floyd-Warshall when: - You need shortest paths between all pairs - Graph is small (V \u2264 400) - You need to detect negative cycles in the entire graph</p>"},{"location":"graph-modeling/dijkstra-bellman-ford/#use-cases","title":"Use Cases","text":""},{"location":"graph-modeling/dijkstra-bellman-ford/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>GPS Navigation: Finding shortest routes</li> <li>Network Routing: Optimizing data packet paths</li> <li>Social Networks: Finding shortest connection paths</li> <li>Game AI: Pathfinding in games</li> <li>Resource Allocation: Optimizing resource distribution</li> </ul>"},{"location":"graph-modeling/dijkstra-bellman-ford/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>Shortest Path Problems: Standard shortest path queries</li> <li>Negative Cycle Detection: Finding problematic cycles</li> <li>All-Pairs Shortest Path: When you need all distances</li> <li>Constrained Shortest Path: With additional constraints</li> <li>Graph Optimization: Various graph optimization problems</li> </ul>"},{"location":"graph-modeling/dijkstra-bellman-ford/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"graph-modeling/dijkstra-bellman-ford/#time-complexity","title":"Time Complexity","text":"<ul> <li>Dijkstra: O((V + E) log V) with binary heap</li> <li>Bellman-Ford: O(VE)</li> <li>Floyd-Warshall: O(V\u00b3)</li> </ul>"},{"location":"graph-modeling/dijkstra-bellman-ford/#space-complexity","title":"Space Complexity","text":"<ul> <li>Dijkstra: O(V) for distance array and priority queue</li> <li>Bellman-Ford: O(V) for distance array</li> <li>Floyd-Warshall: O(V\u00b2) for distance matrix</li> </ul>"},{"location":"graph-modeling/dijkstra-bellman-ford/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Choose Right Algorithm: Use Dijkstra for non-negative weights, Bellman-Ford for negative weights</li> <li>Data Structures: Use appropriate priority queue implementations</li> <li>Early Termination: Stop when destination is reached (for single-source)</li> <li>Path Reconstruction: Store parent pointers for path recovery</li> <li>Negative Cycle Detection: Always check for negative cycles with Bellman-Ford</li> <li>Memory Management: Use adjacency lists for sparse graphs, matrices for dense graphs</li> </ol>"},{"location":"graph-modeling/union-find/","title":"Union-Find (Disjoint Set Union)","text":"<p>Union-Find, also known as Disjoint Set Union (DSU), is a data structure that efficiently manages a collection of disjoint sets. It provides fast operations for finding which set an element belongs to and for merging two sets together.</p>"},{"location":"graph-modeling/union-find/#how-it-works","title":"How It Works","text":"<p>Union-Find maintains a forest of trees where each tree represents a set. The root of each tree is the representative of the set. Two elements are in the same set if they have the same root.</p>"},{"location":"graph-modeling/union-find/#key-operations","title":"Key Operations","text":"<ol> <li>Find: Determine which set an element belongs to</li> <li>Union: Merge two sets into one</li> <li>Connected: Check if two elements are in the same set</li> </ol>"},{"location":"graph-modeling/union-find/#basic-implementation","title":"Basic Implementation","text":"<p>Problem: Implement Union-Find data structure with path compression and union by rank optimizations.</p> <p>Sample Input:  - Operations: Union(0,1), Union(2,3), Find(0), Find(2), Connected(0,2)</p> <p>Sample Output:  - Find(0) = 0, Find(2) = 2, Connected(0,2) = false</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector&lt;int&gt; parent;\n    vector&lt;int&gt; rank;\n    int components;\n\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0), components(n) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px == py) return; // Already in same set\n\n        // Union by rank\n        if (rank[px] &lt; rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] &gt; rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n\n        components--;\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int getComponents() {\n        return components;\n    }\n};\n</code></pre>"},{"location":"graph-modeling/union-find/#advanced-applications","title":"Advanced Applications","text":""},{"location":"graph-modeling/union-find/#minimum-spanning-tree-kruskals-algorithm","title":"Minimum Spanning Tree (Kruskal's Algorithm)","text":"<p>Problem: Find the minimum spanning tree using Kruskal's algorithm with Union-Find.</p> <p>Sample Input:  - Edges: <code>[(0,1,4), (0,2,1), (1,2,2), (1,3,5), (2,3,3)]</code> (u, v, weight)</p> <p>Sample Output:  - MST edges: <code>[(0,2,1), (1,2,2), (2,3,3)]</code> - Total weight: <code>6</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n    Edge(int u, int v, int w) : u(u), v(v), weight(w) {}\n};\n\nclass KruskalMST {\npublic:\n    vector&lt;Edge&gt; findMST(vector&lt;Edge&gt;&amp; edges, int vertices) {\n        // Sort edges by weight\n        sort(edges.begin(), edges.end(), \n             [](const Edge&amp; a, const Edge&amp; b) {\n                 return a.weight &lt; b.weight;\n             });\n\n        UnionFind uf(vertices);\n        vector&lt;Edge&gt; mst;\n\n        for (const Edge&amp; edge : edges) {\n            if (!uf.connected(edge.u, edge.v)) {\n                uf.unite(edge.u, edge.v);\n                mst.push_back(edge);\n            }\n        }\n\n        return mst;\n    }\n\n    int mstWeight(vector&lt;Edge&gt;&amp; edges, int vertices) {\n        vector&lt;Edge&gt; mst = findMST(edges, vertices);\n        int totalWeight = 0;\n        for (const Edge&amp; edge : mst) {\n            totalWeight += edge.weight;\n        }\n        return totalWeight;\n    }\n};\n</code></pre>"},{"location":"graph-modeling/union-find/#number-of-islands","title":"Number of Islands","text":"<p>Problem: Count the number of connected components (islands) in a 2D grid.</p> <p>Sample Input:  <pre><code>Grid:\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1\n</code></pre></p> <p>Sample Output: <code>3</code> (Three connected components)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass NumberOfIslands {\nprivate:\n    int rows, cols;\n    vector&lt;vector&lt;int&gt;&gt; directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\n        if (grid.empty() || grid[0].empty()) return 0;\n\n        rows = grid.size();\n        cols = grid[0].size();\n\n        UnionFind uf(rows * cols);\n        int waterCount = 0;\n\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                if (grid[i][j] == '1') {\n                    int current = i * cols + j;\n\n                    // Check all 4 directions\n                    for (auto&amp; dir : directions) {\n                        int ni = i + dir[0];\n                        int nj = j + dir[1];\n\n                        if (ni &gt;= 0 &amp;&amp; ni &lt; rows &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; cols &amp;&amp; \n                            grid[ni][nj] == '1') {\n                            int neighbor = ni * cols + nj;\n                            uf.unite(current, neighbor);\n                        }\n                    }\n                } else {\n                    waterCount++;\n                }\n            }\n        }\n\n        return uf.getComponents() - waterCount;\n    }\n};\n</code></pre>"},{"location":"graph-modeling/union-find/#redundant-connection","title":"Redundant Connection","text":"<p>Problem: Find the edge that can be removed to make the graph a tree.</p> <p>Sample Input:  - Edges: <code>[[1,2], [1,3], [2,3]]</code></p> <p>Sample Output: <code>[2,3]</code> (The redundant edge)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass RedundantConnection {\npublic:\n    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n        int n = edges.size();\n        UnionFind uf(n + 1);\n\n        for (const auto&amp; edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n\n            if (uf.connected(u, v)) {\n                return edge; // This edge creates a cycle\n            }\n\n            uf.unite(u, v);\n        }\n\n        return {}; // No redundant edge found\n    }\n};\n</code></pre>"},{"location":"graph-modeling/union-find/#advanced-union-find-techniques","title":"Advanced Union-Find Techniques","text":""},{"location":"graph-modeling/union-find/#union-find-with-size-tracking","title":"Union-Find with Size Tracking","text":"<p>Problem: Track the size of each connected component.</p> <p>Sample Input:  - Operations: Union(0,1), Union(1,2), GetSize(0)</p> <p>Sample Output:  - GetSize(0) = 3 (Component containing 0, 1, 2 has size 3)</p> <pre><code>class UnionFindWithSize {\nprivate:\n    vector&lt;int&gt; parent;\n    vector&lt;int&gt; size;\n\npublic:\n    UnionFindWithSize(int n) : parent(n), size(n, 1) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px == py) return;\n\n        // Always attach smaller tree to larger tree\n        if (size[px] &lt; size[py]) {\n            parent[px] = py;\n            size[py] += size[px];\n        } else {\n            parent[py] = px;\n            size[px] += size[py];\n        }\n    }\n\n    int getSize(int x) {\n        return size[find(x)];\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n</code></pre>"},{"location":"graph-modeling/union-find/#union-find-with-rollback","title":"Union-Find with Rollback","text":"<p>Problem: Support rollback operations to undo previous unions.</p> <p>Sample Input:  - Operations: Union(0,1), Union(1,2), Rollback(), Find(0)</p> <p>Sample Output:  - After rollback: Find(0) = 0, Find(2) = 2 (Not connected)</p> <pre><code>class UnionFindWithRollback {\nprivate:\n    vector&lt;int&gt; parent;\n    vector&lt;int&gt; rank;\n    vector&lt;pair&lt;int, int&gt;&gt; history; // Store operations for rollback\n\npublic:\n    UnionFindWithRollback(int n) : parent(n), rank(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            return find(parent[x]);\n        }\n        return x;\n    }\n\n    void unite(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px == py) return;\n\n        // Store the operation for potential rollback\n        history.push_back({px, py});\n\n        if (rank[px] &lt; rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] &gt; rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n\n    void rollback() {\n        if (history.empty()) return;\n\n        auto [px, py] = history.back();\n        history.pop_back();\n\n        parent[px] = px;\n        parent[py] = py;\n        rank[px] = 0;\n        rank[py] = 0;\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n</code></pre>"},{"location":"graph-modeling/union-find/#use-cases","title":"Use Cases","text":""},{"location":"graph-modeling/union-find/#graph-problems","title":"Graph Problems","text":"<ul> <li>Connectivity: Check if two vertices are connected</li> <li>Cycle Detection: Detect cycles in undirected graphs</li> <li>Minimum Spanning Tree: Kruskal's algorithm</li> <li>Connected Components: Find all connected components</li> </ul>"},{"location":"graph-modeling/union-find/#grid-problems","title":"Grid Problems","text":"<ul> <li>Number of Islands: Count connected components in 2D grid</li> <li>Maze Problems: Check connectivity in mazes</li> <li>Flood Fill: Connected region problems</li> <li>Union-Find on Grid: 2D connectivity problems</li> </ul>"},{"location":"graph-modeling/union-find/#network-problems","title":"Network Problems","text":"<ul> <li>Network Connectivity: Check if network is connected</li> <li>Redundant Connections: Find edges that can be removed</li> <li>Critical Connections: Find bridges in network</li> <li>Component Analysis: Analyze network components</li> </ul>"},{"location":"graph-modeling/union-find/#optimization-problems","title":"Optimization Problems","text":"<ul> <li>Clustering: Group similar elements</li> <li>Partitioning: Divide elements into groups</li> <li>Matching: Find optimal pairings</li> <li>Scheduling: Group related tasks</li> </ul>"},{"location":"graph-modeling/union-find/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"graph-modeling/union-find/#time-complexity","title":"Time Complexity","text":"<ul> <li>Find (with path compression): O(\u03b1(n)) amortized</li> <li>Union (with union by rank): O(\u03b1(n)) amortized</li> <li>Connected: O(\u03b1(n)) amortized</li> <li>\u03b1(n): Inverse Ackermann function (practically constant)</li> </ul>"},{"location":"graph-modeling/union-find/#space-complexity","title":"Space Complexity","text":"<ul> <li>Basic Union-Find: O(n) for parent and rank arrays</li> <li>With Size Tracking: O(n) for additional size array</li> <li>With Rollback: O(n + m) where m is number of operations</li> </ul>"},{"location":"graph-modeling/union-find/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Path Compression: Always use path compression in find operation</li> <li>Union by Rank: Use union by rank for better performance</li> <li>Early Termination: Stop when all elements are connected</li> <li>Memory Management: Use appropriate data structures for your use case</li> <li>Batch Operations: Process multiple unions together when possible</li> <li>Rollback Support: Add rollback only when needed (adds overhead)</li> </ol>"},{"location":"graph-modeling/union-find/#common-patterns","title":"Common Patterns","text":""},{"location":"graph-modeling/union-find/#standard-union-find-pattern","title":"Standard Union-Find Pattern","text":"<pre><code>UnionFind uf(n);\nfor (auto&amp; edge : edges) {\n    if (!uf.connected(edge.u, edge.v)) {\n        uf.unite(edge.u, edge.v);\n        // Process the edge\n    }\n}\n</code></pre>"},{"location":"graph-modeling/union-find/#component-counting-pattern","title":"Component Counting Pattern","text":"<pre><code>UnionFind uf(n);\n// Perform all unions\nint components = uf.getComponents();\n</code></pre>"},{"location":"graph-modeling/union-find/#cycle-detection-pattern","title":"Cycle Detection Pattern","text":"<pre><code>UnionFind uf(n);\nfor (auto&amp; edge : edges) {\n    if (uf.connected(edge.u, edge.v)) {\n        // Cycle detected\n        return edge;\n    }\n    uf.unite(edge.u, edge.v);\n}\n</code></pre>"},{"location":"math/","title":"Mathematical Formulas &amp; Concepts","text":"<p>This section provides essential mathematical formulas and concepts commonly used in competitive programming and algorithmic problem-solving. These formulas serve as quick references for geometric calculations, combinatorics, number theory, and other mathematical operations.</p>"},{"location":"math/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link Geometric Formulas Essential formulas for points, lines, circles, polygons, and 3D geometry. Geometric Formulas Combinatorics &amp; Counting Permutations, combinations, and counting principles for probability and enumeration problems. Combinatorics &amp; Counting Number Theory Prime numbers, modular arithmetic, GCD, LCM, and divisibility rules. Number Theory Trigonometry Trigonometric functions, identities, and their applications in geometric problems. Trigonometry Linear Algebra Matrix operations, determinants, and vector calculations. Linear Algebra"},{"location":"math/#quick-reference-tables","title":"Quick Reference Tables","text":""},{"location":"math/#common-mathematical-constants","title":"Common Mathematical Constants","text":"Constant Value Description \u03c0 (pi) 3.14159265359 Ratio of circle's circumference to diameter e 2.71828182846 Base of natural logarithm \u03c6 (phi) 1.61803398875 Golden ratio \u221a2 1.41421356237 Square root of 2 \u221a3 1.73205080757 Square root of 3"},{"location":"math/#common-angle-conversions","title":"Common Angle Conversions","text":"Degrees Radians Sin Cos Tan 0\u00b0 0 0 1 0 30\u00b0 \u03c0/6 1/2 \u221a3/2 \u221a3/3 45\u00b0 \u03c0/4 \u221a2/2 \u221a2/2 1 60\u00b0 \u03c0/3 \u221a3/2 1/2 \u221a3 90\u00b0 \u03c0/2 1 0 \u221e"},{"location":"math/#when-to-use-mathematical-formulas","title":"When to Use Mathematical Formulas","text":"<p>These formulas are essential when: - Solving geometric problems involving shapes, distances, and angles - Working with probability and counting problems - Implementing number theory algorithms - Performing trigonometric calculations - Working with matrices and vectors</p>"},{"location":"math/#common-applications","title":"Common Applications","text":""},{"location":"math/#geometric-problems","title":"Geometric Problems","text":"<ul> <li>Distance Calculations: Finding distances between points, lines, and shapes</li> <li>Area and Perimeter: Calculating areas and perimeters of various shapes</li> <li>Angle Calculations: Determining angles between lines and vectors</li> <li>3D Geometry: Working with 3D coordinates and transformations</li> </ul>"},{"location":"math/#counting-problems","title":"Counting Problems","text":"<ul> <li>Permutations: Arranging objects in order</li> <li>Combinations: Selecting objects without regard to order</li> <li>Probability: Calculating probabilities of events</li> <li>Inclusion-Exclusion: Counting elements in unions of sets</li> </ul>"},{"location":"math/#number-theory","title":"Number Theory","text":"<ul> <li>Prime Factorization: Breaking numbers into prime factors</li> <li>Modular Arithmetic: Working with remainders and congruences</li> <li>GCD and LCM: Finding greatest common divisors and least common multiples</li> <li>Divisibility: Checking if numbers divide evenly</li> </ul>"},{"location":"math/#trigonometric-applications","title":"Trigonometric Applications","text":"<ul> <li>Angle Calculations: Finding angles in triangles and polygons</li> <li>Wave Functions: Modeling periodic phenomena</li> <li>Coordinate Transformations: Converting between coordinate systems</li> <li>Geometric Constructions: Building shapes with specific properties</li> </ul>"},{"location":"math/#tips-for-using-mathematical-formulas","title":"Tips for Using Mathematical Formulas","text":"<ol> <li>Precision: Be careful with floating-point precision in geometric calculations</li> <li>Edge Cases: Consider special cases like parallel lines, collinear points</li> <li>Optimization: Use integer arithmetic when possible to avoid floating-point errors</li> <li>Modular Arithmetic: Apply modular properties to prevent integer overflow</li> <li>Trigonometric Identities: Use identities to simplify complex expressions</li> <li>Coordinate Systems: Choose appropriate coordinate systems for the problem</li> </ol>"},{"location":"math/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Floating Point: Use <code>double</code> or <code>long double</code> for high precision</li> <li>Integer Math: Use <code>long long</code> for large numbers</li> <li>Modular Operations: Apply modulo at each step to prevent overflow</li> <li>Trigonometric Functions: Use <code>sin()</code>, <code>cos()</code>, <code>tan()</code> from <code>&lt;cmath&gt;</code></li> <li>Mathematical Constants: Use <code>M_PI</code>, <code>M_E</code> from <code>&lt;cmath&gt;</code> or define your own</li> </ul>"},{"location":"math/combinatorics-counting/","title":"Combinatorics &amp; Counting","text":"<p>Essential formulas and techniques for permutations, combinations, and counting principles used in probability, enumeration, and combinatorial problems.</p>"},{"location":"math/combinatorics-counting/#basic-counting-principles","title":"Basic Counting Principles","text":""},{"location":"math/combinatorics-counting/#factorial","title":"Factorial","text":"<p>Problem: Calculate n! (n factorial).</p> <p>Sample Input: <code>n = 5</code></p> <p>Sample Output: <code>120</code> (5! = 5 \u00d7 4 \u00d7 3 \u00d7 2 \u00d7 1 = 120)</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\n// Recursive factorial\nlong long factorial(int n) {\n    if (n &lt;= 1) return 1;\n    return n * factorial(n - 1);\n}\n\n// Iterative factorial\nlong long factorialIterative(int n) {\n    long long result = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// Factorial with modulo\nlong long factorialMod(int n, long long mod) {\n    long long result = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        result = (result * i) % mod;\n    }\n    return result;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#permutations-pnr","title":"Permutations (P(n,r))","text":"<p>Problem: Calculate the number of ways to arrange r objects from n objects.</p> <p>Sample Input: <code>n = 5, r = 3</code></p> <p>Sample Output: <code>60</code> (P(5,3) = 5!/(5-3)! = 120/2 = 60)</p> <pre><code>// Permutation formula: P(n,r) = n! / (n-r)!\nlong long permutation(int n, int r) {\n    if (r &gt; n || r &lt; 0) return 0;\n    if (r == 0) return 1;\n\n    long long result = 1;\n    for (int i = n; i &gt; n - r; i--) {\n        result *= i;\n    }\n    return result;\n}\n\n// Permutation with modulo\nlong long permutationMod(int n, int r, long long mod) {\n    if (r &gt; n || r &lt; 0) return 0;\n    if (r == 0) return 1;\n\n    long long result = 1;\n    for (int i = n; i &gt; n - r; i--) {\n        result = (result * i) % mod;\n    }\n    return result;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#combinations-cnr","title":"Combinations (C(n,r))","text":"<p>Problem: Calculate the number of ways to choose r objects from n objects.</p> <p>Sample Input: <code>n = 5, r = 3</code></p> <p>Sample Output: <code>10</code> (C(5,3) = 5!/(3!(5-3)!) = 120/(6\u00d72) = 10)</p> <pre><code>// Combination formula: C(n,r) = n! / (r!(n-r)!)\nlong long combination(int n, int r) {\n    if (r &gt; n || r &lt; 0) return 0;\n    if (r == 0 || r == n) return 1;\n\n    // Use the property C(n,r) = C(n,n-r) to minimize computation\n    if (r &gt; n - r) r = n - r;\n\n    long long result = 1;\n    for (int i = 0; i &lt; r; i++) {\n        result = result * (n - i) / (i + 1);\n    }\n    return result;\n}\n\n// Combination with modulo (using modular inverse)\nlong long modInverse(long long a, long long mod) {\n    long long result = 1;\n    long long power = mod - 2;\n    while (power &gt; 0) {\n        if (power % 2 == 1) {\n            result = (result * a) % mod;\n        }\n        a = (a * a) % mod;\n        power /= 2;\n    }\n    return result;\n}\n\nlong long combinationMod(int n, int r, long long mod) {\n    if (r &gt; n || r &lt; 0) return 0;\n    if (r == 0 || r == n) return 1;\n\n    long long numerator = 1;\n    long long denominator = 1;\n\n    for (int i = 0; i &lt; r; i++) {\n        numerator = (numerator * (n - i)) % mod;\n        denominator = (denominator * (i + 1)) % mod;\n    }\n\n    return (numerator * modInverse(denominator, mod)) % mod;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#advanced-counting-techniques","title":"Advanced Counting Techniques","text":""},{"location":"math/combinatorics-counting/#pascals-triangle","title":"Pascal's Triangle","text":"<p>Problem: Generate Pascal's triangle for combinations.</p> <p>Sample Input: <code>n = 5</code></p> <p>Sample Output:  <pre><code>1\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1\n1 5 10 10 5 1\n</code></pre></p> <pre><code>vector&lt;vector&lt;long long&gt;&gt; pascalsTriangle(int n) {\n    vector&lt;vector&lt;long long&gt;&gt; triangle(n + 1);\n\n    for (int i = 0; i &lt;= n; i++) {\n        triangle[i].resize(i + 1);\n        triangle[i][0] = triangle[i][i] = 1;\n\n        for (int j = 1; j &lt; i; j++) {\n            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j];\n        }\n    }\n\n    return triangle;\n}\n\n// Get C(n,r) from Pascal's triangle\nlong long combinationFromTriangle(const vector&lt;vector&lt;long long&gt;&gt;&amp; triangle, int n, int r) {\n    if (r &gt; n || r &lt; 0) return 0;\n    return triangle[n][r];\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#multinomial-coefficients","title":"Multinomial Coefficients","text":"<p>Problem: Calculate multinomial coefficient for dividing n objects into groups.</p> <p>Sample Input: <code>n = 10, groups = [3, 4, 3]</code></p> <p>Sample Output: <code>4200</code> (10!/(3!\u00d74!\u00d73!) = 3628800/(6\u00d724\u00d76) = 4200)</p> <pre><code>long long multinomialCoefficient(int n, const vector&lt;int&gt;&amp; groups) {\n    long long result = factorial(n);\n\n    for (int group : groups) {\n        result /= factorial(group);\n    }\n\n    return result;\n}\n\n// Multinomial with modulo\nlong long multinomialCoefficientMod(int n, const vector&lt;int&gt;&amp; groups, long long mod) {\n    long long result = factorialMod(n, mod);\n\n    for (int group : groups) {\n        result = (result * modInverse(factorialMod(group, mod), mod)) % mod;\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#stirling-numbers","title":"Stirling Numbers","text":"<p>Problem: Calculate Stirling numbers of the first and second kind.</p> <p>Sample Input: <code>n = 4, k = 2</code></p> <p>Sample Output:  - First kind: <code>11</code> (number of ways to arrange 4 objects into 2 cycles) - Second kind: <code>7</code> (number of ways to partition 4 objects into 2 non-empty subsets)</p> <pre><code>// Stirling numbers of the first kind: S1(n,k)\nlong long stirlingFirst(int n, int k) {\n    if (k == 0) return (n == 0) ? 1 : 0;\n    if (k &gt; n) return 0;\n    if (k == n) return 1;\n\n    return (n - 1) * stirlingFirst(n - 1, k) + stirlingFirst(n - 1, k - 1);\n}\n\n// Stirling numbers of the second kind: S2(n,k)\nlong long stirlingSecond(int n, int k) {\n    if (k == 0) return (n == 0) ? 1 : 0;\n    if (k &gt; n) return 0;\n    if (k == n) return 1;\n\n    return k * stirlingSecond(n - 1, k) + stirlingSecond(n - 1, k - 1);\n}\n\n// Dynamic programming version for efficiency\nvector&lt;vector&lt;long long&gt;&gt; stirlingSecondDP(int n, int k) {\n    vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(k + 1, 0));\n\n    dp[0][0] = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= min(i, k); j++) {\n            dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1];\n        }\n    }\n\n    return dp;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#probability-formulas","title":"Probability Formulas","text":""},{"location":"math/combinatorics-counting/#basic-probability","title":"Basic Probability","text":"<p>Problem: Calculate probability of an event.</p> <p>Sample Input: <code>favorable = 3, total = 10</code></p> <p>Sample Output: <code>0.3</code> (3/10 = 0.3)</p> <pre><code>double probability(int favorable, int total) {\n    if (total == 0) return 0;\n    return (double)favorable / total;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#conditional-probability","title":"Conditional Probability","text":"<p>Problem: Calculate P(A|B) = P(A\u2229B) / P(B).</p> <p>Sample Input: <code>P(A\u2229B) = 0.2, P(B) = 0.5</code></p> <p>Sample Output: <code>0.4</code> (0.2/0.5 = 0.4)</p> <pre><code>double conditionalProbability(double pAandB, double pB) {\n    if (pB == 0) return 0;\n    return pAandB / pB;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#bayes-theorem","title":"Bayes' Theorem","text":"<p>Problem: Calculate P(A|B) using Bayes' theorem.</p> <p>Sample Input: <code>P(B|A) = 0.8, P(A) = 0.3, P(B) = 0.5</code></p> <p>Sample Output: <code>0.48</code> (0.8 \u00d7 0.3 / 0.5 = 0.48)</p> <pre><code>double bayesTheorem(double pBgivenA, double pA, double pB) {\n    if (pB == 0) return 0;\n    return (pBgivenA * pA) / pB;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#inclusion-exclusion-principle","title":"Inclusion-Exclusion Principle","text":""},{"location":"math/combinatorics-counting/#basic-inclusion-exclusion","title":"Basic Inclusion-Exclusion","text":"<p>Problem: Calculate |A \u222a B| = |A| + |B| - |A \u2229 B|.</p> <p>Sample Input: <code>|A| = 10, |B| = 15, |A\u2229B| = 5</code></p> <p>Sample Output: <code>20</code> (10 + 15 - 5 = 20)</p> <pre><code>long long inclusionExclusion2(long long sizeA, long long sizeB, long long sizeAandB) {\n    return sizeA + sizeB - sizeAandB;\n}\n\n// For three sets: |A \u222a B \u222a C| = |A| + |B| + |C| - |A\u2229B| - |A\u2229C| - |B\u2229C| + |A\u2229B\u2229C|\nlong long inclusionExclusion3(long long sizeA, long long sizeB, long long sizeC,\n                             long long sizeAB, long long sizeAC, long long sizeBC,\n                             long long sizeABC) {\n    return sizeA + sizeB + sizeC - sizeAB - sizeAC - sizeBC + sizeABC;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#derangements","title":"Derangements","text":"<p>Problem: Calculate the number of derangements (permutations where no element appears in its original position).</p> <p>Sample Input: <code>n = 4</code></p> <p>Sample Output: <code>9</code> (D(4) = 9)</p> <pre><code>long long derangements(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 0;\n\n    long long prev = 0, curr = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        long long next = (i - 1) * (prev + curr);\n        prev = curr;\n        curr = next;\n    }\n    return curr;\n}\n\n// Using formula: D(n) = n! * \u03a3(-1)^k / k! for k = 0 to n\nlong long derangementsFormula(int n) {\n    long long result = 0;\n    long long factorial = 1;\n\n    for (int k = 0; k &lt;= n; k++) {\n        if (k &gt; 0) factorial *= k;\n        long long term = factorial;\n        if (k % 2 == 1) term = -term;\n        result += term;\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#catalan-numbers","title":"Catalan Numbers","text":"<p>Problem: Calculate the nth Catalan number.</p> <p>Sample Input: <code>n = 4</code></p> <p>Sample Output: <code>14</code> (C(4) = 14)</p> <pre><code>long long catalan(int n) {\n    if (n &lt;= 1) return 1;\n\n    long long result = 0;\n    for (int i = 0; i &lt; n; i++) {\n        result += catalan(i) * catalan(n - 1 - i);\n    }\n    return result;\n}\n\n// Dynamic programming version\nlong long catalanDP(int n) {\n    vector&lt;long long&gt; dp(n + 1, 0);\n    dp[0] = dp[1] = 1;\n\n    for (int i = 2; i &lt;= n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            dp[i] += dp[j] * dp[i - 1 - j];\n        }\n    }\n\n    return dp[n];\n}\n\n// Using formula: C(n) = (2n)! / ((n+1)! * n!)\nlong long catalanFormula(int n) {\n    return combination(2 * n, n) / (n + 1);\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#common-counting-problems","title":"Common Counting Problems","text":""},{"location":"math/combinatorics-counting/#permutations-with-repetition","title":"Permutations with Repetition","text":"<p>Problem: Calculate permutations of n objects where some are identical.</p> <p>Sample Input: <code>n = 5, counts = [2, 1, 2]</code> (2 A's, 1 B, 2 C's)</p> <p>Sample Output: <code>30</code> (5!/(2!\u00d71!\u00d72!) = 120/4 = 30)</p> <pre><code>long long permutationsWithRepetition(int n, const vector&lt;int&gt;&amp; counts) {\n    long long result = factorial(n);\n\n    for (int count : counts) {\n        result /= factorial(count);\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#circular-permutations","title":"Circular Permutations","text":"<p>Problem: Calculate circular permutations of n objects.</p> <p>Sample Input: <code>n = 4</code></p> <p>Sample Output: <code>6</code> ((4-1)! = 3! = 6)</p> <pre><code>long long circularPermutations(int n) {\n    if (n &lt;= 1) return 1;\n    return factorial(n - 1);\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#combinations-with-repetition","title":"Combinations with Repetition","text":"<p>Problem: Calculate combinations of n objects taken r at a time with repetition allowed.</p> <p>Sample Input: <code>n = 5, r = 3</code></p> <p>Sample Output: <code>35</code> (C(5+3-1, 3) = C(7, 3) = 35)</p> <pre><code>long long combinationsWithRepetition(int n, int r) {\n    return combination(n + r - 1, r);\n}\n</code></pre>"},{"location":"math/combinatorics-counting/#use-cases","title":"Use Cases","text":""},{"location":"math/combinatorics-counting/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>Counting Problems: Enumerating arrangements and selections</li> <li>Probability Problems: Calculating probabilities of events</li> <li>Combinatorial Optimization: Finding optimal arrangements</li> <li>Dynamic Programming: Using counting principles in DP</li> </ul>"},{"location":"math/combinatorics-counting/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Statistics: Analyzing data and calculating probabilities</li> <li>Cryptography: Generating keys and analyzing security</li> <li>Game Theory: Analyzing strategies and outcomes</li> <li>Operations Research: Optimizing resource allocation</li> </ul>"},{"location":"math/combinatorics-counting/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Overflow Prevention: Use modular arithmetic for large numbers</li> <li>Memoization: Cache results for recursive calculations</li> <li>Precomputation: Calculate factorials and combinations in advance</li> <li>Numerical Stability: Be careful with floating-point precision</li> <li>Edge Cases: Handle n=0, r=0, and invalid inputs</li> <li>Efficiency: Use iterative approaches for large inputs</li> </ol>"},{"location":"math/geometric-formulas/","title":"Geometric Formulas","text":"<p>Essential geometric formulas for points, lines, circles, polygons, and 3D geometry commonly used in competitive programming and computational geometry problems.</p>"},{"location":"math/geometric-formulas/#basic-point-operations","title":"Basic Point Operations","text":""},{"location":"math/geometric-formulas/#distance-between-two-points","title":"Distance Between Two Points","text":"<p>Problem: Calculate the distance between two points in 2D or 3D space.</p> <p>Sample Input:  - 2D: <code>P1(0, 0)</code>, <code>P2(3, 4)</code> - 3D: <code>P1(0, 0, 0)</code>, <code>P2(1, 2, 2)</code></p> <p>Sample Output:  - 2D: <code>5.0</code> (3-4-5 right triangle) - 3D: <code>3.0</code> (\u221a(1\u00b2 + 2\u00b2 + 2\u00b2) = \u221a9 = 3)</p> <pre><code>#include &lt;cmath&gt;\nusing namespace std;\n\n// 2D Distance\ndouble distance2D(double x1, double y1, double x2, double y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// 3D Distance\ndouble distance3D(double x1, double y1, double z1, double x2, double y2, double z2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));\n}\n\n// Using point structures\nstruct Point2D {\n    double x, y;\n    Point2D(double x, double y) : x(x), y(y) {}\n\n    double distanceTo(const Point2D&amp; other) const {\n        return sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));\n    }\n};\n</code></pre>"},{"location":"math/geometric-formulas/#midpoint-of-two-points","title":"Midpoint of Two Points","text":"<p>Problem: Find the midpoint between two points.</p> <p>Sample Input: <code>P1(0, 0)</code>, <code>P2(6, 8)</code></p> <p>Sample Output: <code>(3, 4)</code></p> <pre><code>Point2D midpoint(const Point2D&amp; p1, const Point2D&amp; p2) {\n    return Point2D((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);\n}\n</code></pre>"},{"location":"math/geometric-formulas/#line-operations","title":"Line Operations","text":""},{"location":"math/geometric-formulas/#line-equation-ax-by-c-0","title":"Line Equation (Ax + By + C = 0)","text":"<p>Problem: Convert two points to line equation form.</p> <p>Sample Input: <code>P1(1, 2)</code>, <code>P2(3, 4)</code></p> <p>Sample Output: <code>x - y + 1 = 0</code> (A=1, B=-1, C=1)</p> <pre><code>struct Line {\n    double A, B, C; // Ax + By + C = 0\n\n    Line(double A, double B, double C) : A(A), B(B), C(C) {}\n\n    // Create line from two points\n    static Line fromPoints(const Point2D&amp; p1, const Point2D&amp; p2) {\n        double A = p2.y - p1.y;\n        double B = p1.x - p2.x;\n        double C = p2.x * p1.y - p1.x * p2.y;\n        return Line(A, B, C);\n    }\n\n    // Distance from point to line\n    double distanceToPoint(const Point2D&amp; p) const {\n        return abs(A * p.x + B * p.y + C) / sqrt(A * A + B * B);\n    }\n};\n</code></pre>"},{"location":"math/geometric-formulas/#point-line-distance","title":"Point-Line Distance","text":"<p>Problem: Calculate the shortest distance from a point to a line.</p> <p>Sample Input:  - Line: <code>x - y + 1 = 0</code> - Point: <code>(2, 3)</code></p> <p>Sample Output: <code>0.707</code> (\u221a2/2)</p> <pre><code>double pointToLineDistance(const Point2D&amp; point, const Line&amp; line) {\n    return abs(line.A * point.x + line.B * point.y + line.C) / \n           sqrt(line.A * line.A + line.B * line.B);\n}\n</code></pre>"},{"location":"math/geometric-formulas/#line-intersection","title":"Line Intersection","text":"<p>Problem: Find the intersection point of two lines.</p> <p>Sample Input:  - Line 1: <code>x + y = 3</code> - Line 2: <code>x - y = 1</code></p> <p>Sample Output: <code>(2, 1)</code></p> <pre><code>Point2D lineIntersection(const Line&amp; l1, const Line&amp; l2) {\n    double det = l1.A * l2.B - l2.A * l1.B;\n    if (abs(det) &lt; 1e-9) {\n        // Lines are parallel\n        return Point2D(0, 0); // No intersection\n    }\n\n    double x = (l1.B * l2.C - l2.B * l1.C) / det;\n    double y = (l2.A * l1.C - l1.A * l2.C) / det;\n    return Point2D(x, y);\n}\n</code></pre>"},{"location":"math/geometric-formulas/#circle-operations","title":"Circle Operations","text":""},{"location":"math/geometric-formulas/#circle-area-and-circumference","title":"Circle Area and Circumference","text":"<p>Problem: Calculate area and circumference of a circle.</p> <p>Sample Input: <code>radius = 5</code></p> <p>Sample Output:  - Area: <code>78.54</code> - Circumference: <code>31.42</code></p> <pre><code>struct Circle {\n    Point2D center;\n    double radius;\n\n    Circle(Point2D center, double radius) : center(center), radius(radius) {}\n\n    double area() const {\n        return M_PI * radius * radius;\n    }\n\n    double circumference() const {\n        return 2 * M_PI * radius;\n    }\n\n    // Check if point is inside circle\n    bool contains(const Point2D&amp; point) const {\n        return center.distanceTo(point) &lt;= radius;\n    }\n};\n</code></pre>"},{"location":"math/geometric-formulas/#circle-circle-intersection","title":"Circle-Circle Intersection","text":"<p>Problem: Check if two circles intersect and find intersection points.</p> <p>Sample Input:  - Circle 1: center <code>(0, 0)</code>, radius <code>3</code> - Circle 2: center <code>(4, 0)</code>, radius <code>2</code></p> <p>Sample Output: <code>true</code> (circles intersect)</p> <pre><code>bool circlesIntersect(const Circle&amp; c1, const Circle&amp; c2) {\n    double distance = c1.center.distanceTo(c2.center);\n    return distance &lt;= (c1.radius + c2.radius) &amp;&amp; \n           distance &gt;= abs(c1.radius - c2.radius);\n}\n\nvector&lt;Point2D&gt; circleIntersectionPoints(const Circle&amp; c1, const Circle&amp; c2) {\n    vector&lt;Point2D&gt; points;\n    double d = c1.center.distanceTo(c2.center);\n\n    if (d &gt; c1.radius + c2.radius || d &lt; abs(c1.radius - c2.radius)) {\n        return points; // No intersection\n    }\n\n    if (d == 0 &amp;&amp; c1.radius == c2.radius) {\n        return points; // Infinite intersections\n    }\n\n    double a = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);\n    double h = sqrt(c1.radius * c1.radius - a * a);\n\n    Point2D p2 = Point2D(\n        c1.center.x + a * (c2.center.x - c1.center.x) / d,\n        c1.center.y + a * (c2.center.y - c1.center.y) / d\n    );\n\n    points.push_back(Point2D(\n        p2.x + h * (c2.center.y - c1.center.y) / d,\n        p2.y - h * (c2.center.x - c1.center.x) / d\n    ));\n\n    points.push_back(Point2D(\n        p2.x - h * (c2.center.y - c1.center.y) / d,\n        p2.y + h * (c2.center.x - c1.center.x) / d\n    ));\n\n    return points;\n}\n</code></pre>"},{"location":"math/geometric-formulas/#polygon-operations","title":"Polygon Operations","text":""},{"location":"math/geometric-formulas/#polygon-area-shoelace-formula","title":"Polygon Area (Shoelace Formula)","text":"<p>Problem: Calculate the area of a polygon using the shoelace formula.</p> <p>Sample Input: <code>[(0,0), (4,0), (4,4), (0,4)]</code> (square)</p> <p>Sample Output: <code>16.0</code></p> <pre><code>double polygonArea(const vector&lt;Point2D&gt;&amp; vertices) {\n    int n = vertices.size();\n    if (n &lt; 3) return 0;\n\n    double area = 0;\n    for (int i = 0; i &lt; n; i++) {\n        int j = (i + 1) % n;\n        area += vertices[i].x * vertices[j].y;\n        area -= vertices[j].x * vertices[i].y;\n    }\n    return abs(area) / 2.0;\n}\n</code></pre>"},{"location":"math/geometric-formulas/#point-in-polygon-ray-casting","title":"Point in Polygon (Ray Casting)","text":"<p>Problem: Determine if a point is inside a polygon.</p> <p>Sample Input:  - Polygon: <code>[(0,0), (4,0), (4,4), (0,4)]</code> - Point: <code>(2, 2)</code></p> <p>Sample Output: <code>true</code> (point is inside)</p> <pre><code>bool pointInPolygon(const Point2D&amp; point, const vector&lt;Point2D&gt;&amp; polygon) {\n    int n = polygon.size();\n    bool inside = false;\n\n    for (int i = 0, j = n - 1; i &lt; n; j = i++) {\n        if (((polygon[i].y &gt; point.y) != (polygon[j].y &gt; point.y)) &amp;&amp;\n            (point.x &lt; (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / \n                      (polygon[j].y - polygon[i].y) + polygon[i].x)) {\n            inside = !inside;\n        }\n    }\n    return inside;\n}\n</code></pre>"},{"location":"math/geometric-formulas/#convex-hull-area","title":"Convex Hull Area","text":"<p>Problem: Calculate the area of a convex hull.</p> <p>Sample Input: <code>[(0,0), (2,0), (1,2), (0,1)]</code></p> <p>Sample Output: <code>2.5</code></p> <pre><code>double convexHullArea(const vector&lt;Point2D&gt;&amp; points) {\n    if (points.size() &lt; 3) return 0;\n\n    // Sort points by x-coordinate, then by y-coordinate\n    vector&lt;Point2D&gt; sortedPoints = points;\n    sort(sortedPoints.begin(), sortedPoints.end(), \n         [](const Point2D&amp; a, const Point2D&amp; b) {\n             return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);\n         });\n\n    // Build lower hull\n    vector&lt;Point2D&gt; hull;\n    for (const auto&amp; point : sortedPoints) {\n        while (hull.size() &gt;= 2 &amp;&amp; \n               crossProduct(hull[hull.size()-2], hull[hull.size()-1], point) &lt;= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(point);\n    }\n\n    // Build upper hull\n    int lowerSize = hull.size();\n    for (int i = sortedPoints.size() - 2; i &gt;= 0; i--) {\n        while (hull.size() &gt; lowerSize &amp;&amp; \n               crossProduct(hull[hull.size()-2], hull[hull.size()-1], sortedPoints[i]) &lt;= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(sortedPoints[i]);\n    }\n\n    return polygonArea(hull);\n}\n\n// Helper function for cross product\ndouble crossProduct(const Point2D&amp; O, const Point2D&amp; A, const Point2D&amp; B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n</code></pre>"},{"location":"math/geometric-formulas/#3d-geometry","title":"3D Geometry","text":""},{"location":"math/geometric-formulas/#3d-distance-and-midpoint","title":"3D Distance and Midpoint","text":"<p>Problem: Calculate distance and midpoint in 3D space.</p> <p>Sample Input: <code>P1(0, 0, 0)</code>, <code>P2(3, 4, 5)</code></p> <p>Sample Output:  - Distance: <code>7.071</code> (\u221a(3\u00b2 + 4\u00b2 + 5\u00b2) = \u221a50) - Midpoint: <code>(1.5, 2, 2.5)</code></p> <pre><code>struct Point3D {\n    double x, y, z;\n    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}\n\n    double distanceTo(const Point3D&amp; other) const {\n        return sqrt((x - other.x) * (x - other.x) + \n                   (y - other.y) * (y - other.y) + \n                   (z - other.z) * (z - other.z));\n    }\n\n    Point3D midpoint(const Point3D&amp; other) const {\n        return Point3D((x + other.x) / 2, (y + other.y) / 2, (z + other.z) / 2);\n    }\n};\n</code></pre>"},{"location":"math/geometric-formulas/#sphere-volume-and-surface-area","title":"Sphere Volume and Surface Area","text":"<p>Problem: Calculate volume and surface area of a sphere.</p> <p>Sample Input: <code>radius = 3</code></p> <p>Sample Output:  - Volume: <code>113.10</code> - Surface Area: <code>113.10</code></p> <pre><code>struct Sphere {\n    Point3D center;\n    double radius;\n\n    Sphere(Point3D center, double radius) : center(center), radius(radius) {}\n\n    double volume() const {\n        return (4.0 / 3.0) * M_PI * radius * radius * radius;\n    }\n\n    double surfaceArea() const {\n        return 4 * M_PI * radius * radius;\n    }\n};\n</code></pre>"},{"location":"math/geometric-formulas/#common-geometric-formulas","title":"Common Geometric Formulas","text":""},{"location":"math/geometric-formulas/#triangle-area-herons-formula","title":"Triangle Area (Heron's Formula)","text":"<p>Problem: Calculate triangle area using side lengths.</p> <p>Sample Input: <code>a = 3, b = 4, c = 5</code></p> <p>Sample Output: <code>6.0</code></p> <pre><code>double triangleArea(double a, double b, double c) {\n    double s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n</code></pre>"},{"location":"math/geometric-formulas/#triangle-area-cross-product","title":"Triangle Area (Cross Product)","text":"<p>Problem: Calculate triangle area using coordinates.</p> <p>Sample Input: <code>A(0,0), B(3,0), C(0,4)</code></p> <p>Sample Output: <code>6.0</code></p> <pre><code>double triangleArea(const Point2D&amp; A, const Point2D&amp; B, const Point2D&amp; C) {\n    return abs((B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y)) / 2.0;\n}\n</code></pre>"},{"location":"math/geometric-formulas/#angle-between-vectors","title":"Angle Between Vectors","text":"<p>Problem: Calculate the angle between two vectors.</p> <p>Sample Input: <code>v1(1,0), v2(0,1)</code></p> <p>Sample Output: <code>90\u00b0</code> (\u03c0/2 radians)</p> <pre><code>double angleBetweenVectors(const Point2D&amp; v1, const Point2D&amp; v2) {\n    double dot = v1.x * v2.x + v1.y * v2.y;\n    double mag1 = sqrt(v1.x * v1.x + v1.y * v1.y);\n    double mag2 = sqrt(v2.x * v2.x + v2.y * v2.y);\n\n    double cosAngle = dot / (mag1 * mag2);\n    return acos(max(-1.0, min(1.0, cosAngle))); // Clamp to avoid numerical errors\n}\n</code></pre>"},{"location":"math/geometric-formulas/#use-cases","title":"Use Cases","text":""},{"location":"math/geometric-formulas/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>Geometry Problems: Distance, area, intersection calculations</li> <li>Convex Hull: Finding the minimal convex polygon</li> <li>Closest Pair: Finding the closest pair of points</li> <li>Line Intersection: Determining if lines intersect</li> </ul>"},{"location":"math/geometric-formulas/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Computer Graphics: Rendering and transformations</li> <li>Robotics: Path planning and obstacle avoidance</li> <li>GIS: Geographic information systems</li> <li>Game Development: Collision detection and physics</li> </ul>"},{"location":"math/geometric-formulas/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Precision: Use <code>double</code> for most calculations, <code>long double</code> for high precision</li> <li>Epsilon: Use small epsilon values (1e-9) for floating-point comparisons</li> <li>Edge Cases: Handle parallel lines, collinear points, and degenerate cases</li> <li>Coordinate Systems: Choose appropriate coordinate systems for the problem</li> <li>Numerical Stability: Use stable algorithms to avoid precision errors</li> <li>Integer Coordinates: Use integer arithmetic when possible to avoid floating-point errors</li> </ol>"},{"location":"math/linear-algebra/","title":"Linear Algebra","text":"<p>Essential linear algebra concepts including matrix operations, determinants, eigenvalues, and vector calculations commonly used in computer graphics, machine learning, and scientific computing.</p>"},{"location":"math/linear-algebra/#vector-operations","title":"Vector Operations","text":""},{"location":"math/linear-algebra/#basic-vector-operations","title":"Basic Vector Operations","text":"<p>Problem: Perform basic vector operations (addition, subtraction, scalar multiplication).</p> <p>Sample Input:  - <code>v1 = [1, 2, 3]</code> - <code>v2 = [4, 5, 6]</code> - <code>scalar = 2</code></p> <p>Sample Output:  - <code>v1 + v2 = [5, 7, 9]</code> - <code>v1 - v2 = [-3, -3, -3]</code> - <code>2 * v1 = [2, 4, 6]</code></p> <pre><code>#include &lt;vector&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nclass Vector {\nprivate:\n    vector&lt;double&gt; data;\n\npublic:\n    Vector(const vector&lt;double&gt;&amp; values) : data(values) {}\n\n    Vector(int size, double value = 0) : data(size, value) {}\n\n    int size() const { return data.size(); }\n\n    double&amp; operator[](int index) { return data[index]; }\n    const double&amp; operator[](int index) const { return data[index]; }\n\n    // Vector addition\n    Vector operator+(const Vector&amp; other) const {\n        Vector result(data.size());\n        for (int i = 0; i &lt; data.size(); i++) {\n            result[i] = data[i] + other[i];\n        }\n        return result;\n    }\n\n    // Vector subtraction\n    Vector operator-(const Vector&amp; other) const {\n        Vector result(data.size());\n        for (int i = 0; i &lt; data.size(); i++) {\n            result[i] = data[i] - other[i];\n        }\n        return result;\n    }\n\n    // Scalar multiplication\n    Vector operator*(double scalar) const {\n        Vector result(data.size());\n        for (int i = 0; i &lt; data.size(); i++) {\n            result[i] = data[i] * scalar;\n        }\n        return result;\n    }\n\n    // Dot product\n    double dot(const Vector&amp; other) const {\n        double result = 0;\n        for (int i = 0; i &lt; data.size(); i++) {\n            result += data[i] * other[i];\n        }\n        return result;\n    }\n\n    // Cross product (3D only)\n    Vector cross(const Vector&amp; other) const {\n        if (data.size() != 3 || other.size() != 3) {\n            throw invalid_argument(\"Cross product only defined for 3D vectors\");\n        }\n\n        return Vector({\n            data[1] * other[2] - data[2] * other[1],\n            data[2] * other[0] - data[0] * other[2],\n            data[0] * other[1] - data[1] * other[0]\n        });\n    }\n\n    // Vector magnitude\n    double magnitude() const {\n        double sum = 0;\n        for (double value : data) {\n            sum += value * value;\n        }\n        return sqrt(sum);\n    }\n\n    // Normalize vector\n    Vector normalize() const {\n        double mag = magnitude();\n        if (mag == 0) return *this;\n        return *this * (1.0 / mag);\n    }\n};\n</code></pre>"},{"location":"math/linear-algebra/#vector-projection","title":"Vector Projection","text":"<p>Problem: Project one vector onto another.</p> <p>Sample Input:  - <code>v = [3, 4, 0]</code> - <code>u = [1, 0, 0]</code></p> <p>Sample Output:  - Projection: <code>[3, 0, 0]</code> - Scalar projection: <code>3.0</code></p> <pre><code>// Project vector v onto vector u\nVector project(const Vector&amp; v, const Vector&amp; u) {\n    double scalar = v.dot(u) / u.dot(u);\n    return u * scalar;\n}\n\n// Scalar projection of v onto u\ndouble scalarProjection(const Vector&amp; v, const Vector&amp; u) {\n    return v.dot(u) / u.magnitude();\n}\n</code></pre>"},{"location":"math/linear-algebra/#matrix-operations","title":"Matrix Operations","text":""},{"location":"math/linear-algebra/#basic-matrix-operations","title":"Basic Matrix Operations","text":"<p>Problem: Perform basic matrix operations (addition, subtraction, multiplication).</p> <p>Sample Input:  - <code>A = [[1, 2], [3, 4]]</code> - <code>B = [[5, 6], [7, 8]]</code></p> <p>Sample Output:  - <code>A + B = [[6, 8], [10, 12]]</code> - <code>A * B = [[19, 22], [43, 50]]</code></p> <pre><code>class Matrix {\nprivate:\n    vector&lt;vector&lt;double&gt;&gt; data;\n    int rows, cols;\n\npublic:\n    Matrix(int rows, int cols, double value = 0) : rows(rows), cols(cols) {\n        data.resize(rows, vector&lt;double&gt;(cols, value));\n    }\n\n    Matrix(const vector&lt;vector&lt;double&gt;&gt;&amp; values) : data(values) {\n        rows = values.size();\n        cols = values[0].size();\n    }\n\n    int getRows() const { return rows; }\n    int getCols() const { return cols; }\n\n    vector&lt;double&gt;&amp; operator[](int index) { return data[index]; }\n    const vector&lt;double&gt;&amp; operator[](int index) const { return data[index]; }\n\n    // Matrix addition\n    Matrix operator+(const Matrix&amp; other) const {\n        Matrix result(rows, cols);\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                result[i][j] = data[i][j] + other[i][j];\n            }\n        }\n        return result;\n    }\n\n    // Matrix subtraction\n    Matrix operator-(const Matrix&amp; other) const {\n        Matrix result(rows, cols);\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                result[i][j] = data[i][j] - other[i][j];\n            }\n        }\n        return result;\n    }\n\n    // Matrix multiplication\n    Matrix operator*(const Matrix&amp; other) const {\n        if (cols != other.rows) {\n            throw invalid_argument(\"Matrix dimensions don't match for multiplication\");\n        }\n\n        Matrix result(rows, other.cols);\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; other.cols; j++) {\n                for (int k = 0; k &lt; cols; k++) {\n                    result[i][j] += data[i][k] * other[k][j];\n                }\n            }\n        }\n        return result;\n    }\n\n    // Scalar multiplication\n    Matrix operator*(double scalar) const {\n        Matrix result(rows, cols);\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                result[i][j] = data[i][j] * scalar;\n            }\n        }\n        return result;\n    }\n\n    // Matrix-vector multiplication\n    Vector operator*(const Vector&amp; v) const {\n        if (cols != v.size()) {\n            throw invalid_argument(\"Matrix and vector dimensions don't match\");\n        }\n\n        Vector result(rows);\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                result[i] += data[i][j] * v[j];\n            }\n        }\n        return result;\n    }\n};\n</code></pre>"},{"location":"math/linear-algebra/#matrix-transpose","title":"Matrix Transpose","text":"<p>Problem: Calculate the transpose of a matrix.</p> <p>Sample Input: <code>A = [[1, 2, 3], [4, 5, 6]]</code></p> <p>Sample Output: <code>A^T = [[1, 4], [2, 5], [3, 6]]</code></p> <pre><code>Matrix transpose() const {\n    Matrix result(cols, rows);\n    for (int i = 0; i &lt; rows; i++) {\n        for (int j = 0; j &lt; cols; j++) {\n            result[j][i] = data[i][j];\n        }\n    }\n    return result;\n}\n</code></pre>"},{"location":"math/linear-algebra/#determinants","title":"Determinants","text":""},{"location":"math/linear-algebra/#2x2-determinant","title":"2x2 Determinant","text":"<p>Problem: Calculate the determinant of a 2x2 matrix.</p> <p>Sample Input: <code>A = [[1, 2], [3, 4]]</code></p> <p>Sample Output: <code>-2</code> (1\u00d74 - 2\u00d73 = -2)</p> <pre><code>double determinant2x2(const Matrix&amp; A) {\n    if (A.getRows() != 2 || A.getCols() != 2) {\n        throw invalid_argument(\"Matrix must be 2x2\");\n    }\n    return A[0][0] * A[1][1] - A[0][1] * A[1][0];\n}\n</code></pre>"},{"location":"math/linear-algebra/#3x3-determinant","title":"3x3 Determinant","text":"<p>Problem: Calculate the determinant of a 3x3 matrix.</p> <p>Sample Input: <code>A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code></p> <p>Sample Output: <code>0</code> (matrix is singular)</p> <pre><code>double determinant3x3(const Matrix&amp; A) {\n    if (A.getRows() != 3 || A.getCols() != 3) {\n        throw invalid_argument(\"Matrix must be 3x3\");\n    }\n\n    return A[0][0] * (A[1][1] * A[2][2] - A[1][2] * A[2][1]) -\n           A[0][1] * (A[1][0] * A[2][2] - A[1][2] * A[2][0]) +\n           A[0][2] * (A[1][0] * A[2][1] - A[1][1] * A[2][0]);\n}\n</code></pre>"},{"location":"math/linear-algebra/#general-determinant-laplace-expansion","title":"General Determinant (Laplace Expansion)","text":"<p>Problem: Calculate the determinant of any square matrix.</p> <p>Sample Input: <code>A = [[2, 1, 0], [0, 3, 1], [1, 0, 2]]</code></p> <p>Sample Output: <code>11</code></p> <pre><code>double determinant(const Matrix&amp; A) {\n    if (A.getRows() != A.getCols()) {\n        throw invalid_argument(\"Matrix must be square\");\n    }\n\n    int n = A.getRows();\n    if (n == 1) return A[0][0];\n    if (n == 2) return determinant2x2(A);\n\n    double det = 0;\n    for (int j = 0; j &lt; n; j++) {\n        Matrix minor = getMinor(A, 0, j);\n        double cofactor = pow(-1, j) * determinant(minor);\n        det += A[0][j] * cofactor;\n    }\n\n    return det;\n}\n\n// Helper function to get minor matrix\nMatrix getMinor(const Matrix&amp; A, int row, int col) {\n    int n = A.getRows();\n    Matrix minor(n - 1, n - 1);\n\n    int minorRow = 0;\n    for (int i = 0; i &lt; n; i++) {\n        if (i == row) continue;\n        int minorCol = 0;\n        for (int j = 0; j &lt; n; j++) {\n            if (j == col) continue;\n            minor[minorRow][minorCol] = A[i][j];\n            minorCol++;\n        }\n        minorRow++;\n    }\n\n    return minor;\n}\n</code></pre>"},{"location":"math/linear-algebra/#matrix-inversion","title":"Matrix Inversion","text":""},{"location":"math/linear-algebra/#2x2-matrix-inversion","title":"2x2 Matrix Inversion","text":"<p>Problem: Calculate the inverse of a 2x2 matrix.</p> <p>Sample Input: <code>A = [[1, 2], [3, 4]]</code></p> <p>Sample Output: <code>A^(-1) = [[-2, 1], [1.5, -0.5]]</code></p> <pre><code>Matrix inverse2x2(const Matrix&amp; A) {\n    if (A.getRows() != 2 || A.getCols() != 2) {\n        throw invalid_argument(\"Matrix must be 2x2\");\n    }\n\n    double det = determinant2x2(A);\n    if (abs(det) &lt; 1e-9) {\n        throw invalid_argument(\"Matrix is singular (determinant is zero)\");\n    }\n\n    Matrix result(2, 2);\n    result[0][0] = A[1][1] / det;\n    result[0][1] = -A[0][1] / det;\n    result[1][0] = -A[1][0] / det;\n    result[1][1] = A[0][0] / det;\n\n    return result;\n}\n</code></pre>"},{"location":"math/linear-algebra/#general-matrix-inversion-gaussian-elimination","title":"General Matrix Inversion (Gaussian Elimination)","text":"<p>Problem: Calculate the inverse of any square matrix.</p> <p>Sample Input: <code>A = [[2, 1], [1, 1]]</code></p> <p>Sample Output: <code>A^(-1) = [[1, -1], [-1, 2]]</code></p> <pre><code>Matrix inverse(const Matrix&amp; A) {\n    if (A.getRows() != A.getCols()) {\n        throw invalid_argument(\"Matrix must be square\");\n    }\n\n    int n = A.getRows();\n    Matrix augmented(n, 2 * n);\n\n    // Create augmented matrix [A | I]\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            augmented[i][j] = A[i][j];\n        }\n        augmented[i][i + n] = 1;\n    }\n\n    // Gaussian elimination\n    for (int i = 0; i &lt; n; i++) {\n        // Find pivot\n        int maxRow = i;\n        for (int k = i + 1; k &lt; n; k++) {\n            if (abs(augmented[k][i]) &gt; abs(augmented[maxRow][i])) {\n                maxRow = k;\n            }\n        }\n\n        // Swap rows\n        if (maxRow != i) {\n            swap(augmented[i], augmented[maxRow]);\n        }\n\n        // Check for singular matrix\n        if (abs(augmented[i][i]) &lt; 1e-9) {\n            throw invalid_argument(\"Matrix is singular\");\n        }\n\n        // Make diagonal element 1\n        double pivot = augmented[i][i];\n        for (int j = 0; j &lt; 2 * n; j++) {\n            augmented[i][j] /= pivot;\n        }\n\n        // Eliminate column\n        for (int k = 0; k &lt; n; k++) {\n            if (k != i) {\n                double factor = augmented[k][i];\n                for (int j = 0; j &lt; 2 * n; j++) {\n                    augmented[k][j] -= factor * augmented[i][j];\n                }\n            }\n        }\n    }\n\n    // Extract inverse matrix\n    Matrix result(n, n);\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            result[i][j] = augmented[i][j + n];\n        }\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"math/linear-algebra/#eigenvalues-and-eigenvectors","title":"Eigenvalues and Eigenvectors","text":""},{"location":"math/linear-algebra/#power-method-for-eigenvalues","title":"Power Method for Eigenvalues","text":"<p>Problem: Find the largest eigenvalue of a matrix.</p> <p>Sample Input: <code>A = [[2, 1], [1, 2]]</code></p> <p>Sample Output: <code>3.0</code> (largest eigenvalue)</p> <pre><code>double powerMethod(const Matrix&amp; A, int maxIterations = 100) {\n    if (A.getRows() != A.getCols()) {\n        throw invalid_argument(\"Matrix must be square\");\n    }\n\n    int n = A.getRows();\n    Vector x(n, 1.0); // Initial guess\n\n    for (int iter = 0; iter &lt; maxIterations; iter++) {\n        Vector y = A * x;\n        double norm = y.magnitude();\n\n        if (norm &lt; 1e-9) break;\n\n        x = y * (1.0 / norm);\n    }\n\n    Vector Ax = A * x;\n    return x.dot(Ax) / x.dot(x);\n}\n</code></pre>"},{"location":"math/linear-algebra/#qr-algorithm-for-all-eigenvalues","title":"QR Algorithm for All Eigenvalues","text":"<p>Problem: Find all eigenvalues of a matrix.</p> <p>Sample Input: <code>A = [[2, 1], [1, 2]]</code></p> <p>Sample Output: <code>[1.0, 3.0]</code> (eigenvalues)</p> <pre><code>vector&lt;double&gt; qrAlgorithm(const Matrix&amp; A, int maxIterations = 100) {\n    if (A.getRows() != A.getCols()) {\n        throw invalid_argument(\"Matrix must be square\");\n    }\n\n    int n = A.getRows();\n    Matrix Q(n, n), R(n, n);\n    Matrix Ak = A;\n\n    for (int iter = 0; iter &lt; maxIterations; iter++) {\n        // QR decomposition\n        qrDecomposition(Ak, Q, R);\n\n        // Update Ak = R * Q\n        Ak = R * Q;\n    }\n\n    // Extract eigenvalues from diagonal\n    vector&lt;double&gt; eigenvalues;\n    for (int i = 0; i &lt; n; i++) {\n        eigenvalues.push_back(Ak[i][i]);\n    }\n\n    return eigenvalues;\n}\n\n// QR decomposition using Gram-Schmidt\nvoid qrDecomposition(const Matrix&amp; A, Matrix&amp; Q, Matrix&amp; R) {\n    int n = A.getRows();\n    Q = Matrix(n, n);\n    R = Matrix(n, n);\n\n    for (int j = 0; j &lt; n; j++) {\n        Vector v(n);\n        for (int i = 0; i &lt; n; i++) {\n            v[i] = A[i][j];\n        }\n\n        for (int k = 0; k &lt; j; k++) {\n            Vector qk(n);\n            for (int i = 0; i &lt; n; i++) {\n                qk[i] = Q[i][k];\n            }\n            R[k][j] = v.dot(qk);\n            v = v - qk * R[k][j];\n        }\n\n        R[j][j] = v.magnitude();\n        if (R[j][j] &gt; 1e-9) {\n            Vector qj = v * (1.0 / R[j][j]);\n            for (int i = 0; i &lt; n; i++) {\n                Q[i][j] = qj[i];\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"math/linear-algebra/#linear-systems","title":"Linear Systems","text":""},{"location":"math/linear-algebra/#gaussian-elimination","title":"Gaussian Elimination","text":"<p>Problem: Solve a system of linear equations.</p> <p>Sample Input:  - <code>2x + y = 5</code> - <code>x + 2y = 4</code></p> <p>Sample Output: <code>x = 2, y = 1</code></p> <pre><code>Vector solveLinearSystem(const Matrix&amp; A, const Vector&amp; b) {\n    if (A.getRows() != A.getCols() || A.getRows() != b.size()) {\n        throw invalid_argument(\"Matrix and vector dimensions don't match\");\n    }\n\n    int n = A.getRows();\n    Matrix augmented(n, n + 1);\n\n    // Create augmented matrix [A | b]\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            augmented[i][j] = A[i][j];\n        }\n        augmented[i][n] = b[i];\n    }\n\n    // Forward elimination\n    for (int i = 0; i &lt; n; i++) {\n        // Find pivot\n        int maxRow = i;\n        for (int k = i + 1; k &lt; n; k++) {\n            if (abs(augmented[k][i]) &gt; abs(augmented[maxRow][i])) {\n                maxRow = k;\n            }\n        }\n\n        // Swap rows\n        if (maxRow != i) {\n            swap(augmented[i], augmented[maxRow]);\n        }\n\n        // Check for singular system\n        if (abs(augmented[i][i]) &lt; 1e-9) {\n            throw invalid_argument(\"System is singular\");\n        }\n\n        // Eliminate column\n        for (int k = i + 1; k &lt; n; k++) {\n            double factor = augmented[k][i] / augmented[i][i];\n            for (int j = i; j &lt;= n; j++) {\n                augmented[k][j] -= factor * augmented[i][j];\n            }\n        }\n    }\n\n    // Back substitution\n    Vector x(n);\n    for (int i = n - 1; i &gt;= 0; i--) {\n        x[i] = augmented[i][n];\n        for (int j = i + 1; j &lt; n; j++) {\n            x[i] -= augmented[i][j] * x[j];\n        }\n        x[i] /= augmented[i][i];\n    }\n\n    return x;\n}\n</code></pre>"},{"location":"math/linear-algebra/#use-cases","title":"Use Cases","text":""},{"location":"math/linear-algebra/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>Matrix Exponentiation: Fast computation of matrix powers</li> <li>Linear Systems: Solving systems of equations</li> <li>Graph Algorithms: Adjacency matrix operations</li> <li>Geometric Transformations: Rotation, scaling, translation</li> </ul>"},{"location":"math/linear-algebra/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Computer Graphics: 3D transformations, projections</li> <li>Machine Learning: Neural networks, dimensionality reduction</li> <li>Scientific Computing: Numerical analysis, simulations</li> <li>Cryptography: Matrix-based encryption schemes</li> </ul>"},{"location":"math/linear-algebra/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Numerical Stability: Use pivoting in Gaussian elimination</li> <li>Precision: Be careful with floating-point precision</li> <li>Efficiency: Use optimized algorithms for large matrices</li> <li>Memory Management: Consider sparse matrices for large problems</li> <li>Error Handling: Check for singular matrices and invalid operations</li> <li>Library Usage: Use optimized libraries like BLAS/LAPACK for production code</li> </ol>"},{"location":"math/number-theory/","title":"Number Theory","text":"<p>Essential number theory concepts including prime numbers, modular arithmetic, GCD, LCM, and divisibility rules commonly used in competitive programming and cryptographic applications.</p>"},{"location":"math/number-theory/#prime-numbers","title":"Prime Numbers","text":""},{"location":"math/number-theory/#prime-checking","title":"Prime Checking","text":"<p>Problem: Check if a number is prime.</p> <p>Sample Input: <code>n = 17</code></p> <p>Sample Output: <code>true</code> (17 is prime)</p> <pre><code>#include &lt;cmath&gt;\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n &lt;= 1) return false;\n    if (n &lt;= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i &lt;= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// For very large numbers (probabilistic)\nbool isPrimeMillerRabin(long long n, int k = 5) {\n    if (n &lt;= 1 || n == 4) return false;\n    if (n &lt;= 3) return true;\n\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n\n    for (int i = 0; i &lt; k; i++) {\n        long long a = 2 + rand() % (n - 4);\n        long long x = modExp(a, d, n);\n\n        if (x == 1 || x == n - 1) continue;\n\n        bool composite = true;\n        for (int j = 0; j &lt; d - 1; j++) {\n            x = (x * x) % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) return false;\n    }\n    return true;\n}\n</code></pre>"},{"location":"math/number-theory/#sieve-of-eratosthenes","title":"Sieve of Eratosthenes","text":"<p>Problem: Find all prime numbers up to n.</p> <p>Sample Input: <code>n = 20</code></p> <p>Sample Output: <code>[2, 3, 5, 7, 11, 13, 17, 19]</code></p> <pre><code>vector&lt;int&gt; sieveOfEratosthenes(int n) {\n    vector&lt;bool&gt; isPrime(n + 1, true);\n    isPrime[0] = isPrime[1] = false;\n\n    for (int i = 2; i * i &lt;= n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j &lt;= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\n    vector&lt;int&gt; primes;\n    for (int i = 2; i &lt;= n; i++) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Segmented sieve for large ranges\nvector&lt;long long&gt; segmentedSieve(long long L, long long R) {\n    int limit = sqrt(R);\n    vector&lt;bool&gt; isPrime(limit + 1, true);\n    vector&lt;int&gt; primes;\n\n    // Generate primes up to sqrt(R)\n    for (int i = 2; i &lt;= limit; i++) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j &lt;= limit; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\n    vector&lt;bool&gt; isPrimeRange(R - L + 1, true);\n    for (int prime : primes) {\n        long long start = max((long long)prime * prime, (L + prime - 1) / prime * prime);\n        for (long long j = start; j &lt;= R; j += prime) {\n            isPrimeRange[j - L] = false;\n        }\n    }\n\n    vector&lt;long long&gt; result;\n    for (long long i = L; i &lt;= R; i++) {\n        if (isPrimeRange[i - L]) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"math/number-theory/#prime-factorization","title":"Prime Factorization","text":"<p>Problem: Factorize a number into its prime factors.</p> <p>Sample Input: <code>n = 60</code></p> <p>Sample Output: <code>[(2, 2), (3, 1), (5, 1)]</code> (60 = 2\u00b2 \u00d7 3\u00b9 \u00d7 5\u00b9)</p> <pre><code>vector&lt;pair&lt;int, int&gt;&gt; primeFactorization(int n) {\n    vector&lt;pair&lt;int, int&gt;&gt; factors;\n\n    for (int i = 2; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            int count = 0;\n            while (n % i == 0) {\n                n /= i;\n                count++;\n            }\n            factors.push_back({i, count});\n        }\n    }\n\n    if (n &gt; 1) {\n        factors.push_back({n, 1});\n    }\n\n    return factors;\n}\n\n// Using precomputed primes\nvector&lt;pair&lt;int, int&gt;&gt; primeFactorizationWithPrimes(int n, const vector&lt;int&gt;&amp; primes) {\n    vector&lt;pair&lt;int, int&gt;&gt; factors;\n\n    for (int prime : primes) {\n        if (prime * prime &gt; n) break;\n        if (n % prime == 0) {\n            int count = 0;\n            while (n % prime == 0) {\n                n /= prime;\n                count++;\n            }\n            factors.push_back({prime, count});\n        }\n    }\n\n    if (n &gt; 1) {\n        factors.push_back({n, 1});\n    }\n\n    return factors;\n}\n</code></pre>"},{"location":"math/number-theory/#greatest-common-divisor-gcd","title":"Greatest Common Divisor (GCD)","text":""},{"location":"math/number-theory/#euclidean-algorithm","title":"Euclidean Algorithm","text":"<p>Problem: Find the GCD of two numbers.</p> <p>Sample Input: <code>a = 48, b = 18</code></p> <p>Sample Output: <code>6</code> (GCD(48, 18) = 6)</p> <pre><code>int gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Recursive version\nint gcdRecursive(int a, int b) {\n    if (b == 0) return a;\n    return gcdRecursive(b, a % b);\n}\n\n// Extended Euclidean Algorithm\nint extendedGcd(int a, int b, int&amp; x, int&amp; y) {\n    if (a == 0) {\n        x = 0; y = 1;\n        return b;\n    }\n\n    int x1, y1;\n    int gcd = extendedGcd(b % a, a, x1, y1);\n\n    x = y1 - (b / a) * x1;\n    y = x1;\n\n    return gcd;\n}\n</code></pre>"},{"location":"math/number-theory/#least-common-multiple-lcm","title":"Least Common Multiple (LCM)","text":"<p>Problem: Find the LCM of two numbers.</p> <p>Sample Input: <code>a = 12, b = 18</code></p> <p>Sample Output: <code>36</code> (LCM(12, 18) = 36)</p> <pre><code>int lcm(int a, int b) {\n    return (a / gcd(a, b)) * b;\n}\n\n// For multiple numbers\nint lcmMultiple(const vector&lt;int&gt;&amp; numbers) {\n    int result = numbers[0];\n    for (int i = 1; i &lt; numbers.size(); i++) {\n        result = lcm(result, numbers[i]);\n    }\n    return result;\n}\n</code></pre>"},{"location":"math/number-theory/#modular-arithmetic","title":"Modular Arithmetic","text":""},{"location":"math/number-theory/#modular-exponentiation","title":"Modular Exponentiation","text":"<p>Problem: Calculate (a^b) mod m efficiently.</p> <p>Sample Input: <code>a = 2, b = 10, m = 1000</code></p> <p>Sample Output: <code>24</code> (2^10 mod 1000 = 1024 mod 1000 = 24)</p> <pre><code>long long modExp(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base %= mod;\n\n    while (exp &gt; 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        exp &gt;&gt;= 1;\n        base = (base * base) % mod;\n    }\n\n    return result;\n}\n\n// Modular multiplication to prevent overflow\nlong long modMul(long long a, long long b, long long mod) {\n    return ((a % mod) * (b % mod)) % mod;\n}\n\n// Modular addition\nlong long modAdd(long long a, long long b, long long mod) {\n    return ((a % mod) + (b % mod)) % mod;\n}\n\n// Modular subtraction\nlong long modSub(long long a, long long b, long long mod) {\n    return ((a % mod) - (b % mod) + mod) % mod;\n}\n</code></pre>"},{"location":"math/number-theory/#modular-inverse","title":"Modular Inverse","text":"<p>Problem: Find the modular inverse of a number.</p> <p>Sample Input: <code>a = 3, m = 11</code></p> <p>Sample Output: <code>4</code> (3 \u00d7 4 \u2261 1 (mod 11))</p> <pre><code>long long modInverse(long long a, long long m) {\n    int x, y;\n    int g = extendedGcd(a, m, x, y);\n\n    if (g != 1) {\n        return -1; // No inverse exists\n    }\n\n    return (x % m + m) % m;\n}\n\n// Using Fermat's Little Theorem (when m is prime)\nlong long modInverseFermat(long long a, long long m) {\n    return modExp(a, m - 2, m);\n}\n</code></pre>"},{"location":"math/number-theory/#chinese-remainder-theorem","title":"Chinese Remainder Theorem","text":"<p>Problem: Solve a system of congruences.</p> <p>Sample Input:  - x \u2261 2 (mod 3) - x \u2261 3 (mod 5) - x \u2261 2 (mod 7)</p> <p>Sample Output: <code>23</code> (x = 23)</p> <pre><code>long long chineseRemainderTheorem(const vector&lt;int&gt;&amp; remainders, const vector&lt;int&gt;&amp; moduli) {\n    int n = remainders.size();\n    long long product = 1;\n\n    for (int mod : moduli) {\n        product *= mod;\n    }\n\n    long long result = 0;\n    for (int i = 0; i &lt; n; i++) {\n        long long partialProduct = product / moduli[i];\n        long long inverse = modInverse(partialProduct, moduli[i]);\n        result += remainders[i] * partialProduct * inverse;\n    }\n\n    return result % product;\n}\n</code></pre>"},{"location":"math/number-theory/#divisibility-rules","title":"Divisibility Rules","text":""},{"location":"math/number-theory/#basic-divisibility","title":"Basic Divisibility","text":"<p>Problem: Check if a number is divisible by another.</p> <p>Sample Input: <code>n = 123456, d = 3</code></p> <p>Sample Output: <code>true</code> (123456 is divisible by 3)</p> <pre><code>bool isDivisible(int n, int d) {\n    return n % d == 0;\n}\n\n// Sum of digits divisible by 3\nbool isDivisibleBy3(int n) {\n    int sum = 0;\n    while (n &gt; 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum % 3 == 0;\n}\n\n// Last digit divisible by 2\nbool isDivisibleBy2(int n) {\n    return n % 2 == 0;\n}\n\n// Last two digits divisible by 4\nbool isDivisibleBy4(int n) {\n    return n % 4 == 0;\n}\n\n// Last three digits divisible by 8\nbool isDivisibleBy8(int n) {\n    return n % 8 == 0;\n}\n\n// Sum of digits divisible by 9\nbool isDivisibleBy9(int n) {\n    int sum = 0;\n    while (n &gt; 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum % 9 == 0;\n}\n</code></pre>"},{"location":"math/number-theory/#number-theory-functions","title":"Number Theory Functions","text":""},{"location":"math/number-theory/#eulers-totient-function","title":"Euler's Totient Function","text":"<p>Problem: Calculate \u03c6(n) - count of numbers less than n that are coprime to n.</p> <p>Sample Input: <code>n = 12</code></p> <p>Sample Output: <code>4</code> (\u03c6(12) = 4: 1, 5, 7, 11)</p> <pre><code>int eulerTotient(int n) {\n    int result = n;\n\n    for (int i = 2; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            while (n % i == 0) {\n                n /= i;\n            }\n            result -= result / i;\n        }\n    }\n\n    if (n &gt; 1) {\n        result -= result / n;\n    }\n\n    return result;\n}\n\n// Using prime factorization\nint eulerTotientWithFactors(const vector&lt;pair&lt;int, int&gt;&gt;&amp; factors) {\n    int result = 1;\n\n    for (const auto&amp; factor : factors) {\n        int p = factor.first;\n        int k = factor.second;\n        result *= (p - 1) * pow(p, k - 1);\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"math/number-theory/#mobius-function","title":"M\u00f6bius Function","text":"<p>Problem: Calculate \u03bc(n) - M\u00f6bius function.</p> <p>Sample Input: <code>n = 12</code></p> <p>Sample Output: <code>0</code> (\u03bc(12) = 0 because 12 has a squared factor)</p> <pre><code>int mobiusFunction(int n) {\n    if (n == 1) return 1;\n\n    int count = 0;\n    for (int i = 2; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            if (n % (i * i) == 0) return 0; // Has squared factor\n            count++;\n            n /= i;\n        }\n    }\n\n    if (n &gt; 1) count++;\n\n    return (count % 2 == 0) ? 1 : -1;\n}\n</code></pre>"},{"location":"math/number-theory/#divisor-functions","title":"Divisor Functions","text":"<p>Problem: Calculate number of divisors and sum of divisors.</p> <p>Sample Input: <code>n = 12</code></p> <p>Sample Output:  - Number of divisors: <code>6</code> (1, 2, 3, 4, 6, 12) - Sum of divisors: <code>28</code> (1 + 2 + 3 + 4 + 6 + 12 = 28)</p> <pre><code>int numberOfDivisors(int n) {\n    int count = 1;\n    auto factors = primeFactorization(n);\n\n    for (const auto&amp; factor : factors) {\n        count *= (factor.second + 1);\n    }\n\n    return count;\n}\n\nint sumOfDivisors(int n) {\n    int sum = 1;\n    auto factors = primeFactorization(n);\n\n    for (const auto&amp; factor : factors) {\n        int p = factor.first;\n        int k = factor.second;\n        sum *= (pow(p, k + 1) - 1) / (p - 1);\n    }\n\n    return sum;\n}\n\n// Generate all divisors\nvector&lt;int&gt; getAllDivisors(int n) {\n    vector&lt;int&gt; divisors;\n\n    for (int i = 1; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            divisors.push_back(i);\n            if (i != n / i) {\n                divisors.push_back(n / i);\n            }\n        }\n    }\n\n    sort(divisors.begin(), divisors.end());\n    return divisors;\n}\n</code></pre>"},{"location":"math/number-theory/#use-cases","title":"Use Cases","text":""},{"location":"math/number-theory/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>Prime Problems: Checking primality, factorization</li> <li>Modular Arithmetic: Large number calculations</li> <li>GCD/LCM: Finding common factors and multiples</li> <li>Number Theory: Solving mathematical problems</li> </ul>"},{"location":"math/number-theory/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Cryptography: RSA encryption, digital signatures</li> <li>Computer Science: Hash functions, random number generation</li> <li>Mathematics: Research in number theory</li> <li>Engineering: Error detection and correction codes</li> </ul>"},{"location":"math/number-theory/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Overflow Prevention: Use <code>long long</code> for large numbers</li> <li>Modular Arithmetic: Apply modulo at each step</li> <li>Precomputation: Use sieves for multiple queries</li> <li>Efficiency: Use efficient algorithms for large inputs</li> <li>Edge Cases: Handle n=0, n=1, and negative numbers</li> <li>Numerical Stability: Be careful with floating-point operations</li> </ol>"},{"location":"math/trigonometry/","title":"Trigonometry","text":"<p>Essential trigonometric functions, identities, and their applications in geometric problems, wave analysis, and coordinate transformations.</p>"},{"location":"math/trigonometry/#basic-trigonometric-functions","title":"Basic Trigonometric Functions","text":""},{"location":"math/trigonometry/#sine-cosine-and-tangent","title":"Sine, Cosine, and Tangent","text":"<p>Problem: Calculate basic trigonometric functions for given angles.</p> <p>Sample Input: <code>angle = 30\u00b0</code> (\u03c0/6 radians)</p> <p>Sample Output:  - <code>sin(30\u00b0) = 0.5</code> - <code>cos(30\u00b0) = 0.866</code> - <code>tan(30\u00b0) = 0.577</code></p> <pre><code>#include &lt;cmath&gt;\nusing namespace std;\n\n// Convert degrees to radians\ndouble degreesToRadians(double degrees) {\n    return degrees * M_PI / 180.0;\n}\n\n// Convert radians to degrees\ndouble radiansToDegrees(double radians) {\n    return radians * 180.0 / M_PI;\n}\n\n// Basic trigonometric functions\ndouble sine(double angle) {\n    return sin(angle);\n}\n\ndouble cosine(double angle) {\n    return cos(angle);\n}\n\ndouble tangent(double angle) {\n    return tan(angle);\n}\n\n// For degree input\ndouble sineDegrees(double degrees) {\n    return sin(degreesToRadians(degrees));\n}\n\ndouble cosineDegrees(double degrees) {\n    return cos(degreesToRadians(degrees));\n}\n\ndouble tangentDegrees(double degrees) {\n    return tan(degreesToRadians(degrees));\n}\n</code></pre>"},{"location":"math/trigonometry/#inverse-trigonometric-functions","title":"Inverse Trigonometric Functions","text":"<p>Problem: Calculate inverse trigonometric functions.</p> <p>Sample Input: <code>value = 0.5</code></p> <p>Sample Output:  - <code>arcsin(0.5) = 30\u00b0</code> (\u03c0/6 radians) - <code>arccos(0.5) = 60\u00b0</code> (\u03c0/3 radians) - <code>arctan(0.5) = 26.57\u00b0</code> (0.464 radians)</p> <pre><code>// Inverse trigonometric functions\ndouble arcsine(double value) {\n    return asin(value);\n}\n\ndouble arccosine(double value) {\n    return acos(value);\n}\n\ndouble arctangent(double value) {\n    return atan(value);\n}\n\n// Two-argument arctangent (atan2)\ndouble arctangent2(double y, double x) {\n    return atan2(y, x);\n}\n\n// For degree output\ndouble arcsineDegrees(double value) {\n    return radiansToDegrees(asin(value));\n}\n\ndouble arccosineDegrees(double value) {\n    return radiansToDegrees(acos(value));\n}\n\ndouble arctangentDegrees(double value) {\n    return radiansToDegrees(atan(value));\n}\n</code></pre>"},{"location":"math/trigonometry/#trigonometric-identities","title":"Trigonometric Identities","text":""},{"location":"math/trigonometry/#pythagorean-identities","title":"Pythagorean Identities","text":"<p>Problem: Verify Pythagorean identities.</p> <p>Sample Input: <code>angle = 45\u00b0</code></p> <p>Sample Output:  - <code>sin\u00b2(45\u00b0) + cos\u00b2(45\u00b0) = 1.0</code> - <code>1 + tan\u00b2(45\u00b0) = sec\u00b2(45\u00b0) = 2.0</code></p> <pre><code>// Pythagorean identities\nbool verifyPythagoreanIdentity(double angle) {\n    double sinVal = sin(angle);\n    double cosVal = cos(angle);\n    double result = sinVal * sinVal + cosVal * cosVal;\n    return abs(result - 1.0) &lt; 1e-9;\n}\n\n// Secant, cosecant, cotangent\ndouble secant(double angle) {\n    return 1.0 / cos(angle);\n}\n\ndouble cosecant(double angle) {\n    return 1.0 / sin(angle);\n}\n\ndouble cotangent(double angle) {\n    return 1.0 / tan(angle);\n}\n</code></pre>"},{"location":"math/trigonometry/#angle-sum-and-difference-identities","title":"Angle Sum and Difference Identities","text":"<p>Problem: Calculate trigonometric functions of sum and difference of angles.</p> <p>Sample Input: <code>a = 30\u00b0, b = 45\u00b0</code></p> <p>Sample Output:  - <code>sin(75\u00b0) = 0.966</code> (sin(30\u00b0 + 45\u00b0)) - <code>cos(15\u00b0) = 0.966</code> (cos(45\u00b0 - 30\u00b0))</p> <pre><code>// Angle sum identities\ndouble sinSum(double a, double b) {\n    return sin(a) * cos(b) + cos(a) * sin(b);\n}\n\ndouble cosSum(double a, double b) {\n    return cos(a) * cos(b) - sin(a) * sin(b);\n}\n\ndouble tanSum(double a, double b) {\n    return (tan(a) + tan(b)) / (1 - tan(a) * tan(b));\n}\n\n// Angle difference identities\ndouble sinDiff(double a, double b) {\n    return sin(a) * cos(b) - cos(a) * sin(b);\n}\n\ndouble cosDiff(double a, double b) {\n    return cos(a) * cos(b) + sin(a) * sin(b);\n}\n\ndouble tanDiff(double a, double b) {\n    return (tan(a) - tan(b)) / (1 + tan(a) * tan(b));\n}\n</code></pre>"},{"location":"math/trigonometry/#double-angle-identities","title":"Double Angle Identities","text":"<p>Problem: Calculate trigonometric functions of double angles.</p> <p>Sample Input: <code>angle = 30\u00b0</code></p> <p>Sample Output:  - <code>sin(60\u00b0) = 0.866</code> (sin(2 \u00d7 30\u00b0)) - <code>cos(60\u00b0) = 0.5</code> (cos(2 \u00d7 30\u00b0))</p> <pre><code>// Double angle identities\ndouble sinDouble(double angle) {\n    return 2 * sin(angle) * cos(angle);\n}\n\ndouble cosDouble(double angle) {\n    double cosVal = cos(angle);\n    return 2 * cosVal * cosVal - 1;\n}\n\ndouble tanDouble(double angle) {\n    double tanVal = tan(angle);\n    return 2 * tanVal / (1 - tanVal * tanVal);\n}\n</code></pre>"},{"location":"math/trigonometry/#half-angle-identities","title":"Half Angle Identities","text":"<p>Problem: Calculate trigonometric functions of half angles.</p> <p>Sample Input: <code>angle = 60\u00b0</code></p> <p>Sample Output:  - <code>sin(30\u00b0) = 0.5</code> (sin(60\u00b0/2)) - <code>cos(30\u00b0) = 0.866</code> (cos(60\u00b0/2))</p> <pre><code>// Half angle identities\ndouble sinHalf(double angle) {\n    return sqrt((1 - cos(angle)) / 2);\n}\n\ndouble cosHalf(double angle) {\n    return sqrt((1 + cos(angle)) / 2);\n}\n\ndouble tanHalf(double angle) {\n    return (1 - cos(angle)) / sin(angle);\n}\n</code></pre>"},{"location":"math/trigonometry/#triangle-calculations","title":"Triangle Calculations","text":""},{"location":"math/trigonometry/#law-of-sines","title":"Law of Sines","text":"<p>Problem: Solve triangle using Law of Sines.</p> <p>Sample Input: <code>a = 5, A = 30\u00b0, B = 45\u00b0</code></p> <p>Sample Output:  - <code>b = 7.071</code> (side opposite angle B) - <code>C = 105\u00b0</code> (remaining angle)</p> <pre><code>struct Triangle {\n    double a, b, c;  // Sides\n    double A, B, C;  // Angles (in radians)\n\n    Triangle(double a, double b, double c) : a(a), b(b), c(c) {\n        // Calculate angles using Law of Cosines\n        A = acos((b*b + c*c - a*a) / (2*b*c));\n        B = acos((a*a + c*c - b*b) / (2*a*c));\n        C = acos((a*a + b*b - c*c) / (2*a*b));\n    }\n\n    Triangle(double a, double A, double B) : a(a), A(A), B(B) {\n        C = M_PI - A - B;\n        b = a * sin(B) / sin(A);  // Law of Sines\n        c = a * sin(C) / sin(A);\n    }\n};\n\n// Law of Sines: a/sin(A) = b/sin(B) = c/sin(C)\ndouble lawOfSines(double a, double A, double B) {\n    return a * sin(B) / sin(A);\n}\n</code></pre>"},{"location":"math/trigonometry/#law-of-cosines","title":"Law of Cosines","text":"<p>Problem: Solve triangle using Law of Cosines.</p> <p>Sample Input: <code>a = 3, b = 4, C = 90\u00b0</code></p> <p>Sample Output:  - <code>c = 5.0</code> (hypotenuse)</p> <pre><code>// Law of Cosines: c\u00b2 = a\u00b2 + b\u00b2 - 2ab*cos(C)\ndouble lawOfCosines(double a, double b, double C) {\n    return sqrt(a*a + b*b - 2*a*b*cos(C));\n}\n\n// Calculate angle using Law of Cosines\ndouble lawOfCosinesAngle(double a, double b, double c) {\n    return acos((a*a + b*b - c*c) / (2*a*b));\n}\n</code></pre>"},{"location":"math/trigonometry/#triangle-area","title":"Triangle Area","text":"<p>Problem: Calculate triangle area using different methods.</p> <p>Sample Input: <code>a = 3, b = 4, C = 90\u00b0</code></p> <p>Sample Output:  - Area: <code>6.0</code> (using two sides and included angle)</p> <pre><code>// Area using two sides and included angle\ndouble triangleAreaSAS(double a, double b, double C) {\n    return 0.5 * a * b * sin(C);\n}\n\n// Area using three sides (Heron's formula)\ndouble triangleAreaSSS(double a, double b, double c) {\n    double s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// Area using base and height\ndouble triangleAreaBH(double base, double height) {\n    return 0.5 * base * height;\n}\n</code></pre>"},{"location":"math/trigonometry/#coordinate-transformations","title":"Coordinate Transformations","text":""},{"location":"math/trigonometry/#polar-to-cartesian","title":"Polar to Cartesian","text":"<p>Problem: Convert polar coordinates to Cartesian coordinates.</p> <p>Sample Input: <code>r = 5, \u03b8 = 30\u00b0</code></p> <p>Sample Output:  - <code>x = 4.33, y = 2.5</code></p> <pre><code>struct PolarPoint {\n    double r, theta;  // radius, angle in radians\n\n    PolarPoint(double r, double theta) : r(r), theta(theta) {}\n\n    // Convert to Cartesian\n    pair&lt;double, double&gt; toCartesian() {\n        double x = r * cos(theta);\n        double y = r * sin(theta);\n        return {x, y};\n    }\n};\n\n// Direct conversion\npair&lt;double, double&gt; polarToCartesian(double r, double theta) {\n    return {r * cos(theta), r * sin(theta)};\n}\n</code></pre>"},{"location":"math/trigonometry/#cartesian-to-polar","title":"Cartesian to Polar","text":"<p>Problem: Convert Cartesian coordinates to polar coordinates.</p> <p>Sample Input: <code>x = 3, y = 4</code></p> <p>Sample Output:  - <code>r = 5.0, \u03b8 = 53.13\u00b0</code></p> <pre><code>struct CartesianPoint {\n    double x, y;\n\n    CartesianPoint(double x, double y) : x(x), y(y) {}\n\n    // Convert to polar\n    pair&lt;double, double&gt; toPolar() {\n        double r = sqrt(x*x + y*y);\n        double theta = atan2(y, x);\n        return {r, theta};\n    }\n};\n\n// Direct conversion\npair&lt;double, double&gt; cartesianToPolar(double x, double y) {\n    double r = sqrt(x*x + y*y);\n    double theta = atan2(y, x);\n    return {r, theta};\n}\n</code></pre>"},{"location":"math/trigonometry/#rotation-matrix","title":"Rotation Matrix","text":"<p>Problem: Rotate a point around the origin.</p> <p>Sample Input: <code>x = 1, y = 0, angle = 90\u00b0</code></p> <p>Sample Output:  - <code>x' = 0, y' = 1</code></p> <pre><code>// Rotate point around origin\npair&lt;double, double&gt; rotatePoint(double x, double y, double angle) {\n    double cosA = cos(angle);\n    double sinA = sin(angle);\n\n    double newX = x * cosA - y * sinA;\n    double newY = x * sinA + y * cosA;\n\n    return {newX, newY};\n}\n\n// Rotate point around arbitrary center\npair&lt;double, double&gt; rotatePointAround(double x, double y, double centerX, double centerY, double angle) {\n    // Translate to origin\n    double tx = x - centerX;\n    double ty = y - centerY;\n\n    // Rotate\n    auto rotated = rotatePoint(tx, ty, angle);\n\n    // Translate back\n    return {rotated.first + centerX, rotated.second + centerY};\n}\n</code></pre>"},{"location":"math/trigonometry/#wave-functions","title":"Wave Functions","text":""},{"location":"math/trigonometry/#sine-wave","title":"Sine Wave","text":"<p>Problem: Generate sine wave data points.</p> <p>Sample Input: <code>amplitude = 2, frequency = 1, phase = 0, samples = 10</code></p> <p>Sample Output: <code>[0, 1.236, 2, 1.236, 0, -1.236, -2, -1.236, 0, 1.236]</code></p> <pre><code>vector&lt;double&gt; generateSineWave(double amplitude, double frequency, double phase, int samples) {\n    vector&lt;double&gt; wave;\n    double timeStep = 2 * M_PI / samples;\n\n    for (int i = 0; i &lt; samples; i++) {\n        double t = i * timeStep;\n        double value = amplitude * sin(frequency * t + phase);\n        wave.push_back(value);\n    }\n\n    return wave;\n}\n</code></pre>"},{"location":"math/trigonometry/#fourier-transform-simple","title":"Fourier Transform (Simple)","text":"<p>Problem: Calculate simple Fourier coefficients.</p> <p>Sample Input: <code>signal = [1, 0, -1, 0]</code></p> <p>Sample Output:  - <code>DC component: 0</code> - <code>First harmonic: 1</code></p> <pre><code>// Simple DFT (not optimized)\nvector&lt;complex&lt;double&gt;&gt; discreteFourierTransform(const vector&lt;double&gt;&amp; signal) {\n    int N = signal.size();\n    vector&lt;complex&lt;double&gt;&gt; result(N);\n\n    for (int k = 0; k &lt; N; k++) {\n        complex&lt;double&gt; sum(0, 0);\n        for (int n = 0; n &lt; N; n++) {\n            double angle = -2 * M_PI * k * n / N;\n            sum += signal[n] * complex&lt;double&gt;(cos(angle), sin(angle));\n        }\n        result[k] = sum;\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"math/trigonometry/#common-trigonometric-values","title":"Common Trigonometric Values","text":""},{"location":"math/trigonometry/#special-angles","title":"Special Angles","text":"<p>Problem: Get trigonometric values for special angles.</p> <p>Sample Input: <code>angle = 30\u00b0</code></p> <p>Sample Output:  - <code>sin(30\u00b0) = 0.5</code> - <code>cos(30\u00b0) = \u221a3/2 \u2248 0.866</code></p> <pre><code>// Precomputed values for common angles\nmap&lt;int, pair&lt;double, double&gt;&gt; specialAngles = {\n    {0, {0, 1}},\n    {30, {0.5, sqrt(3)/2}},\n    {45, {sqrt(2)/2, sqrt(2)/2}},\n    {60, {sqrt(3)/2, 0.5}},\n    {90, {1, 0}},\n    {120, {sqrt(3)/2, -0.5}},\n    {135, {sqrt(2)/2, -sqrt(2)/2}},\n    {150, {0.5, -sqrt(3)/2}},\n    {180, {0, -1}}\n};\n\npair&lt;double, double&gt; getSpecialAngleValues(int degrees) {\n    if (specialAngles.find(degrees) != specialAngles.end()) {\n        return specialAngles[degrees];\n    }\n    return {sin(degreesToRadians(degrees)), cos(degreesToRadians(degrees))};\n}\n</code></pre>"},{"location":"math/trigonometry/#use-cases","title":"Use Cases","text":""},{"location":"math/trigonometry/#competitive-programming","title":"Competitive Programming","text":"<ul> <li>Geometric Problems: Angle calculations, rotations</li> <li>Wave Analysis: Signal processing, frequency analysis</li> <li>Coordinate Systems: Transformations between coordinate systems</li> <li>Trigonometric Identities: Simplifying complex expressions</li> </ul>"},{"location":"math/trigonometry/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Computer Graphics: 3D rotations, transformations</li> <li>Physics: Wave motion, oscillations</li> <li>Engineering: Signal processing, control systems</li> <li>Navigation: GPS, compass calculations</li> </ul>"},{"location":"math/trigonometry/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Angle Units: Be consistent with degrees vs radians</li> <li>Precision: Use appropriate precision for calculations</li> <li>Edge Cases: Handle angles outside [0, 2\u03c0] range</li> <li>Numerical Stability: Use stable algorithms for calculations</li> <li>Precomputation: Cache frequently used values</li> <li>Library Functions: Use optimized library functions when available</li> </ol>"},{"location":"simulation/","title":"Simulation &amp; Modeling","text":"<p>Simulation and modeling techniques involve creating computational models to represent real-world scenarios or abstract problems. These methods are particularly useful for problems that require systematic exploration of solution spaces or optimization with specific constraints.</p>"},{"location":"simulation/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link Two Pointer / Sliding Window Efficient techniques for maintaining a dynamic range or window while processing data, commonly used for subarray problems. Two Pointer / Sliding Window Binary Search on Answer An optimization technique that searches for the optimal parameter value using binary search, particularly useful when the problem has monotonic properties. Binary Search on Answer Greedy Algorithms Algorithms that make locally optimal choices at each step, often leading to globally optimal solutions for certain types of problems. Greedy Algorithms"},{"location":"simulation/#when-to-use-simulation-modeling","title":"When to Use Simulation &amp; Modeling","text":"<p>These techniques are effective when: - You need to explore a range of possible solutions - The problem has monotonic or predictable properties - Local optimization can lead to global optimization - Working with constrained optimization problems</p>"},{"location":"simulation/#common-problem-types","title":"Common Problem Types","text":""},{"location":"simulation/#sliding-window-problems","title":"Sliding Window Problems","text":"<ul> <li>Maximum/Minimum Subarray: Finding optimal subarrays of fixed or variable size</li> <li>String Matching: Finding patterns or anagrams in strings</li> <li>Resource Allocation: Optimizing resource usage within constraints</li> </ul>"},{"location":"simulation/#binary-search-applications","title":"Binary Search Applications","text":"<ul> <li>Parameter Optimization: Finding optimal values for problem parameters</li> <li>Feasibility Testing: Determining if a solution exists for given constraints</li> <li>Range Queries: Finding values within specific ranges</li> </ul>"},{"location":"simulation/#greedy-applications","title":"Greedy Applications","text":"<ul> <li>Scheduling: Optimizing task or resource scheduling</li> <li>Coin Change: Finding minimum number of coins for change</li> <li>Huffman Coding: Optimal data compression</li> <li>Minimum Spanning Tree: Finding optimal tree structures</li> </ul>"},{"location":"simulation/binary-search-answer/","title":"Binary Search on Answer","text":"<p>Binary search on answer is a powerful optimization technique that uses binary search to find the optimal parameter value when the problem has monotonic properties. Instead of searching through a sorted array, we search through the space of possible answers.</p>"},{"location":"simulation/binary-search-answer/#how-it-works","title":"How It Works","text":"<p>The technique works when: 1. We can determine if a given answer is feasible (too small, too large, or optimal) 2. The feasibility function is monotonic (if answer X is feasible, then X+1 is also feasible, or vice versa) 3. We're looking for the minimum/maximum feasible answer</p>"},{"location":"simulation/binary-search-answer/#basic-template","title":"Basic Template","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n// Template for binary search on answer\nint binarySearchAnswer(int left, int right, function&lt;bool(int)&gt; isFeasible) {\n    int result = -1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n\n        if (isFeasible(mid)) {\n            result = mid;\n            right = mid - 1;  // Search for smaller feasible answer\n        } else {\n            left = mid + 1;   // Search for larger answer\n        }\n    }\n\n    return result;\n}\n\n// For finding maximum feasible answer\nint binarySearchMaxAnswer(int left, int right, function&lt;bool(int)&gt; isFeasible) {\n    int result = -1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n\n        if (isFeasible(mid)) {\n            result = mid;\n            left = mid + 1;   // Search for larger feasible answer\n        } else {\n            right = mid - 1;  // Search for smaller answer\n        }\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"simulation/binary-search-answer/#example-minimum-capacity-to-ship-packages","title":"Example: Minimum Capacity to Ship Packages","text":"<p>Problem: Given weights of packages and days, find the minimum capacity of a ship to ship all packages within the given days.</p> <p>Sample Input:  - <code>weights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code> - <code>days = 5</code></p> <p>Sample Output: <code>15</code> (Can ship in 5 days with capacity 15)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass ShipPackages {\npublic:\n    int shipWithinDays(vector&lt;int&gt;&amp; weights, int days) {\n        int left = *max_element(weights.begin(), weights.end());\n        int right = accumulate(weights.begin(), weights.end(), 0);\n\n        while (left &lt; right) {\n            int mid = left + (right - left) / 2;\n\n            if (canShip(weights, days, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\nprivate:\n    bool canShip(vector&lt;int&gt;&amp; weights, int days, int capacity) {\n        int currentWeight = 0;\n        int daysNeeded = 1;\n\n        for (int weight : weights) {\n            if (currentWeight + weight &gt; capacity) {\n                daysNeeded++;\n                currentWeight = weight;\n            } else {\n                currentWeight += weight;\n            }\n        }\n\n        return daysNeeded &lt;= days;\n    }\n};\n</code></pre>"},{"location":"simulation/binary-search-answer/#example-koko-eating-bananas","title":"Example: Koko Eating Bananas","text":"<p>Problem: Koko can eat at most h bananas. Find the minimum eating speed to finish all bananas in h hours.</p> <p>Sample Input:  - <code>piles = [3, 6, 7, 11]</code> - <code>h = 8</code></p> <p>Sample Output: <code>4</code> (Eating speed of 4 bananas per hour)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass EatingBananas {\npublic:\n    int minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) {\n        int left = 1;\n        int right = *max_element(piles.begin(), piles.end());\n\n        while (left &lt; right) {\n            int mid = left + (right - left) / 2;\n\n            if (canFinish(piles, h, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\nprivate:\n    bool canFinish(vector&lt;int&gt;&amp; piles, int h, int speed) {\n        int hours = 0;\n\n        for (int pile : piles) {\n            hours += (pile + speed - 1) / speed;  // Ceiling division\n        }\n\n        return hours &lt;= h;\n    }\n};\n</code></pre>"},{"location":"simulation/binary-search-answer/#example-split-array-largest-sum","title":"Example: Split Array Largest Sum","text":"<p>Problem: Split an array into m non-empty continuous subarrays and minimize the largest sum among these subarrays.</p> <p>Sample Input:  - <code>nums = [7, 2, 5, 10, 8]</code> - <code>m = 2</code></p> <p>Sample Output: <code>18</code> (Split: [7,2,5] and [10,8], sums are 14 and 18)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass SplitArray {\npublic:\n    int splitArray(vector&lt;int&gt;&amp; nums, int m) {\n        int left = *max_element(nums.begin(), nums.end());\n        int right = accumulate(nums.begin(), nums.end(), 0);\n\n        while (left &lt; right) {\n            int mid = left + (right - left) / 2;\n\n            if (canSplit(nums, m, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\nprivate:\n    bool canSplit(vector&lt;int&gt;&amp; nums, int m, int maxSum) {\n        int subarrays = 1;\n        int currentSum = 0;\n\n        for (int num : nums) {\n            if (currentSum + num &gt; maxSum) {\n                subarrays++;\n                currentSum = num;\n            } else {\n                currentSum += num;\n            }\n        }\n\n        return subarrays &lt;= m;\n    }\n};\n</code></pre>"},{"location":"simulation/binary-search-answer/#advanced-applications","title":"Advanced Applications","text":""},{"location":"simulation/binary-search-answer/#finding-kth-smallest-element-in-sorted-matrix","title":"Finding Kth Smallest Element in Sorted Matrix","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass KthSmallestInMatrix {\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n        int n = matrix.size();\n        int left = matrix[0][0];\n        int right = matrix[n-1][n-1];\n\n        while (left &lt; right) {\n            int mid = left + (right - left) / 2;\n\n            if (countLessOrEqual(matrix, mid) &lt; k) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return left;\n    }\n\nprivate:\n    int countLessOrEqual(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        int n = matrix.size();\n        int count = 0;\n        int row = n - 1;\n        int col = 0;\n\n        while (row &gt;= 0 &amp;&amp; col &lt; n) {\n            if (matrix[row][col] &lt;= target) {\n                count += row + 1;\n                col++;\n            } else {\n                row--;\n            }\n        }\n\n        return count;\n    }\n};\n</code></pre>"},{"location":"simulation/binary-search-answer/#median-of-two-sorted-arrays","title":"Median of Two Sorted Arrays","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass MedianOfTwoArrays {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        if (nums1.size() &gt; nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n\n        int m = nums1.size();\n        int n = nums2.size();\n        int left = 0, right = m;\n\n        while (left &lt;= right) {\n            int partitionX = (left + right) / 2;\n            int partitionY = (m + n + 1) / 2 - partitionX;\n\n            int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n            int minRightX = (partitionX == m) ? INT_MAX : nums1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n            int minRightY = (partitionY == n) ? INT_MAX : nums2[partitionY];\n\n            if (maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2.0;\n                } else {\n                    return max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX &gt; minRightY) {\n                right = partitionX - 1;\n            } else {\n                left = partitionX + 1;\n            }\n        }\n\n        return 0.0;\n    }\n};\n</code></pre>"},{"location":"simulation/binary-search-answer/#common-problem-patterns","title":"Common Problem Patterns","text":""},{"location":"simulation/binary-search-answer/#1-minimize-maximum-value","title":"1. Minimize Maximum Value","text":"<pre><code>// Find minimum possible maximum value\nint minimizeMax(vector&lt;int&gt;&amp; arr, int k) {\n    int left = 0;\n    int right = *max_element(arr.begin(), arr.end());\n\n    while (left &lt; right) {\n        int mid = left + (right - left) / 2;\n        if (isFeasible(arr, k, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n</code></pre>"},{"location":"simulation/binary-search-answer/#2-maximize-minimum-value","title":"2. Maximize Minimum Value","text":"<pre><code>// Find maximum possible minimum value\nint maximizeMin(vector&lt;int&gt;&amp; arr, int k) {\n    int left = *min_element(arr.begin(), arr.end());\n    int right = *max_element(arr.begin(), arr.end());\n\n    while (left &lt; right) {\n        int mid = left + (right - left + 1) / 2;\n        if (isFeasible(arr, k, mid)) {\n            left = mid;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n}\n</code></pre>"},{"location":"simulation/binary-search-answer/#3-find-exact-value","title":"3. Find Exact Value","text":"<pre><code>// Find exact value that satisfies condition\nint findExactValue(vector&lt;int&gt;&amp; arr, int target) {\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] &lt; target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n</code></pre>"},{"location":"simulation/binary-search-answer/#use-cases","title":"Use Cases","text":""},{"location":"simulation/binary-search-answer/#optimization-problems","title":"Optimization Problems","text":"<ul> <li>Capacity Planning: Finding minimum capacity for given constraints</li> <li>Resource Allocation: Optimizing resource usage</li> <li>Scheduling: Finding optimal time slots or deadlines</li> <li>Load Balancing: Distributing load optimally</li> </ul>"},{"location":"simulation/binary-search-answer/#search-problems","title":"Search Problems","text":"<ul> <li>Parameter Tuning: Finding optimal parameter values</li> <li>Threshold Finding: Determining critical values</li> <li>Range Queries: Finding values in specific ranges</li> <li>Feasibility Testing: Checking if solutions exist</li> </ul>"},{"location":"simulation/binary-search-answer/#mathematical-problems","title":"Mathematical Problems","text":"<ul> <li>Root Finding: Finding roots of equations</li> <li>Optimization: Finding minima/maxima</li> <li>Approximation: Finding approximate solutions</li> <li>Convergence: Iterative improvement</li> </ul>"},{"location":"simulation/binary-search-answer/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"simulation/binary-search-answer/#time-complexity","title":"Time Complexity","text":"<ul> <li>Binary Search: O(log n) where n is the search space size</li> <li>Feasibility Check: Depends on the problem (usually O(n) or O(n log n))</li> <li>Overall: O(f(n) \u00d7 log n) where f(n) is the feasibility check complexity</li> </ul>"},{"location":"simulation/binary-search-answer/#space-complexity","title":"Space Complexity","text":"<ul> <li>Binary Search: O(1) additional space</li> <li>Feasibility Check: Depends on the problem requirements</li> <li>Overall: Usually O(1) or O(n) depending on feasibility check</li> </ul>"},{"location":"simulation/binary-search-answer/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Choose Appropriate Bounds: Set left and right bounds carefully</li> <li>Avoid Integer Overflow: Use <code>left + (right - left) / 2</code> instead of <code>(left + right) / 2</code></li> <li>Handle Edge Cases: Consider empty arrays, single elements, etc.</li> <li>Optimize Feasibility Check: Make the feasibility function as efficient as possible</li> <li>Use Appropriate Comparison: Choose between <code>&lt;</code> and <code>&lt;=</code> based on problem requirements</li> <li>Consider Floating Point: For decimal answers, use appropriate precision</li> </ol>"},{"location":"simulation/greedy-algorithms/","title":"Greedy Algorithms","text":"<p>Greedy algorithms make locally optimal choices at each step with the hope that these choices will lead to a globally optimal solution. They work well for problems that have the greedy choice property and optimal substructure.</p>"},{"location":"simulation/greedy-algorithms/#key-principles","title":"Key Principles","text":"<ol> <li>Greedy Choice Property: A global optimum can be reached by making locally optimal choices</li> <li>Optimal Substructure: The optimal solution contains optimal solutions to subproblems</li> <li>No Backtracking: Once a choice is made, it's never reconsidered</li> </ol>"},{"location":"simulation/greedy-algorithms/#common-greedy-patterns","title":"Common Greedy Patterns","text":""},{"location":"simulation/greedy-algorithms/#1-activity-selection-problem","title":"1. Activity Selection Problem","text":"<p>Problem: Select maximum number of non-overlapping activities from a set of activities.</p> <p>Sample Input:  - Activities: [(1,3), (2,5), (0,6), (5,7), (8,9), (5,9)]</p> <p>Sample Output:  - Selected activities: [(1,3), (5,7), (8,9)] - Maximum activities: 3</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Activity {\n    int start, end;\n    Activity(int s, int e) : start(s), end(e) {}\n};\n\nclass ActivitySelection {\npublic:\n    vector&lt;Activity&gt; selectActivities(vector&lt;Activity&gt;&amp; activities) {\n        // Sort by end time\n        sort(activities.begin(), activities.end(), \n             [](const Activity&amp; a, const Activity&amp; b) {\n                 return a.end &lt; b.end;\n             });\n\n        vector&lt;Activity&gt; selected;\n        selected.push_back(activities[0]);\n        int lastEndTime = activities[0].end;\n\n        for (int i = 1; i &lt; activities.size(); i++) {\n            if (activities[i].start &gt;= lastEndTime) {\n                selected.push_back(activities[i]);\n                lastEndTime = activities[i].end;\n            }\n        }\n\n        return selected;\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#2-fractional-knapsack","title":"2. Fractional Knapsack","text":"<p>Problem: Fill a knapsack with maximum value, allowing fractional items.</p> <p>Sample Input:  - Items: [(60, 10), (100, 20), (120, 30)] (value, weight) - Capacity: 50</p> <p>Sample Output:  - Maximum value: 240 - Items taken: 10kg of item1, 20kg of item2, 20kg of item3</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Item {\n    int value, weight;\n    double ratio;\n\n    Item(int v, int w) : value(v), weight(w) {\n        ratio = (double)value / weight;\n    }\n};\n\nclass FractionalKnapsack {\npublic:\n    double getMaxValue(vector&lt;Item&gt;&amp; items, int capacity) {\n        // Sort by value-to-weight ratio in descending order\n        sort(items.begin(), items.end(), \n             [](const Item&amp; a, const Item&amp; b) {\n                 return a.ratio &gt; b.ratio;\n             });\n\n        double totalValue = 0.0;\n        int remainingCapacity = capacity;\n\n        for (const Item&amp; item : items) {\n            if (remainingCapacity &gt;= item.weight) {\n                // Take the entire item\n                totalValue += item.value;\n                remainingCapacity -= item.weight;\n            } else {\n                // Take fraction of the item\n                totalValue += item.ratio * remainingCapacity;\n                break;\n            }\n        }\n\n        return totalValue;\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#3-huffman-coding","title":"3. Huffman Coding","text":"<p>Problem: Create optimal binary codes for characters based on their frequencies.</p> <p>Sample Input:  - Text: \"aabacdab\"</p> <p>Sample Output:  - Character frequencies: a=4, b=2, c=1, d=1 - Huffman codes: a=0, b=10, c=110, d=111 - Encoded text: \"00100110110010\"</p> <pre><code>#include &lt;queue&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nstruct HuffmanNode {\n    char data;\n    int frequency;\n    HuffmanNode* left, *right;\n\n    HuffmanNode(char d, int freq) : data(d), frequency(freq), left(nullptr), right(nullptr) {}\n    HuffmanNode(int freq) : data('\\0'), frequency(freq), left(nullptr), right(nullptr) {}\n};\n\nclass HuffmanCoding {\nprivate:\n    struct Compare {\n        bool operator()(HuffmanNode* a, HuffmanNode* b) {\n            return a-&gt;frequency &gt; b-&gt;frequency;\n        }\n    };\n\npublic:\n    unordered_map&lt;char, string&gt; buildHuffmanCodes(string text) {\n        // Count frequencies\n        unordered_map&lt;char, int&gt; freq;\n        for (char c : text) {\n            freq[c]++;\n        }\n\n        // Build min heap\n        priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; minHeap;\n        for (auto&amp; pair : freq) {\n            minHeap.push(new HuffmanNode(pair.first, pair.second));\n        }\n\n        // Build Huffman tree\n        while (minHeap.size() &gt; 1) {\n            HuffmanNode* left = minHeap.top();\n            minHeap.pop();\n\n            HuffmanNode* right = minHeap.top();\n            minHeap.pop();\n\n            HuffmanNode* merged = new HuffmanNode(left-&gt;frequency + right-&gt;frequency);\n            merged-&gt;left = left;\n            merged-&gt;right = right;\n\n            minHeap.push(merged);\n        }\n\n        // Generate codes\n        unordered_map&lt;char, string&gt; codes;\n        generateCodes(minHeap.top(), \"\", codes);\n\n        return codes;\n    }\n\nprivate:\n    void generateCodes(HuffmanNode* root, string code, unordered_map&lt;char, string&gt;&amp; codes) {\n        if (!root) return;\n\n        if (root-&gt;data != '\\0') {\n            codes[root-&gt;data] = code;\n            return;\n        }\n\n        generateCodes(root-&gt;left, code + \"0\", codes);\n        generateCodes(root-&gt;right, code + \"1\", codes);\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#classic-greedy-problems","title":"Classic Greedy Problems","text":""},{"location":"simulation/greedy-algorithms/#minimum-spanning-tree-kruskals-algorithm","title":"Minimum Spanning Tree (Kruskal's Algorithm)","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Edge {\n    int src, dest, weight;\n    Edge(int s, int d, int w) : src(s), dest(d), weight(w) {}\n};\n\nclass UnionFind {\nprivate:\n    vector&lt;int&gt; parent, rank;\n\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return;\n\n        if (rank[px] &lt; rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] &gt; rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nclass KruskalMST {\npublic:\n    vector&lt;Edge&gt; findMST(vector&lt;Edge&gt;&amp; edges, int vertices) {\n        // Sort edges by weight\n        sort(edges.begin(), edges.end(), \n             [](const Edge&amp; a, const Edge&amp; b) {\n                 return a.weight &lt; b.weight;\n             });\n\n        UnionFind uf(vertices);\n        vector&lt;Edge&gt; mst;\n\n        for (const Edge&amp; edge : edges) {\n            if (!uf.connected(edge.src, edge.dest)) {\n                mst.push_back(edge);\n                uf.unite(edge.src, edge.dest);\n            }\n        }\n\n        return mst;\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#coin-change-minimum-coins","title":"Coin Change (Minimum Coins)","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nclass CoinChange {\npublic:\n    int minCoins(vector&lt;int&gt;&amp; coins, int amount) {\n        // Sort coins in descending order\n        sort(coins.rbegin(), coins.rend());\n\n        int count = 0;\n        int remaining = amount;\n\n        for (int coin : coins) {\n            if (remaining &gt;= coin) {\n                count += remaining / coin;\n                remaining %= coin;\n            }\n        }\n\n        return (remaining == 0) ? count : -1;\n    }\n\n    // For arbitrary coin systems (not always optimal)\n    int minCoinsDP(vector&lt;int&gt;&amp; coins, int amount) {\n        vector&lt;int&gt; dp(amount + 1, amount + 1);\n        dp[0] = 0;\n\n        for (int i = 1; i &lt;= amount; i++) {\n            for (int coin : coins) {\n                if (coin &lt;= i) {\n                    dp[i] = min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n\n        return (dp[amount] &gt; amount) ? -1 : dp[amount];\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#job-scheduling","title":"Job Scheduling","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Job {\n    int id, deadline, profit;\n    Job(int i, int d, int p) : id(i), deadline(d), profit(p) {}\n};\n\nclass JobScheduling {\npublic:\n    vector&lt;Job&gt; scheduleJobs(vector&lt;Job&gt;&amp; jobs) {\n        // Sort by profit in descending order\n        sort(jobs.begin(), jobs.end(), \n             [](const Job&amp; a, const Job&amp; b) {\n                 return a.profit &gt; b.profit;\n             });\n\n        int maxDeadline = 0;\n        for (const Job&amp; job : jobs) {\n            maxDeadline = max(maxDeadline, job.deadline);\n        }\n\n        vector&lt;bool&gt; slot(maxDeadline + 1, false);\n        vector&lt;Job&gt; scheduled;\n\n        for (const Job&amp; job : jobs) {\n            // Find latest available slot\n            for (int j = min(job.deadline, maxDeadline); j &gt;= 1; j--) {\n                if (!slot[j]) {\n                    slot[j] = true;\n                    scheduled.push_back(job);\n                    break;\n                }\n            }\n        }\n\n        return scheduled;\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#advanced-greedy-applications","title":"Advanced Greedy Applications","text":""},{"location":"simulation/greedy-algorithms/#gas-station-problem","title":"Gas Station Problem","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nclass GasStation {\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int totalTank = 0;\n        int currentTank = 0;\n        int startStation = 0;\n\n        for (int i = 0; i &lt; gas.size(); i++) {\n            totalTank += gas[i] - cost[i];\n            currentTank += gas[i] - cost[i];\n\n            if (currentTank &lt; 0) {\n                startStation = i + 1;\n                currentTank = 0;\n            }\n        }\n\n        return (totalTank &gt;= 0) ? startStation : -1;\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#meeting-rooms","title":"Meeting Rooms","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Interval {\n    int start, end;\n    Interval(int s, int e) : start(s), end(e) {}\n};\n\nclass MeetingRooms {\npublic:\n    int minMeetingRooms(vector&lt;Interval&gt;&amp; intervals) {\n        vector&lt;int&gt; starts, ends;\n\n        for (const Interval&amp; interval : intervals) {\n            starts.push_back(interval.start);\n            ends.push_back(interval.end);\n        }\n\n        sort(starts.begin(), starts.end());\n        sort(ends.begin(), ends.end());\n\n        int rooms = 0;\n        int endIndex = 0;\n\n        for (int i = 0; i &lt; starts.size(); i++) {\n            if (starts[i] &lt; ends[endIndex]) {\n                rooms++;\n            } else {\n                endIndex++;\n            }\n        }\n\n        return rooms;\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#task-scheduler","title":"Task Scheduler","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nclass TaskScheduler {\npublic:\n    int leastInterval(vector&lt;char&gt;&amp; tasks, int n) {\n        vector&lt;int&gt; freq(26, 0);\n        for (char task : tasks) {\n            freq[task - 'A']++;\n        }\n\n        sort(freq.rbegin(), freq.rend());\n\n        int maxFreq = freq[0];\n        int idleSlots = (maxFreq - 1) * n;\n\n        for (int i = 1; i &lt; 26 &amp;&amp; freq[i] &gt; 0; i++) {\n            idleSlots -= min(freq[i], maxFreq - 1);\n        }\n\n        return tasks.size() + max(0, idleSlots);\n    }\n};\n</code></pre>"},{"location":"simulation/greedy-algorithms/#when-to-use-greedy-algorithms","title":"When to Use Greedy Algorithms","text":""},{"location":"simulation/greedy-algorithms/#problems-suitable-for-greedy","title":"Problems Suitable for Greedy","text":"<ul> <li>Activity Selection: Choose activities that finish earliest</li> <li>Fractional Knapsack: Take items with highest value-to-weight ratio</li> <li>Huffman Coding: Build tree by combining least frequent characters</li> <li>Minimum Spanning Tree: Add edges with minimum weight</li> <li>Coin Change: Use largest coins first (for standard coin systems)</li> </ul>"},{"location":"simulation/greedy-algorithms/#problems-not-suitable-for-greedy","title":"Problems NOT Suitable for Greedy","text":"<ul> <li>0/1 Knapsack: Greedy doesn't guarantee optimal solution</li> <li>Traveling Salesman: Greedy can get stuck in local optima</li> <li>Graph Coloring: No simple greedy strategy works</li> <li>Longest Path: Greedy choices don't lead to optimal solution</li> </ul>"},{"location":"simulation/greedy-algorithms/#proving-greedy-correctness","title":"Proving Greedy Correctness","text":""},{"location":"simulation/greedy-algorithms/#1-greedy-choice-property","title":"1. Greedy Choice Property","text":"<p>Show that a globally optimal solution can be reached by making locally optimal choices.</p>"},{"location":"simulation/greedy-algorithms/#2-optimal-substructure","title":"2. Optimal Substructure","text":"<p>Show that the optimal solution contains optimal solutions to subproblems.</p>"},{"location":"simulation/greedy-algorithms/#3-exchange-argument","title":"3. Exchange Argument","text":"<p>Show that any optimal solution can be transformed to include the greedy choice.</p>"},{"location":"simulation/greedy-algorithms/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"simulation/greedy-algorithms/#time-complexity","title":"Time Complexity","text":"<ul> <li>Sorting: Usually O(n log n) for initial sorting</li> <li>Main Algorithm: Often O(n) after sorting</li> <li>Overall: Typically O(n log n)</li> </ul>"},{"location":"simulation/greedy-algorithms/#space-complexity","title":"Space Complexity","text":"<ul> <li>Additional Space: Usually O(1) or O(n) for storing results</li> <li>Sorting Space: O(1) for in-place sorting, O(n) for stable sorting</li> </ul>"},{"location":"simulation/greedy-algorithms/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Identify the Greedy Choice: Determine what makes a choice locally optimal</li> <li>Sort Efficiently: Choose appropriate sorting criteria</li> <li>Use Appropriate Data Structures: Heaps, sets, or arrays as needed</li> <li>Handle Edge Cases: Empty inputs, single elements, ties</li> <li>Prove Correctness: Ensure the greedy choice leads to optimal solution</li> <li>Consider Alternatives: Sometimes DP or other approaches might be better</li> </ol>"},{"location":"simulation/two-pointer-sliding-window/","title":"Two Pointer / Sliding Window","text":"<p>Two pointer and sliding window techniques are efficient methods for solving problems involving arrays or sequences. They maintain a dynamic range or window while processing data, often achieving O(n) time complexity.</p>"},{"location":"simulation/two-pointer-sliding-window/#two-pointer-technique","title":"Two Pointer Technique","text":"<p>Two pointers move through the array from different positions, typically from both ends or at different speeds.</p>"},{"location":"simulation/two-pointer-sliding-window/#basic-template","title":"Basic Template","text":"<p>Problem: Implement a general two-pointer technique for array processing.</p> <p>Sample Input: <code>arr = [1, 2, 3, 4, 5, 6]</code></p> <p>Sample Output: Processes pairs from both ends moving inward</p> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nvoid twoPointers(vector&lt;int&gt;&amp; arr) {\n    int left = 0, right = arr.size() - 1;\n\n    while (left &lt; right) {\n        // Process current pair\n        if (conditionMet(arr[left], arr[right])) {\n            // Handle the case\n            left++;\n            right--;\n        } else if (arr[left] &lt; arr[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n}\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#example-two-sum-sorted-array","title":"Example: Two Sum (Sorted Array)","text":"<p>Problem: Find two numbers in a sorted array that add up to a target sum.</p> <p>Sample Input:  - <code>arr = [2, 7, 11, 15]</code> - <code>target = 9</code></p> <p>Sample Output: <code>[0, 1]</code> (indices of 2 and 7)</p> <pre><code>def two_sum_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left &lt; right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum &lt; target:\n            left += 1\n        else:\n            right -= 1\n\n    return None\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#sliding-window-technique","title":"Sliding Window Technique","text":"<p>A sliding window maintains a subarray/substring of variable or fixed size while moving through the array.</p>"},{"location":"simulation/two-pointer-sliding-window/#fixed-size-window","title":"Fixed Size Window","text":"<p>Problem: Find the maximum sum of any subarray of fixed size k.</p> <p>Sample Input:  - <code>arr = [1, 4, 2, 10, 23, 3, 1, 0, 20]</code> - <code>k = 4</code></p> <p>Sample Output: <code>39</code> (subarray [4, 2, 10, 23])</p> <pre><code>def sliding_window_fixed(arr, k):\n    if len(arr) &lt; k:\n        return []\n\n    window_sum = sum(arr[:k])\n    max_sum = window_sum\n\n    for i in range(k, len(arr)):\n        window_sum = window_sum - arr[i-k] + arr[i]\n        max_sum = max(max_sum, window_sum)\n\n    return max_sum\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#variable-size-window","title":"Variable Size Window","text":"<p>Problem: Find the minimum length subarray with sum greater than or equal to target.</p> <p>Sample Input:  - <code>arr = [2, 3, 1, 2, 4, 3]</code> - <code>target = 7</code></p> <p>Sample Output: <code>2</code> (subarray [4, 3] has sum 7)</p> <pre><code>def sliding_window_variable(arr, target):\n    left = 0\n    window_sum = 0\n    min_length = float('inf')\n\n    for right in range(len(arr)):\n        window_sum += arr[right]\n\n        while window_sum &gt;= target:\n            min_length = min(min_length, right - left + 1)\n            window_sum -= arr[left]\n            left += 1\n\n    return min_length if min_length != float('inf') else 0\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#common-applications","title":"Common Applications","text":""},{"location":"simulation/two-pointer-sliding-window/#maximum-subarray-sum","title":"Maximum Subarray Sum","text":"<pre><code>def max_subarray_sum(arr):\n    max_sum = current_sum = arr[0]\n\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#longest-substring-without-repeating-characters","title":"Longest Substring Without Repeating Characters","text":"<pre><code>def longest_unique_substring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#container-with-most-water","title":"Container With Most Water","text":"<pre><code>def max_area(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n\n    while left &lt; right:\n        width = right - left\n        current_area = width * min(height[left], height[right])\n        max_area = max(max_area, current_area)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return max_area\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"simulation/two-pointer-sliding-window/#fast-and-slow-pointers","title":"Fast and Slow Pointers","text":"<pre><code>def detect_cycle(head):\n    slow = fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#three-pointers","title":"Three Pointers","text":"<pre><code>def three_sum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i &gt; 0 and nums[i] == nums[i-1]:\n            continue\n\n        left, right = i + 1, len(nums) - 1\n\n        while left &lt; right:\n            current_sum = nums[i] + nums[left] + nums[right]\n\n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left+1]:\n                    left += 1\n                while left &lt; right and nums[right] == nums[right-1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n            elif current_sum &lt; 0:\n                left += 1\n            else:\n                right -= 1\n\n    return result\n</code></pre>"},{"location":"simulation/two-pointer-sliding-window/#when-to-use-each-technique","title":"When to Use Each Technique","text":""},{"location":"simulation/two-pointer-sliding-window/#use-two-pointers-when","title":"Use Two Pointers When:","text":"<ul> <li>Array is sorted</li> <li>Need to find pairs/triplets</li> <li>Working with palindromes</li> <li>Need to partition array</li> </ul>"},{"location":"simulation/two-pointer-sliding-window/#use-sliding-window-when","title":"Use Sliding Window When:","text":"<ul> <li>Working with subarrays/substrings</li> <li>Need to find optimal window size</li> <li>Problem involves contiguous elements</li> <li>Need to maintain running statistics</li> </ul>"},{"location":"simulation/two-pointer-sliding-window/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Time Complexity: Usually O(n) for single pass</li> <li>Space Complexity: Usually O(1) for two pointers, O(k) for sliding window where k is window size</li> </ul>"},{"location":"simulation/two-pointer-sliding-window/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Early Termination: Stop when condition is met</li> <li>Skip Duplicates: Avoid processing duplicate elements</li> <li>Boundary Checks: Always check array bounds</li> <li>State Maintenance: Keep track of window state efficiently</li> <li>Memory Optimization: Use variables instead of data structures when possible</li> </ol>"},{"location":"string-bitwise/","title":"String &amp; Bitwise Techniques","text":"<p>String and bitwise techniques involve specialized algorithms for text processing, pattern matching, and bit manipulation. These methods are essential for text analysis, data compression, and optimization problems that can be solved using bitwise operations.</p>"},{"location":"string-bitwise/#techniques-in-this-category","title":"Techniques in This Category","text":"Technique Description Link KMP / Z Algorithm Efficient pattern matching algorithms for finding substring occurrences in text, with linear time complexity. KMP / Z Algorithm Trie / Aho-Corasick Tree-based data structures for prefix matching and multiple pattern searching, commonly used in autocomplete systems. Trie / Aho-Corasick Bitmask Tricks Bitwise manipulation techniques for representing and manipulating subsets, often used for optimization and state representation. Bitmask Tricks"},{"location":"string-bitwise/#when-to-use-string-bitwise-techniques","title":"When to Use String &amp; Bitwise Techniques","text":"<p>These techniques are essential when: - Working with text processing and pattern matching - Need to represent subsets or states efficiently - Solving problems that can benefit from bitwise operations - Building search engines or text analysis systems</p>"},{"location":"string-bitwise/#common-applications","title":"Common Applications","text":""},{"location":"string-bitwise/#string-algorithms","title":"String Algorithms","text":"<ul> <li>Pattern Matching: Finding occurrences of patterns in text</li> <li>String Comparison: Efficient string similarity and distance calculations</li> <li>Text Compression: Reducing storage requirements for text data</li> <li>Lexicographic Sorting: Ordering strings alphabetically</li> </ul>"},{"location":"string-bitwise/#bitwise-techniques","title":"Bitwise Techniques","text":"<ul> <li>Subset Generation: Efficiently generating all subsets of a set</li> <li>State Representation: Compact representation of problem states</li> <li>Optimization: Using bitwise operations for performance improvements</li> <li>Parity Checking: Detecting even/odd properties using XOR</li> </ul>"},{"location":"string-bitwise/bitmask-tricks/","title":"Bitmask Tricks","text":"<p>Bitmask tricks involve using binary representations and bitwise operations to efficiently solve problems that involve subsets, state representation, and combinatorial optimization. These techniques are particularly powerful for problems with small state spaces that can be represented as integers.</p>"},{"location":"string-bitwise/bitmask-tricks/#basic-bitwise-operations","title":"Basic Bitwise Operations","text":"<p>Understanding fundamental bitwise operations is crucial for bitmask techniques:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid demonstrateBitwiseOps() {\n    int a = 5;  // Binary: 101\n    int b = 3;  // Binary: 011\n\n    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \" (binary: \" &lt;&lt; bitset&lt;8&gt;(a) &lt;&lt; \")\" &lt;&lt; endl;\n    cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; \" (binary: \" &lt;&lt; bitset&lt;8&gt;(b) &lt;&lt; \")\" &lt;&lt; endl;\n\n    // Basic operations\n    cout &lt;&lt; \"a &amp; b = \" &lt;&lt; (a &amp; b) &lt;&lt; \" (AND)\" &lt;&lt; endl;\n    cout &lt;&lt; \"a | b = \" &lt;&lt; (a | b) &lt;&lt; \" (OR)\" &lt;&lt; endl;\n    cout &lt;&lt; \"a ^ b = \" &lt;&lt; (a ^ b) &lt;&lt; \" (XOR)\" &lt;&lt; endl;\n    cout &lt;&lt; \"~a = \" &lt;&lt; (~a) &lt;&lt; \" (NOT)\" &lt;&lt; endl;\n    cout &lt;&lt; \"a &lt;&lt; 1 = \" &lt;&lt; (a &lt;&lt; 1) &lt;&lt; \" (Left shift)\" &lt;&lt; endl;\n    cout &lt;&lt; \"a &gt;&gt; 1 = \" &lt;&lt; (a &gt;&gt; 1) &lt;&lt; \" (Right shift)\" &lt;&lt; endl;\n}\n</code></pre>"},{"location":"string-bitwise/bitmask-tricks/#common-bitmask-operations","title":"Common Bitmask Operations","text":""},{"location":"string-bitwise/bitmask-tricks/#setting-clearing-and-toggling-bits","title":"Setting, Clearing, and Toggling Bits","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass BitmaskUtils {\npublic:\n    // Set the i-th bit (0-indexed)\n    static int setBit(int mask, int i) {\n        return mask | (1 &lt;&lt; i);\n    }\n\n    // Clear the i-th bit\n    static int clearBit(int mask, int i) {\n        return mask &amp; ~(1 &lt;&lt; i);\n    }\n\n    // Toggle the i-th bit\n    static int toggleBit(int mask, int i) {\n        return mask ^ (1 &lt;&lt; i);\n    }\n\n    // Check if the i-th bit is set\n    static bool isBitSet(int mask, int i) {\n        return (mask &amp; (1 &lt;&lt; i)) != 0;\n    }\n\n    // Count number of set bits\n    static int countSetBits(int mask) {\n        int count = 0;\n        while (mask) {\n            count += mask &amp; 1;\n            mask &gt;&gt;= 1;\n        }\n        return count;\n    }\n\n    // Get the lowest set bit\n    static int getLowestSetBit(int mask) {\n        return mask &amp; (-mask);\n    }\n\n    // Remove the lowest set bit\n    static int removeLowestSetBit(int mask) {\n        return mask &amp; (mask - 1);\n    }\n\n    // Check if mask is a power of 2\n    static bool isPowerOfTwo(int mask) {\n        return mask &gt; 0 &amp;&amp; (mask &amp; (mask - 1)) == 0;\n    }\n};\n</code></pre>"},{"location":"string-bitwise/bitmask-tricks/#subset-generation","title":"Subset Generation","text":""},{"location":"string-bitwise/bitmask-tricks/#generate-all-subsets","title":"Generate All Subsets","text":"<p>Problem: Generate all possible subsets of an array using bitmask techniques.</p> <p>Sample Input: <code>arr = [1, 2, 3]</code></p> <p>Sample Output:  <pre><code>All subsets: [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]\nSubsets of size 2: [[1,2], [1,3], [2,3]]\n</code></pre></p> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; generateAllSubsets(vector&lt;int&gt;&amp; arr) {\n    int n = arr.size();\n    vector&lt;vector&lt;int&gt;&gt; subsets;\n\n    // Generate all 2^n subsets\n    for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {\n        vector&lt;int&gt; subset;\n        for (int i = 0; i &lt; n; i++) {\n            if (mask &amp; (1 &lt;&lt; i)) {\n                subset.push_back(arr[i]);\n            }\n        }\n        subsets.push_back(subset);\n    }\n\n    return subsets;\n}\n\n// Generate subsets of specific size\nvector&lt;vector&lt;int&gt;&gt; generateSubsetsOfSize(vector&lt;int&gt;&amp; arr, int k) {\n    int n = arr.size();\n    vector&lt;vector&lt;int&gt;&gt; subsets;\n\n    for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {\n        if (__builtin_popcount(mask) == k) {  // Count set bits\n            vector&lt;int&gt; subset;\n            for (int i = 0; i &lt; n; i++) {\n                if (mask &amp; (1 &lt;&lt; i)) {\n                    subset.push_back(arr[i]);\n                }\n            }\n            subsets.push_back(subset);\n        }\n    }\n\n    return subsets;\n}\n</code></pre>"},{"location":"string-bitwise/bitmask-tricks/#traveling-salesman-problem-tsp","title":"Traveling Salesman Problem (TSP)","text":"<p>The TSP is a classic example where bitmasks represent visited cities:</p> <p>Problem: Find the shortest route that visits each city exactly once and returns to the starting city.</p> <p>Sample Input:  <pre><code>Distance matrix:\n   0  10  15  20\n  10   0  35  25\n  15  35   0  30\n  20  25  30   0\n</code></pre></p> <p>Sample Output: <code>80</code> (Route: 0 \u2192 1 \u2192 3 \u2192 2 \u2192 0)</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass TSP {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; dist;\n    vector&lt;vector&lt;int&gt;&gt; dp;\n    int n;\n\npublic:\n    int solveTSP(vector&lt;vector&lt;int&gt;&gt;&amp; distance) {\n        n = distance.size();\n        dist = distance;\n        dp.assign(1 &lt;&lt; n, vector&lt;int&gt;(n, -1));\n\n        return tsp(1, 0);  // Start from city 0, only city 0 visited\n    }\n\nprivate:\n    int tsp(int mask, int pos) {\n        // If all cities visited, return to start\n        if (mask == (1 &lt;&lt; n) - 1) {\n            return dist[pos][0];\n        }\n\n        if (dp[mask][pos] != -1) {\n            return dp[mask][pos];\n        }\n\n        int minCost = INT_MAX;\n\n        // Try visiting each unvisited city\n        for (int next = 0; next &lt; n; next++) {\n            if (!(mask &amp; (1 &lt;&lt; next))) {  // If city not visited\n                int newMask = mask | (1 &lt;&lt; next);\n                int cost = dist[pos][next] + tsp(newMask, next);\n                minCost = min(minCost, cost);\n            }\n        }\n\n        return dp[mask][pos] = minCost;\n    }\n};\n</code></pre>"},{"location":"string-bitwise/bitmask-tricks/#dynamic-programming-with-bitmasks","title":"Dynamic Programming with Bitmasks","text":""},{"location":"string-bitwise/bitmask-tricks/#assignment-problem","title":"Assignment Problem","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nclass AssignmentProblem {\npublic:\n    int solveAssignment(vector&lt;vector&lt;int&gt;&gt;&amp; cost) {\n        int n = cost.size();\n        vector&lt;int&gt; dp(1 &lt;&lt; n, INT_MAX);\n        dp[0] = 0;  // Base case: no assignments made\n\n        for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {\n            int assigned = __builtin_popcount(mask);\n\n            for (int i = 0; i &lt; n; i++) {\n                if (!(mask &amp; (1 &lt;&lt; i))) {  // If task i not assigned\n                    int newMask = mask | (1 &lt;&lt; i);\n                    dp[newMask] = min(dp[newMask], dp[mask] + cost[assigned][i]);\n                }\n            }\n        }\n\n        return dp[(1 &lt;&lt; n) - 1];\n    }\n};\n</code></pre>"},{"location":"string-bitwise/bitmask-tricks/#state-space-search","title":"State Space Search","text":""},{"location":"string-bitwise/bitmask-tricks/#n-queens-problem","title":"N-Queens Problem","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass NQueens {\nprivate:\n    int n;\n    vector&lt;int&gt; queens;\n\npublic:\n    int solveNQueens(int boardSize) {\n        n = boardSize;\n        queens.resize(n);\n        return backtrack(0, 0, 0, 0);\n    }\n\nprivate:\n    int backtrack(int row, int colMask, int diag1Mask, int diag2Mask) {\n        if (row == n) {\n            return 1;  // Found a valid solution\n        }\n\n        int solutions = 0;\n\n        for (int col = 0; col &lt; n; col++) {\n            int pos = 1 &lt;&lt; col;\n            int diag1 = 1 &lt;&lt; (row + col);\n            int diag2 = 1 &lt;&lt; (row - col + n - 1);\n\n            // Check if position is safe\n            if (!(colMask &amp; pos) &amp;&amp; !(diag1Mask &amp; diag1) &amp;&amp; !(diag2Mask &amp; diag2)) {\n                queens[row] = col;\n                solutions += backtrack(row + 1, \n                                    colMask | pos, \n                                    diag1Mask | diag1, \n                                    diag2Mask | diag2);\n            }\n        }\n\n        return solutions;\n    }\n};\n</code></pre>"},{"location":"string-bitwise/bitmask-tricks/#advanced-bitmask-techniques","title":"Advanced Bitmask Techniques","text":""},{"location":"string-bitwise/bitmask-tricks/#fast-subset-iteration","title":"Fast Subset Iteration","text":"<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\n// Iterate through all subsets of a set\nvoid iterateSubsets(int set) {\n    for (int subset = set; subset; subset = (subset - 1) &amp; set) {\n        // Process subset\n        cout &lt;&lt; \"Subset: \" &lt;&lt; bitset&lt;8&gt;(subset) &lt;&lt; endl;\n    }\n}\n\n// Iterate through all supersets of a set\nvoid iterateSupersets(int set, int universe) {\n    for (int superset = set; superset &lt;= universe; superset = (superset + 1) | set) {\n        // Process superset\n        cout &lt;&lt; \"Superset: \" &lt;&lt; bitset&lt;8&gt;(superset) &lt;&lt; endl;\n    }\n}\n</code></pre>"},{"location":"string-bitwise/bitmask-tricks/#bit-manipulation-tricks","title":"Bit Manipulation Tricks","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass AdvancedBitTricks {\npublic:\n    // Swap two numbers without temporary variable\n    static void swap(int&amp; a, int&amp; b) {\n        a ^= b;\n        b ^= a;\n        a ^= b;\n    }\n\n    // Check if number is even/odd\n    static bool isEven(int n) {\n        return (n &amp; 1) == 0;\n    }\n\n    // Get absolute value without branching\n    static int abs(int n) {\n        int mask = n &gt;&gt; 31;  // All 1s if negative, all 0s if positive\n        return (n + mask) ^ mask;\n    }\n\n    // Find the next power of 2\n    static int nextPowerOfTwo(int n) {\n        n--;\n        n |= n &gt;&gt; 1;\n        n |= n &gt;&gt; 2;\n        n |= n &gt;&gt; 4;\n        n |= n &gt;&gt; 8;\n        n |= n &gt;&gt; 16;\n        return n + 1;\n    }\n\n    // Reverse bits\n    static unsigned int reverseBits(unsigned int n) {\n        n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1);\n        n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2);\n        n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) | ((n &amp; 0x0F0F0F0F) &lt;&lt; 4);\n        n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) | ((n &amp; 0x00FF00FF) &lt;&lt; 8);\n        n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) | ((n &amp; 0x0000FFFF) &lt;&lt; 16);\n        return n;\n    }\n};\n</code></pre>"},{"location":"string-bitwise/bitmask-tricks/#use-cases","title":"Use Cases","text":""},{"location":"string-bitwise/bitmask-tricks/#optimization-problems","title":"Optimization Problems","text":"<ul> <li>Traveling Salesman Problem: Representing visited cities</li> <li>Assignment Problems: Tracking assigned tasks</li> <li>Scheduling Problems: Representing time slots or resources</li> <li>Graph Coloring: Representing color assignments</li> </ul>"},{"location":"string-bitwise/bitmask-tricks/#combinatorial-problems","title":"Combinatorial Problems","text":"<ul> <li>Subset Generation: All possible combinations</li> <li>Permutation Problems: State representation</li> <li>Partition Problems: Dividing sets into groups</li> <li>Coverage Problems: Selecting minimum sets</li> </ul>"},{"location":"string-bitwise/bitmask-tricks/#state-space-search_1","title":"State Space Search","text":"<ul> <li>Game States: Chess, checkers, tic-tac-toe</li> <li>Puzzle Solving: 15-puzzle, sliding puzzles</li> <li>Constraint Satisfaction: N-queens, sudoku</li> <li>Path Finding: With state constraints</li> </ul>"},{"location":"string-bitwise/bitmask-tricks/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"string-bitwise/bitmask-tricks/#time-complexity","title":"Time Complexity","text":"<ul> <li>Subset Generation: O(2^n) for n elements</li> <li>TSP with Bitmask DP: O(n\u00b2 \u00d7 2^n)</li> <li>Assignment Problem: O(n\u00b2 \u00d7 2^n)</li> <li>Bit Operations: O(1) for most operations</li> </ul>"},{"location":"string-bitwise/bitmask-tricks/#space-complexity","title":"Space Complexity","text":"<ul> <li>Bitmask DP: O(2^n \u00d7 n) for state space</li> <li>Subset Storage: O(2^n) for all subsets</li> <li>Bit Operations: O(1) additional space</li> </ul>"},{"location":"string-bitwise/bitmask-tricks/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use Built-in Functions: <code>__builtin_popcount()</code>, <code>__builtin_clz()</code>, etc.</li> <li>Precompute Powers: Store 2^i values for efficiency</li> <li>Memory Optimization: Use bit manipulation instead of boolean arrays</li> <li>Early Pruning: Skip impossible states early</li> <li>State Compression: Combine multiple boolean states into single integers</li> <li>Cache Optimization: Use bitmasks as array indices for better cache locality</li> </ol>"},{"location":"string-bitwise/kmp-z-algorithm/","title":"KMP / Z Algorithm","text":"<p>The Knuth-Morris-Pratt (KMP) and Z algorithms are efficient pattern matching algorithms that find all occurrences of a pattern in a text string. Both algorithms achieve linear time complexity O(n + m) where n is the text length and m is the pattern length.</p>"},{"location":"string-bitwise/kmp-z-algorithm/#kmp-algorithm","title":"KMP Algorithm","text":"<p>The KMP algorithm uses a failure function (also called LPS - Longest Proper Prefix which is also a Suffix) to avoid unnecessary character comparisons.</p>"},{"location":"string-bitwise/kmp-z-algorithm/#how-it-works","title":"How It Works","text":"<ol> <li>Preprocessing: Build a failure function that determines the longest proper prefix of the pattern that is also a suffix</li> <li>Matching: Use the failure function to skip characters that are guaranteed to match</li> </ol>"},{"location":"string-bitwise/kmp-z-algorithm/#kmp-implementation","title":"KMP Implementation","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\n// Build failure function (LPS array)\nvector&lt;int&gt; buildFailureFunction(string pattern) {\n    int m = pattern.length();\n    vector&lt;int&gt; lps(m, 0);\n    int len = 0;  // Length of the previous longest prefix suffix\n\n    for (int i = 1; i &lt; m; i++) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n                i--;  // Don't increment i\n            } else {\n                lps[i] = 0;\n            }\n        }\n    }\n\n    return lps;\n}\n\n// Find all occurrences of pattern in text\nvector&lt;int&gt; kmpSearch(string text, string pattern) {\n    vector&lt;int&gt; lps = buildFailureFunction(pattern);\n    vector&lt;int&gt; matches;\n\n    int n = text.length();\n    int m = pattern.length();\n    int i = 0;  // Index for text\n    int j = 0;  // Index for pattern\n\n    while (i &lt; n) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n\n        if (j == m) {\n            matches.push_back(i - j);  // Pattern found at position i-j\n            j = lps[j - 1];\n        } else if (i &lt; n &amp;&amp; pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n\n    return matches;\n}\n</code></pre>"},{"location":"string-bitwise/kmp-z-algorithm/#z-algorithm","title":"Z Algorithm","text":"<p>The Z algorithm builds a Z-array where Z[i] represents the length of the longest substring starting from position i that is also a prefix of the string.</p>"},{"location":"string-bitwise/kmp-z-algorithm/#z-algorithm-implementation","title":"Z Algorithm Implementation","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\n// Build Z-array for a string\nvector&lt;int&gt; buildZArray(string s) {\n    int n = s.length();\n    vector&lt;int&gt; z(n, 0);\n\n    int l = 0, r = 0;  // Left and right boundaries of the Z-box\n\n    for (int i = 1; i &lt; n; i++) {\n        if (i &lt;= r) {\n            z[i] = min(r - i + 1, z[i - l]);\n        }\n\n        while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n\n        if (i + z[i] - 1 &gt; r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n\n    return z;\n}\n\n// Find all occurrences of pattern in text using Z algorithm\nvector&lt;int&gt; zSearch(string text, string pattern) {\n    string combined = pattern + \"$\" + text;\n    vector&lt;int&gt; z = buildZArray(combined);\n    vector&lt;int&gt; matches;\n\n    int m = pattern.length();\n\n    for (int i = m + 1; i &lt; z.size(); i++) {\n        if (z[i] == m) {\n            matches.push_back(i - m - 1);\n        }\n    }\n\n    return matches;\n}\n</code></pre>"},{"location":"string-bitwise/kmp-z-algorithm/#example-pattern-matching","title":"Example: Pattern Matching","text":"<p>Problem: Find all occurrences of a pattern string in a text string.</p> <p>Sample Input:  - <code>text = \"ABABDABACDABABCABAB\"</code> - <code>pattern = \"ABABCABAB\"</code></p> <p>Sample Output:  - KMP matches at positions: <code>10</code> - Z algorithm matches at positions: <code>10</code></p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    string text = \"ABABDABACDABABCABAB\";\n    string pattern = \"ABABCABAB\";\n\n    // Using KMP\n    vector&lt;int&gt; kmpMatches = kmpSearch(text, pattern);\n    cout &lt;&lt; \"KMP matches at positions: \";\n    for (int pos : kmpMatches) {\n        cout &lt;&lt; pos &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    // Using Z algorithm\n    vector&lt;int&gt; zMatches = zSearch(text, pattern);\n    cout &lt;&lt; \"Z algorithm matches at positions: \";\n    for (int pos : zMatches) {\n        cout &lt;&lt; pos &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"string-bitwise/kmp-z-algorithm/#advanced-applications","title":"Advanced Applications","text":""},{"location":"string-bitwise/kmp-z-algorithm/#multiple-pattern-matching","title":"Multiple Pattern Matching","text":"<p>Problem: Find all occurrences of multiple patterns in a text string.</p> <p>Sample Input:  - <code>text = \"ushers\"</code> - <code>patterns = [\"he\", \"she\", \"his\", \"hers\"]</code></p> <p>Sample Output:  <pre><code>[\n  {\"he\", [1]},\n  {\"she\", [2]},\n  {\"his\", []},\n  {\"hers\", [3]}\n]\n</code></pre></p> <pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\n// Find all patterns in text using KMP\nvector&lt;pair&lt;string, vector&lt;int&gt;&gt;&gt; findMultiplePatterns(string text, vector&lt;string&gt; patterns) {\n    vector&lt;pair&lt;string, vector&lt;int&gt;&gt;&gt; results;\n\n    for (string pattern : patterns) {\n        vector&lt;int&gt; matches = kmpSearch(text, pattern);\n        results.push_back({pattern, matches});\n    }\n\n    return results;\n}\n</code></pre>"},{"location":"string-bitwise/kmp-z-algorithm/#longest-common-substring","title":"Longest Common Substring","text":"<p>Problem: Find the longest common substring between two strings.</p> <p>Sample Input:  - <code>s1 = \"ABABC\"</code> - <code>s2 = \"BABCA\"</code></p> <p>Sample Output: <code>\"BABC\"</code></p> <pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstring longestCommonSubstring(string s1, string s2) {\n    string combined = s1 + \"$\" + s2;\n    vector&lt;int&gt; z = buildZArray(combined);\n\n    int maxLen = 0;\n    int startPos = 0;\n\n    for (int i = s1.length() + 1; i &lt; z.size(); i++) {\n        if (z[i] &gt; maxLen) {\n            maxLen = z[i];\n            startPos = i - s1.length() - 1;\n        }\n    }\n\n    return s2.substr(startPos, maxLen);\n}\n</code></pre>"},{"location":"string-bitwise/kmp-z-algorithm/#use-cases","title":"Use Cases","text":"<ul> <li>Text Search: Finding all occurrences of a pattern in text</li> <li>DNA Sequence Analysis: Pattern matching in biological sequences</li> <li>Plagiarism Detection: Finding similar text patterns</li> <li>String Compression: LZ77 and similar algorithms</li> <li>Regular Expression Matching: Building regex engines</li> </ul>"},{"location":"string-bitwise/kmp-z-algorithm/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"string-bitwise/kmp-z-algorithm/#kmp-algorithm_1","title":"KMP Algorithm","text":"<ul> <li>Time Complexity: O(n + m) for preprocessing and searching</li> <li>Space Complexity: O(m) for the failure function</li> </ul>"},{"location":"string-bitwise/kmp-z-algorithm/#z-algorithm_1","title":"Z Algorithm","text":"<ul> <li>Time Complexity: O(n + m) for building Z-array and searching</li> <li>Space Complexity: O(n + m) for the Z-array</li> </ul>"},{"location":"string-bitwise/kmp-z-algorithm/#when-to-use-which-algorithm","title":"When to Use Which Algorithm","text":""},{"location":"string-bitwise/kmp-z-algorithm/#use-kmp-when","title":"Use KMP when:","text":"<ul> <li>You need to find all occurrences of a single pattern</li> <li>Memory usage is a concern (KMP uses less space)</li> <li>You need the failure function for other applications</li> </ul>"},{"location":"string-bitwise/kmp-z-algorithm/#use-z-algorithm-when","title":"Use Z Algorithm when:","text":"<ul> <li>You need to find the longest common prefix at each position</li> <li>You're working with multiple pattern matching</li> <li>You need to find palindromes or other string properties</li> </ul>"},{"location":"string-bitwise/kmp-z-algorithm/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Early Termination: Stop searching if only the first occurrence is needed</li> <li>Memory Optimization: Use Z algorithm for single-pass applications</li> <li>Pattern Preprocessing: Cache failure functions for repeated pattern searches</li> <li>String Concatenation: Minimize string operations in the Z algorithm</li> </ol>"},{"location":"string-bitwise/trie-aho-corasick/","title":"Trie / Aho-Corasick","text":"<p>Trie (prefix tree) and Aho-Corasick are powerful data structures for string processing, particularly useful for multiple pattern matching and prefix-based operations. The Aho-Corasick algorithm extends the trie with failure links for efficient multiple pattern matching.</p>"},{"location":"string-bitwise/trie-aho-corasick/#trie-data-structure","title":"Trie Data Structure","text":"<p>A trie is a tree-like data structure where each node represents a character, and paths from root to leaves represent strings.</p>"},{"location":"string-bitwise/trie-aho-corasick/#basic-trie-implementation","title":"Basic Trie Implementation","text":"<pre><code>#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass TrieNode {\npublic:\n    unordered_map&lt;char, TrieNode*&gt; children;\n    bool isEndOfWord;\n    string word;  // Store the complete word at end nodes\n\n    TrieNode() : isEndOfWord(false) {}\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n\n    // Insert a word into the trie\n    void insert(string word) {\n        TrieNode* current = root;\n\n        for (char c : word) {\n            if (current-&gt;children.find(c) == current-&gt;children.end()) {\n                current-&gt;children[c] = new TrieNode();\n            }\n            current = current-&gt;children[c];\n        }\n\n        current-&gt;isEndOfWord = true;\n        current-&gt;word = word;\n    }\n\n    // Search for a word in the trie\n    bool search(string word) {\n        TrieNode* current = root;\n\n        for (char c : word) {\n            if (current-&gt;children.find(c) == current-&gt;children.end()) {\n                return false;\n            }\n            current = current-&gt;children[c];\n        }\n\n        return current-&gt;isEndOfWord;\n    }\n\n    // Check if any word starts with the given prefix\n    bool startsWith(string prefix) {\n        TrieNode* current = root;\n\n        for (char c : prefix) {\n            if (current-&gt;children.find(c) == current-&gt;children.end()) {\n                return false;\n            }\n            current = current-&gt;children[c];\n        }\n\n        return true;\n    }\n\n    // Get all words with the given prefix\n    vector&lt;string&gt; getWordsWithPrefix(string prefix) {\n        vector&lt;string&gt; result;\n        TrieNode* current = root;\n\n        // Navigate to the prefix node\n        for (char c : prefix) {\n            if (current-&gt;children.find(c) == current-&gt;children.end()) {\n                return result;  // No words with this prefix\n            }\n            current = current-&gt;children[c];\n        }\n\n        // DFS to collect all words from this node\n        collectWords(current, result);\n        return result;\n    }\n\nprivate:\n    void collectWords(TrieNode* node, vector&lt;string&gt;&amp; result) {\n        if (node-&gt;isEndOfWord) {\n            result.push_back(node-&gt;word);\n        }\n\n        for (auto&amp; pair : node-&gt;children) {\n            collectWords(pair.second, result);\n        }\n    }\n};\n</code></pre>"},{"location":"string-bitwise/trie-aho-corasick/#aho-corasick-algorithm","title":"Aho-Corasick Algorithm","text":"<p>The Aho-Corasick algorithm extends the trie with failure links to efficiently find all occurrences of multiple patterns in a text.</p>"},{"location":"string-bitwise/trie-aho-corasick/#aho-corasick-implementation","title":"Aho-Corasick Implementation","text":"<pre><code>#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nclass AhoCorasickNode {\npublic:\n    unordered_map&lt;char, AhoCorasickNode*&gt; children;\n    AhoCorasickNode* failure;\n    vector&lt;string&gt; output;  // Patterns that end at this node\n    bool isEndOfWord;\n\n    AhoCorasickNode() : failure(nullptr), isEndOfWord(false) {}\n};\n\nclass AhoCorasick {\nprivate:\n    AhoCorasickNode* root;\n\npublic:\n    AhoCorasick() {\n        root = new AhoCorasickNode();\n    }\n\n    // Build the trie with patterns\n    void buildTrie(vector&lt;string&gt; patterns) {\n        for (string pattern : patterns) {\n            insertPattern(pattern);\n        }\n        buildFailureLinks();\n    }\n\n    // Insert a single pattern\n    void insertPattern(string pattern) {\n        AhoCorasickNode* current = root;\n\n        for (char c : pattern) {\n            if (current-&gt;children.find(c) == current-&gt;children.end()) {\n                current-&gt;children[c] = new AhoCorasickNode();\n            }\n            current = current-&gt;children[c];\n        }\n\n        current-&gt;isEndOfWord = true;\n        current-&gt;output.push_back(pattern);\n    }\n\n    // Build failure links using BFS\n    void buildFailureLinks() {\n        queue&lt;AhoCorasickNode*&gt; q;\n\n        // Initialize failure links for root's children\n        for (auto&amp; pair : root-&gt;children) {\n            pair.second-&gt;failure = root;\n            q.push(pair.second);\n        }\n\n        while (!q.empty()) {\n            AhoCorasickNode* current = q.front();\n            q.pop();\n\n            for (auto&amp; pair : current-&gt;children) {\n                char c = pair.first;\n                AhoCorasickNode* child = pair.second;\n\n                AhoCorasickNode* failure = current-&gt;failure;\n\n                // Find the longest proper suffix that is also a prefix\n                while (failure != root &amp;&amp; failure-&gt;children.find(c) == failure-&gt;children.end()) {\n                    failure = failure-&gt;failure;\n                }\n\n                if (failure-&gt;children.find(c) != failure-&gt;children.end()) {\n                    child-&gt;failure = failure-&gt;children[c];\n                } else {\n                    child-&gt;failure = root;\n                }\n\n                // Merge output functions\n                child-&gt;output.insert(child-&gt;output.end(), \n                                   child-&gt;failure-&gt;output.begin(), \n                                   child-&gt;failure-&gt;output.end());\n\n                q.push(child);\n            }\n        }\n    }\n\n    // Search for all patterns in text\n    vector&lt;pair&lt;string, int&gt;&gt; search(string text) {\n        vector&lt;pair&lt;string, int&gt;&gt; matches;\n        AhoCorasickNode* current = root;\n\n        for (int i = 0; i &lt; text.length(); i++) {\n            char c = text[i];\n\n            // Follow failure links until we find a child with character c\n            while (current != root &amp;&amp; current-&gt;children.find(c) == current-&gt;children.end()) {\n                current = current-&gt;failure;\n            }\n\n            if (current-&gt;children.find(c) != current-&gt;children.end()) {\n                current = current-&gt;children[c];\n            } else {\n                current = root;\n            }\n\n            // Add all patterns that end at current node\n            for (string pattern : current-&gt;output) {\n                matches.push_back({pattern, i - pattern.length() + 1});\n            }\n        }\n\n        return matches;\n    }\n};\n</code></pre>"},{"location":"string-bitwise/trie-aho-corasick/#example-multiple-pattern-matching","title":"Example: Multiple Pattern Matching","text":"<p>Problem: Implement a trie for word storage and an Aho-Corasick automaton for multiple pattern matching.</p> <p>Sample Input:  - Trie operations: insert \"hello\", \"world\", \"hell\", \"he\" - Aho-Corasick patterns: [\"he\", \"she\", \"his\", \"hers\"] - Text: \"ushers\"</p> <p>Sample Output:  <pre><code>Search 'hello': 1\nSearch 'hel': 0\nStarts with 'he': 1\nWords with prefix 'he': he hell hello\n\nPatterns found in 'ushers':\nPattern 'he' at position 1\nPattern 'she' at position 2\nPattern 'hers' at position 3\n</code></pre></p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    // Example usage of Trie\n    Trie trie;\n    trie.insert(\"hello\");\n    trie.insert(\"world\");\n    trie.insert(\"hell\");\n    trie.insert(\"he\");\n\n    cout &lt;&lt; \"Search 'hello': \" &lt;&lt; trie.search(\"hello\") &lt;&lt; endl;\n    cout &lt;&lt; \"Search 'hel': \" &lt;&lt; trie.search(\"hel\") &lt;&lt; endl;\n    cout &lt;&lt; \"Starts with 'he': \" &lt;&lt; trie.startsWith(\"he\") &lt;&lt; endl;\n\n    vector&lt;string&gt; words = trie.getWordsWithPrefix(\"he\");\n    cout &lt;&lt; \"Words with prefix 'he': \";\n    for (string word : words) {\n        cout &lt;&lt; word &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    // Example usage of Aho-Corasick\n    AhoCorasick ac;\n    vector&lt;string&gt; patterns = {\"he\", \"she\", \"his\", \"hers\"};\n    ac.buildTrie(patterns);\n\n    string text = \"ushers\";\n    vector&lt;pair&lt;string, int&gt;&gt; matches = ac.search(text);\n\n    cout &lt;&lt; \"Patterns found in '\" &lt;&lt; text &lt;&lt; \"':\" &lt;&lt; endl;\n    for (auto&amp; match : matches) {\n        cout &lt;&lt; \"Pattern '\" &lt;&lt; match.first &lt;&lt; \"' at position \" &lt;&lt; match.second &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"string-bitwise/trie-aho-corasick/#advanced-applications","title":"Advanced Applications","text":""},{"location":"string-bitwise/trie-aho-corasick/#autocomplete-system","title":"Autocomplete System","text":"<pre><code>class AutocompleteSystem {\nprivate:\n    Trie trie;\n\npublic:\n    void addWord(string word) {\n        trie.insert(word);\n    }\n\n    vector&lt;string&gt; getSuggestions(string prefix) {\n        return trie.getWordsWithPrefix(prefix);\n    }\n};\n</code></pre>"},{"location":"string-bitwise/trie-aho-corasick/#word-search-in-2d-grid","title":"Word Search in 2D Grid","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass WordSearch {\nprivate:\n    vector&lt;vector&lt;char&gt;&gt; board;\n    int rows, cols;\n    vector&lt;string&gt; words;\n    vector&lt;string&gt; result;\n\npublic:\n    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) {\n        this-&gt;board = board;\n        this-&gt;words = words;\n        rows = board.size();\n        cols = board[0].size();\n\n        // Build trie from words\n        Trie trie;\n        for (string word : words) {\n            trie.insert(word);\n        }\n\n        // Search from each cell\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                dfs(i, j, \"\", trie.root);\n            }\n        }\n\n        return result;\n    }\n\nprivate:\n    void dfs(int row, int col, string current, TrieNode* node) {\n        if (row &lt; 0 || row &gt;= rows || col &lt; 0 || col &gt;= cols || board[row][col] == '#') {\n            return;\n        }\n\n        char c = board[row][col];\n        if (node-&gt;children.find(c) == node-&gt;children.end()) {\n            return;\n        }\n\n        current += c;\n        node = node-&gt;children[c];\n\n        if (node-&gt;isEndOfWord) {\n            result.push_back(current);\n            node-&gt;isEndOfWord = false;  // Avoid duplicates\n        }\n\n        board[row][col] = '#';  // Mark as visited\n\n        // Explore all four directions\n        dfs(row + 1, col, current, node);\n        dfs(row - 1, col, current, node);\n        dfs(row, col + 1, current, node);\n        dfs(row, col - 1, current, node);\n\n        board[row][col] = c;  // Restore\n    }\n};\n</code></pre>"},{"location":"string-bitwise/trie-aho-corasick/#use-cases","title":"Use Cases","text":""},{"location":"string-bitwise/trie-aho-corasick/#trie-applications","title":"Trie Applications","text":"<ul> <li>Autocomplete Systems: Finding words with given prefixes</li> <li>Spell Checkers: Validating word existence</li> <li>IP Routing: Longest prefix matching</li> <li>Text Compression: LZW algorithm</li> <li>Dictionary Operations: Fast word lookup</li> </ul>"},{"location":"string-bitwise/trie-aho-corasick/#aho-corasick-applications","title":"Aho-Corasick Applications","text":"<ul> <li>Multiple Pattern Matching: Finding all patterns in text</li> <li>Virus Detection: Scanning for multiple virus signatures</li> <li>Text Mining: Extracting multiple keywords</li> <li>DNA Sequence Analysis: Finding multiple gene patterns</li> <li>Network Intrusion Detection: Pattern matching in network traffic</li> </ul>"},{"location":"string-bitwise/trie-aho-corasick/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"string-bitwise/trie-aho-corasick/#trie-operations","title":"Trie Operations","text":"<ul> <li>Insert: O(m) where m is the length of the word</li> <li>Search: O(m) where m is the length of the word</li> <li>Prefix Search: O(m) where m is the length of the prefix</li> <li>Space: O(ALPHABET_SIZE * N * M) where N is number of words and M is average length</li> </ul>"},{"location":"string-bitwise/trie-aho-corasick/#aho-corasick","title":"Aho-Corasick","text":"<ul> <li>Preprocessing: O(sum of pattern lengths)</li> <li>Search: O(text length + number of matches)</li> <li>Space: O(sum of pattern lengths)</li> </ul>"},{"location":"string-bitwise/trie-aho-corasick/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Memory Optimization: Use array instead of hash map for small alphabets</li> <li>Compression: Implement compressed tries (radix trees) for space efficiency</li> <li>Lazy Loading: Build trie nodes only when needed</li> <li>Caching: Cache frequently accessed nodes</li> <li>Early Termination: Stop searching when no more matches are possible</li> </ol>"}]}